// Package api comment
// This file was generated by tars2go 1.1.4
// Generated from api.tars
package api

import (
	"fmt"

	"github.com/TarsCloud/TarsGo/tars/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

// ChannelLocation struct implement
type ChannelLocation struct {
	Constructor int32                `json:"constructor"`
	Data        ChannelLocation_Data `json:"data"`
}

func (st *ChannelLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChannelLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChannelLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChannelLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChannelLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChannelLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChannelLocation_Data struct implement
type ChannelLocation_Data struct {
	Geo_point GeoPoint `json:"geo_point"`
	Address   string   `json:"address"`
}

func (st *ChannelLocation_Data) ResetDefault() {
	st.Geo_point.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChannelLocation_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Geo_point.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Address, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChannelLocation_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChannelLocation_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChannelLocation_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Geo_point.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Address, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChannelLocation_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelLocationEmpty struct implement
type TLchannelLocationEmpty struct {
	Data ChannelLocation_Data `json:"data"`
}

func (st *TLchannelLocationEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelLocationEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelLocationEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelLocationEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelLocationEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelLocationEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelLocation struct implement
type TLchannelLocation struct {
	Data ChannelLocation_Data `json:"data"`
}

func (st *TLchannelLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PostAddress struct implement
type PostAddress struct {
	Constructor int32            `json:"constructor"`
	Data        PostAddress_Data `json:"data"`
}

func (st *PostAddress) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PostAddress) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PostAddress) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PostAddress, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PostAddress) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PostAddress) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PostAddress_Data struct implement
type PostAddress_Data struct {
	Street_line1 string `json:"street_line1"`
	Street_line2 string `json:"street_line2"`
	City         string `json:"city"`
	State        string `json:"state"`
	Country_iso2 string `json:"country_iso2"`
	Post_code    string `json:"post_code"`
}

func (st *PostAddress_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *PostAddress_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Street_line1, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Street_line2, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.City, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.State, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Country_iso2, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Post_code, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PostAddress_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PostAddress_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PostAddress_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Street_line1, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Street_line2, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.City, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.State, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Country_iso2, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Post_code, 5)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PostAddress_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpostAddress struct implement
type TLpostAddress struct {
	Data PostAddress_Data `json:"data"`
}

func (st *TLpostAddress) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpostAddress) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpostAddress) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpostAddress, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpostAddress) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpostAddress) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_AffectedHistory struct implement
type Messages_AffectedHistory struct {
	Constructor int32                         `json:"constructor"`
	Data        Messages_AffectedHistory_Data `json:"data"`
}

func (st *Messages_AffectedHistory) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_AffectedHistory) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_AffectedHistory) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_AffectedHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_AffectedHistory) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_AffectedHistory) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_AffectedHistory_Data struct implement
type Messages_AffectedHistory_Data struct {
	Pts       int32 `json:"pts"`
	Pts_count int32 `json:"pts_count"`
	Offset    int32 `json:"offset"`
}

func (st *Messages_AffectedHistory_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_AffectedHistory_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Pts, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Pts_count, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_AffectedHistory_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_AffectedHistory_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_AffectedHistory_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Pts, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Pts_count, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_AffectedHistory_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_affectedHistory struct implement
type TLmessages_affectedHistory struct {
	Data Messages_AffectedHistory_Data `json:"data"`
}

func (st *TLmessages_affectedHistory) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_affectedHistory) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_affectedHistory) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_affectedHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_affectedHistory) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_affectedHistory) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputThemeSettings struct implement
type InputThemeSettings struct {
	Constructor int32                   `json:"constructor"`
	Data        InputThemeSettings_Data `json:"data"`
}

func (st *InputThemeSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputThemeSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputThemeSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputThemeSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputThemeSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputThemeSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputThemeSettings_Data struct implement
type InputThemeSettings_Data struct {
	Base_theme           BaseTheme         `json:"base_theme"`
	Accent_color         int32             `json:"accent_color"`
	Message_top_color    int32             `json:"message_top_color"`
	Message_bottom_color int32             `json:"message_bottom_color"`
	Wallpaper            InputWallPaper    `json:"wallpaper"`
	Wallpaper_settings   WallPaperSettings `json:"wallpaper_settings"`
}

func (st *InputThemeSettings_Data) ResetDefault() {
	st.Base_theme.ResetDefault()
	st.Wallpaper.ResetDefault()
	st.Wallpaper_settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputThemeSettings_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Base_theme.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Accent_color, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Message_top_color, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Message_bottom_color, 3, false)
	if err != nil {
		return err
	}

	err = st.Wallpaper.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = st.Wallpaper_settings.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputThemeSettings_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputThemeSettings_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputThemeSettings_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Base_theme.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Accent_color, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Message_top_color, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Message_bottom_color, 3)
	if err != nil {
		return err
	}

	err = st.Wallpaper.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = st.Wallpaper_settings.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputThemeSettings_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputThemeSettings struct implement
type TLinputThemeSettings struct {
	Data InputThemeSettings_Data `json:"data"`
}

func (st *TLinputThemeSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputThemeSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputThemeSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputThemeSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputThemeSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputThemeSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChannelAdminLogEvent struct implement
type ChannelAdminLogEvent struct {
	Constructor int32                     `json:"constructor"`
	Data        ChannelAdminLogEvent_Data `json:"data"`
}

func (st *ChannelAdminLogEvent) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChannelAdminLogEvent) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChannelAdminLogEvent) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChannelAdminLogEvent, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChannelAdminLogEvent) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChannelAdminLogEvent) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChannelAdminLogEvent_Data struct implement
type ChannelAdminLogEvent_Data struct {
	Id      int64                      `json:"id"`
	Date    int32                      `json:"date"`
	User_id int32                      `json:"user_id"`
	Action  ChannelAdminLogEventAction `json:"action"`
}

func (st *ChannelAdminLogEvent_Data) ResetDefault() {
	st.Action.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChannelAdminLogEvent_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.User_id, 2, false)
	if err != nil {
		return err
	}

	err = st.Action.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChannelAdminLogEvent_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChannelAdminLogEvent_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChannelAdminLogEvent_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.User_id, 2)
	if err != nil {
		return err
	}

	err = st.Action.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChannelAdminLogEvent_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEvent struct implement
type TLchannelAdminLogEvent struct {
	Data ChannelAdminLogEvent_Data `json:"data"`
}

func (st *TLchannelAdminLogEvent) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEvent) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEvent) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEvent, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEvent) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEvent) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_Password struct implement
type Account_Password struct {
	Constructor int32                 `json:"constructor"`
	Data        Account_Password_Data `json:"data"`
}

func (st *Account_Password) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_Password) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_Password) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_Password, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_Password) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_Password) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_Password_Data struct implement
type Account_Password_Data struct {
	Has_recovery              bool                  `json:"has_recovery"`
	Has_secure_values         bool                  `json:"has_secure_values"`
	Has_password              bool                  `json:"has_password"`
	Current_algo              PasswordKdfAlgo       `json:"current_algo"`
	Srp_B                     []uint8               `json:"srp_B"`
	Srp_id                    int64                 `json:"srp_id"`
	Hint                      string                `json:"hint"`
	Email_unconfirmed_pattern string                `json:"email_unconfirmed_pattern"`
	New_algo                  PasswordKdfAlgo       `json:"new_algo"`
	New_secure_algo           SecurePasswordKdfAlgo `json:"new_secure_algo"`
	Secure_random             []uint8               `json:"secure_random"`
}

func (st *Account_Password_Data) ResetDefault() {
	st.Current_algo.ResetDefault()
	st.New_algo.ResetDefault()
	st.New_secure_algo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_Password_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Has_recovery, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Has_secure_values, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Has_password, 2, false)
	if err != nil {
		return err
	}

	err = st.Current_algo.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Srp_B = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Srp_B[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Srp_B, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int64(&st.Srp_id, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Hint, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Email_unconfirmed_pattern, 7, false)
	if err != nil {
		return err
	}

	err = st.New_algo.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err = st.New_secure_algo.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(10, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Secure_random = make([]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_uint8(&st.Secure_random[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Secure_random, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_Password_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_Password_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_Password_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Has_recovery, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Has_secure_values, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Has_password, 2)
	if err != nil {
		return err
	}

	err = st.Current_algo.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Srp_B)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Srp_B {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int64(st.Srp_id, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Hint, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Email_unconfirmed_pattern, 7)
	if err != nil {
		return err
	}

	err = st.New_algo.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = st.New_secure_algo.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 10)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Secure_random)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Secure_random {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_Password_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_password struct implement
type TLaccount_password struct {
	Data Account_Password_Data `json:"data"`
}

func (st *TLaccount_password) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_password) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_password) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_password, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_password) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_password) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ImportedContact struct implement
type ImportedContact struct {
	Constructor int32                `json:"constructor"`
	Data        ImportedContact_Data `json:"data"`
}

func (st *ImportedContact) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ImportedContact) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ImportedContact) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ImportedContact, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ImportedContact) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ImportedContact) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ImportedContact_Data struct implement
type ImportedContact_Data struct {
	User_id   int32 `json:"user_id"`
	Client_id int64 `json:"client_id"`
}

func (st *ImportedContact_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *ImportedContact_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Client_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ImportedContact_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ImportedContact_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ImportedContact_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.User_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Client_id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ImportedContact_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLimportedContact struct implement
type TLimportedContact struct {
	Data ImportedContact_Data `json:"data"`
}

func (st *TLimportedContact) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLimportedContact) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLimportedContact) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLimportedContact, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLimportedContact) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLimportedContact) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// UserStatus struct implement
type UserStatus struct {
	Constructor int32           `json:"constructor"`
	Data        UserStatus_Data `json:"data"`
}

func (st *UserStatus) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *UserStatus) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *UserStatus) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserStatus, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *UserStatus) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *UserStatus) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// UserStatus_Data struct implement
type UserStatus_Data struct {
	Expires    int32 `json:"expires"`
	Was_online int32 `json:"was_online"`
}

func (st *UserStatus_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *UserStatus_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Expires, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Was_online, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *UserStatus_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserStatus_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *UserStatus_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Expires, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Was_online, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *UserStatus_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLuserStatusEmpty struct implement
type TLuserStatusEmpty struct {
	Data UserStatus_Data `json:"data"`
}

func (st *TLuserStatusEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLuserStatusEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLuserStatusEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLuserStatusEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLuserStatusEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLuserStatusEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLuserStatusOnline struct implement
type TLuserStatusOnline struct {
	Data UserStatus_Data `json:"data"`
}

func (st *TLuserStatusOnline) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLuserStatusOnline) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLuserStatusOnline) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLuserStatusOnline, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLuserStatusOnline) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLuserStatusOnline) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLuserStatusOffline struct implement
type TLuserStatusOffline struct {
	Data UserStatus_Data `json:"data"`
}

func (st *TLuserStatusOffline) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLuserStatusOffline) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLuserStatusOffline) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLuserStatusOffline, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLuserStatusOffline) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLuserStatusOffline) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLuserStatusRecently struct implement
type TLuserStatusRecently struct {
	Data UserStatus_Data `json:"data"`
}

func (st *TLuserStatusRecently) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLuserStatusRecently) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLuserStatusRecently) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLuserStatusRecently, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLuserStatusRecently) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLuserStatusRecently) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLuserStatusLastWeek struct implement
type TLuserStatusLastWeek struct {
	Data UserStatus_Data `json:"data"`
}

func (st *TLuserStatusLastWeek) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLuserStatusLastWeek) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLuserStatusLastWeek) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLuserStatusLastWeek, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLuserStatusLastWeek) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLuserStatusLastWeek) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLuserStatusLastMonth struct implement
type TLuserStatusLastMonth struct {
	Data UserStatus_Data `json:"data"`
}

func (st *TLuserStatusLastMonth) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLuserStatusLastMonth) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLuserStatusLastMonth) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLuserStatusLastMonth, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLuserStatusLastMonth) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLuserStatusLastMonth) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputPaymentCredentials struct implement
type InputPaymentCredentials struct {
	Constructor int32                        `json:"constructor"`
	Data        InputPaymentCredentials_Data `json:"data"`
}

func (st *InputPaymentCredentials) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputPaymentCredentials) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputPaymentCredentials) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputPaymentCredentials, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputPaymentCredentials) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputPaymentCredentials) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputPaymentCredentials_Data struct implement
type InputPaymentCredentials_Data struct {
	Id                    string   `json:"id"`
	Tmp_password          []uint8  `json:"tmp_password"`
	Save                  bool     `json:"save"`
	Data                  DataJSON `json:"data"`
	Payment_data          DataJSON `json:"payment_data"`
	Payment_token         DataJSON `json:"payment_token"`
	Google_transaction_id string   `json:"google_transaction_id"`
}

func (st *InputPaymentCredentials_Data) ResetDefault() {
	st.Data.ResetDefault()
	st.Payment_data.ResetDefault()
	st.Payment_token.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputPaymentCredentials_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Tmp_password = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Tmp_password[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Tmp_password, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_bool(&st.Save, 2, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = st.Payment_data.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = st.Payment_token.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Google_transaction_id, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputPaymentCredentials_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputPaymentCredentials_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputPaymentCredentials_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Tmp_password)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Tmp_password {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_bool(st.Save, 2)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = st.Payment_data.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = st.Payment_token.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Google_transaction_id, 6)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputPaymentCredentials_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPaymentCredentialsSaved struct implement
type TLinputPaymentCredentialsSaved struct {
	Data InputPaymentCredentials_Data `json:"data"`
}

func (st *TLinputPaymentCredentialsSaved) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPaymentCredentialsSaved) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPaymentCredentialsSaved) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPaymentCredentialsSaved, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPaymentCredentialsSaved) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPaymentCredentialsSaved) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPaymentCredentials struct implement
type TLinputPaymentCredentials struct {
	Data InputPaymentCredentials_Data `json:"data"`
}

func (st *TLinputPaymentCredentials) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPaymentCredentials) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPaymentCredentials) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPaymentCredentials, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPaymentCredentials) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPaymentCredentials) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPaymentCredentialsApplePay struct implement
type TLinputPaymentCredentialsApplePay struct {
	Data InputPaymentCredentials_Data `json:"data"`
}

func (st *TLinputPaymentCredentialsApplePay) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPaymentCredentialsApplePay) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPaymentCredentialsApplePay) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPaymentCredentialsApplePay, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPaymentCredentialsApplePay) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPaymentCredentialsApplePay) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPaymentCredentialsAndroidPay struct implement
type TLinputPaymentCredentialsAndroidPay struct {
	Data InputPaymentCredentials_Data `json:"data"`
}

func (st *TLinputPaymentCredentialsAndroidPay) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPaymentCredentialsAndroidPay) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPaymentCredentialsAndroidPay) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPaymentCredentialsAndroidPay, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPaymentCredentialsAndroidPay) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPaymentCredentialsAndroidPay) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PeerBlocked struct implement
type PeerBlocked struct {
	Constructor int32            `json:"constructor"`
	Data        PeerBlocked_Data `json:"data"`
}

func (st *PeerBlocked) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PeerBlocked) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PeerBlocked) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PeerBlocked, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PeerBlocked) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PeerBlocked) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PeerBlocked_Data struct implement
type PeerBlocked_Data struct {
	Peer_id Peer  `json:"peer_id"`
	Date    int32 `json:"date"`
}

func (st *PeerBlocked_Data) ResetDefault() {
	st.Peer_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PeerBlocked_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer_id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PeerBlocked_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PeerBlocked_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PeerBlocked_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer_id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PeerBlocked_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpeerBlocked struct implement
type TLpeerBlocked struct {
	Data PeerBlocked_Data `json:"data"`
}

func (st *TLpeerBlocked) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpeerBlocked) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpeerBlocked) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpeerBlocked, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpeerBlocked) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpeerBlocked) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StatsGroupTopPoster struct implement
type StatsGroupTopPoster struct {
	Constructor int32                    `json:"constructor"`
	Data        StatsGroupTopPoster_Data `json:"data"`
}

func (st *StatsGroupTopPoster) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *StatsGroupTopPoster) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StatsGroupTopPoster) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StatsGroupTopPoster, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StatsGroupTopPoster) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StatsGroupTopPoster) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StatsGroupTopPoster_Data struct implement
type StatsGroupTopPoster_Data struct {
	User_id   int32 `json:"user_id"`
	Messages  int32 `json:"messages"`
	Avg_chars int32 `json:"avg_chars"`
}

func (st *StatsGroupTopPoster_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *StatsGroupTopPoster_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Messages, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Avg_chars, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StatsGroupTopPoster_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StatsGroupTopPoster_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StatsGroupTopPoster_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.User_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Messages, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Avg_chars, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StatsGroupTopPoster_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstatsGroupTopPoster struct implement
type TLstatsGroupTopPoster struct {
	Data StatsGroupTopPoster_Data `json:"data"`
}

func (st *TLstatsGroupTopPoster) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstatsGroupTopPoster) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstatsGroupTopPoster) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstatsGroupTopPoster, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstatsGroupTopPoster) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstatsGroupTopPoster) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Updates_Difference struct implement
type Updates_Difference struct {
	Constructor int32                   `json:"constructor"`
	Data        Updates_Difference_Data `json:"data"`
}

func (st *Updates_Difference) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Updates_Difference) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Updates_Difference) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Updates_Difference, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Updates_Difference) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Updates_Difference) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Updates_Difference_Data struct implement
type Updates_Difference_Data struct {
	Date                   int32              `json:"date"`
	Seq                    int32              `json:"seq"`
	New_messages           []Message          `json:"new_messages"`
	New_encrypted_messages []EncryptedMessage `json:"new_encrypted_messages"`
	Other_updates          []Update           `json:"other_updates"`
	Chats                  []Chat             `json:"chats"`
	Users                  []User             `json:"users"`
	State                  Updates_State      `json:"state"`
	Intermediate_state     Updates_State      `json:"intermediate_state"`
	Pts                    int32              `json:"pts"`
}

func (st *Updates_Difference_Data) ResetDefault() {
	st.State.ResetDefault()
	st.Intermediate_state.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Updates_Difference_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Date, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Seq, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.New_messages = make([]Message, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.New_messages[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.New_encrypted_messages = make([]EncryptedMessage, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.New_encrypted_messages[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Other_updates = make([]Update, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Other_updates[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Chats[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = st.Users[i4].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.State.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	err = st.Intermediate_state.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Pts, 9, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Updates_Difference_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Updates_Difference_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Updates_Difference_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Date, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Seq, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.New_messages)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.New_messages {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.New_encrypted_messages)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.New_encrypted_messages {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Other_updates)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Other_updates {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.State.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	err = st.Intermediate_state.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Pts, 9)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Updates_Difference_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdates_differenceEmpty struct implement
type TLupdates_differenceEmpty struct {
	Data Updates_Difference_Data `json:"data"`
}

func (st *TLupdates_differenceEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdates_differenceEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdates_differenceEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdates_differenceEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdates_differenceEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdates_differenceEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdates_difference struct implement
type TLupdates_difference struct {
	Data Updates_Difference_Data `json:"data"`
}

func (st *TLupdates_difference) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdates_difference) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdates_difference) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdates_difference, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdates_difference) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdates_difference) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdates_differenceSlice struct implement
type TLupdates_differenceSlice struct {
	Data Updates_Difference_Data `json:"data"`
}

func (st *TLupdates_differenceSlice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdates_differenceSlice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdates_differenceSlice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdates_differenceSlice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdates_differenceSlice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdates_differenceSlice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdates_differenceTooLong struct implement
type TLupdates_differenceTooLong struct {
	Data Updates_Difference_Data `json:"data"`
}

func (st *TLupdates_differenceTooLong) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdates_differenceTooLong) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdates_differenceTooLong) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdates_differenceTooLong, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdates_differenceTooLong) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdates_differenceTooLong) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageEntity struct implement
type MessageEntity struct {
	Constructor int32              `json:"constructor"`
	Data        MessageEntity_Data `json:"data"`
}

func (st *MessageEntity) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageEntity) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageEntity) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageEntity, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageEntity) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageEntity) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageEntity_Data struct implement
type MessageEntity_Data struct {
	Offset    int32     `json:"offset"`
	Length    int32     `json:"length"`
	Language  string    `json:"language"`
	Url       string    `json:"url"`
	User_id   int32     `json:"user_id"`
	User_id_6 InputUser `json:"user_id_6"`
}

func (st *MessageEntity_Data) ResetDefault() {
	st.User_id_6.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageEntity_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Offset, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Length, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Language, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Url, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.User_id, 4, false)
	if err != nil {
		return err
	}

	err = st.User_id_6.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageEntity_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageEntity_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageEntity_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Offset, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Length, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Language, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Url, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.User_id, 4)
	if err != nil {
		return err
	}

	err = st.User_id_6.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageEntity_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityUnknown struct implement
type TLmessageEntityUnknown struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityUnknown) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityUnknown) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityUnknown) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityUnknown, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityUnknown) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityUnknown) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityMention struct implement
type TLmessageEntityMention struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityMention) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityMention) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityMention) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityMention, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityMention) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityMention) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityHashtag struct implement
type TLmessageEntityHashtag struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityHashtag) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityHashtag) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityHashtag) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityHashtag, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityHashtag) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityHashtag) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityBotCommand struct implement
type TLmessageEntityBotCommand struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityBotCommand) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityBotCommand) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityBotCommand) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityBotCommand, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityBotCommand) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityBotCommand) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityUrl struct implement
type TLmessageEntityUrl struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityUrl) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityUrl) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityUrl) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityUrl, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityUrl) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityUrl) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityEmail struct implement
type TLmessageEntityEmail struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityEmail) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityEmail) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityEmail) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityEmail, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityEmail) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityEmail) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityBold struct implement
type TLmessageEntityBold struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityBold) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityBold) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityBold) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityBold, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityBold) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityBold) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityItalic struct implement
type TLmessageEntityItalic struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityItalic) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityItalic) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityItalic) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityItalic, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityItalic) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityItalic) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityCode struct implement
type TLmessageEntityCode struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityCode) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityCode) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityCode) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityCode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityCode) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityCode) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityPre struct implement
type TLmessageEntityPre struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityPre) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityPre) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityPre) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityPre, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityPre) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityPre) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityTextUrl struct implement
type TLmessageEntityTextUrl struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityTextUrl) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityTextUrl) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityTextUrl) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityTextUrl, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityTextUrl) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityTextUrl) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityMentionName struct implement
type TLmessageEntityMentionName struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityMentionName) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityMentionName) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityMentionName) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityMentionName, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityMentionName) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityMentionName) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessageEntityMentionName struct implement
type TLinputMessageEntityMentionName struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLinputMessageEntityMentionName) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessageEntityMentionName) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessageEntityMentionName) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessageEntityMentionName, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessageEntityMentionName) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessageEntityMentionName) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityPhone struct implement
type TLmessageEntityPhone struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityPhone) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityPhone) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityPhone) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityPhone, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityPhone) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityPhone) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityCashtag struct implement
type TLmessageEntityCashtag struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityCashtag) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityCashtag) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityCashtag) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityCashtag, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityCashtag) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityCashtag) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityUnderline struct implement
type TLmessageEntityUnderline struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityUnderline) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityUnderline) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityUnderline) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityUnderline, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityUnderline) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityUnderline) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityStrike struct implement
type TLmessageEntityStrike struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityStrike) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityStrike) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityStrike) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityStrike, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityStrike) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityStrike) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityBlockquote struct implement
type TLmessageEntityBlockquote struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityBlockquote) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityBlockquote) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityBlockquote) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityBlockquote, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityBlockquote) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityBlockquote) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEntityBankCard struct implement
type TLmessageEntityBankCard struct {
	Data MessageEntity_Data `json:"data"`
}

func (st *TLmessageEntityBankCard) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEntityBankCard) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEntityBankCard) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEntityBankCard, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEntityBankCard) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEntityBankCard) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PollResults struct implement
type PollResults struct {
	Constructor int32            `json:"constructor"`
	Data        PollResults_Data `json:"data"`
}

func (st *PollResults) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PollResults) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PollResults) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PollResults, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PollResults) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PollResults) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PollResults_Data struct implement
type PollResults_Data struct {
	Min               bool               `json:"min"`
	Results           []PollAnswerVoters `json:"results"`
	Total_voters      int32              `json:"total_voters"`
	Recent_voters     []int32            `json:"recent_voters"`
	Solution          string             `json:"solution"`
	Solution_entities []MessageEntity    `json:"solution_entities"`
}

func (st *PollResults_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *PollResults_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Min, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Results = make([]PollAnswerVoters, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Results[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Total_voters, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Recent_voters = make([]int32, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int32(&st.Recent_voters[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Solution, 4, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Solution_entities = make([]MessageEntity, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Solution_entities[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PollResults_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PollResults_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PollResults_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Min, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Results)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Results {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Total_voters, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Recent_voters)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Recent_voters {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Solution, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Solution_entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Solution_entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PollResults_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpollResults struct implement
type TLpollResults struct {
	Data PollResults_Data `json:"data"`
}

func (st *TLpollResults) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpollResults) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpollResults) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpollResults, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpollResults) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpollResults) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// NotifyPeer struct implement
type NotifyPeer struct {
	Constructor int32           `json:"constructor"`
	Data        NotifyPeer_Data `json:"data"`
}

func (st *NotifyPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *NotifyPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *NotifyPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require NotifyPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *NotifyPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *NotifyPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// NotifyPeer_Data struct implement
type NotifyPeer_Data struct {
	Peer Peer `json:"peer"`
}

func (st *NotifyPeer_Data) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *NotifyPeer_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *NotifyPeer_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require NotifyPeer_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *NotifyPeer_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *NotifyPeer_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLnotifyPeer struct implement
type TLnotifyPeer struct {
	Data NotifyPeer_Data `json:"data"`
}

func (st *TLnotifyPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLnotifyPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLnotifyPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLnotifyPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLnotifyPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLnotifyPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLnotifyUsers struct implement
type TLnotifyUsers struct {
	Data NotifyPeer_Data `json:"data"`
}

func (st *TLnotifyUsers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLnotifyUsers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLnotifyUsers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLnotifyUsers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLnotifyUsers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLnotifyUsers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLnotifyChats struct implement
type TLnotifyChats struct {
	Data NotifyPeer_Data `json:"data"`
}

func (st *TLnotifyChats) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLnotifyChats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLnotifyChats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLnotifyChats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLnotifyChats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLnotifyChats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLnotifyBroadcasts struct implement
type TLnotifyBroadcasts struct {
	Data NotifyPeer_Data `json:"data"`
}

func (st *TLnotifyBroadcasts) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLnotifyBroadcasts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLnotifyBroadcasts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLnotifyBroadcasts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLnotifyBroadcasts) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLnotifyBroadcasts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputStickerSet struct implement
type InputStickerSet struct {
	Constructor int32                `json:"constructor"`
	Data        InputStickerSet_Data `json:"data"`
}

func (st *InputStickerSet) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputStickerSet) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputStickerSet) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputStickerSet, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputStickerSet) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputStickerSet) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputStickerSet_Data struct implement
type InputStickerSet_Data struct {
	Id          int64  `json:"id"`
	Access_hash int64  `json:"access_hash"`
	Short_name  string `json:"short_name"`
	Emoticon    string `json:"emoticon"`
}

func (st *InputStickerSet_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputStickerSet_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Short_name, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Emoticon, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputStickerSet_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputStickerSet_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputStickerSet_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Short_name, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Emoticon, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputStickerSet_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputStickerSetEmpty struct implement
type TLinputStickerSetEmpty struct {
	Data InputStickerSet_Data `json:"data"`
}

func (st *TLinputStickerSetEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputStickerSetEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputStickerSetEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputStickerSetEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputStickerSetEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputStickerSetEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputStickerSetID struct implement
type TLinputStickerSetID struct {
	Data InputStickerSet_Data `json:"data"`
}

func (st *TLinputStickerSetID) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputStickerSetID) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputStickerSetID) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputStickerSetID, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputStickerSetID) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputStickerSetID) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputStickerSetShortName struct implement
type TLinputStickerSetShortName struct {
	Data InputStickerSet_Data `json:"data"`
}

func (st *TLinputStickerSetShortName) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputStickerSetShortName) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputStickerSetShortName) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputStickerSetShortName, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputStickerSetShortName) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputStickerSetShortName) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputStickerSetAnimatedEmoji struct implement
type TLinputStickerSetAnimatedEmoji struct {
	Data InputStickerSet_Data `json:"data"`
}

func (st *TLinputStickerSetAnimatedEmoji) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputStickerSetAnimatedEmoji) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputStickerSetAnimatedEmoji) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputStickerSetAnimatedEmoji, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputStickerSetAnimatedEmoji) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputStickerSetAnimatedEmoji) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputStickerSetDice struct implement
type TLinputStickerSetDice struct {
	Data InputStickerSet_Data `json:"data"`
}

func (st *TLinputStickerSetDice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputStickerSetDice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputStickerSetDice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputStickerSetDice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputStickerSetDice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputStickerSetDice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_AuthorizationForm struct implement
type Account_AuthorizationForm struct {
	Constructor int32                          `json:"constructor"`
	Data        Account_AuthorizationForm_Data `json:"data"`
}

func (st *Account_AuthorizationForm) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_AuthorizationForm) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_AuthorizationForm) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_AuthorizationForm, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_AuthorizationForm) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_AuthorizationForm) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_AuthorizationForm_Data struct implement
type Account_AuthorizationForm_Data struct {
	Required_types     []SecureRequiredType `json:"required_types"`
	Values             []SecureValue        `json:"values"`
	Errors             []SecureValueError   `json:"errors"`
	Users              []User               `json:"users"`
	Privacy_policy_url string               `json:"privacy_policy_url"`
}

func (st *Account_AuthorizationForm_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_AuthorizationForm_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Required_types = make([]SecureRequiredType, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Required_types[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Values = make([]SecureValue, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Values[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Errors = make([]SecureValueError, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Errors[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Users[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Privacy_policy_url, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_AuthorizationForm_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_AuthorizationForm_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_AuthorizationForm_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Required_types)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Required_types {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Values)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Values {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Errors)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Errors {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Privacy_policy_url, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_AuthorizationForm_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_authorizationForm struct implement
type TLaccount_authorizationForm struct {
	Data Account_AuthorizationForm_Data `json:"data"`
}

func (st *TLaccount_authorizationForm) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_authorizationForm) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_authorizationForm) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_authorizationForm, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_authorizationForm) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_authorizationForm) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Photo struct implement
type Photo struct {
	Constructor int32      `json:"constructor"`
	Data        Photo_Data `json:"data"`
}

func (st *Photo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Photo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Photo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Photo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Photo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Photo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Photo_Data struct implement
type Photo_Data struct {
	Id             int64       `json:"id"`
	Has_stickers   bool        `json:"has_stickers"`
	Access_hash    int64       `json:"access_hash"`
	File_reference []uint8     `json:"file_reference"`
	Date           int32       `json:"date"`
	Sizes          []PhotoSize `json:"sizes"`
	Video_sizes    []VideoSize `json:"video_sizes"`
	Dc_id          int32       `json:"dc_id"`
}

func (st *Photo_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Photo_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Has_stickers, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.File_reference = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.File_reference[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.File_reference, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Date, 4, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Sizes = make([]PhotoSize, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Sizes[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Video_sizes = make([]VideoSize, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Video_sizes[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Dc_id, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Photo_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Photo_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Photo_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Has_stickers, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.File_reference)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.File_reference {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Date, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Sizes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Sizes {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Video_sizes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Video_sizes {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Dc_id, 7)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Photo_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphotoEmpty struct implement
type TLphotoEmpty struct {
	Data Photo_Data `json:"data"`
}

func (st *TLphotoEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphotoEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphotoEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphotoEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphotoEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphotoEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphoto struct implement
type TLphoto struct {
	Data Photo_Data `json:"data"`
}

func (st *TLphoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_PassportConfig struct implement
type Help_PassportConfig struct {
	Constructor int32                    `json:"constructor"`
	Data        Help_PassportConfig_Data `json:"data"`
}

func (st *Help_PassportConfig) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_PassportConfig) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_PassportConfig) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_PassportConfig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_PassportConfig) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_PassportConfig) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_PassportConfig_Data struct implement
type Help_PassportConfig_Data struct {
	Hash            int32    `json:"hash"`
	Countries_langs DataJSON `json:"countries_langs"`
}

func (st *Help_PassportConfig_Data) ResetDefault() {
	st.Countries_langs.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_PassportConfig_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	err = st.Countries_langs.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_PassportConfig_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_PassportConfig_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_PassportConfig_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	err = st.Countries_langs.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_PassportConfig_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_passportConfigNotModified struct implement
type TLhelp_passportConfigNotModified struct {
	Data Help_PassportConfig_Data `json:"data"`
}

func (st *TLhelp_passportConfigNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_passportConfigNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_passportConfigNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_passportConfigNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_passportConfigNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_passportConfigNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_passportConfig struct implement
type TLhelp_passportConfig struct {
	Data Help_PassportConfig_Data `json:"data"`
}

func (st *TLhelp_passportConfig) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_passportConfig) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_passportConfig) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_passportConfig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_passportConfig) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_passportConfig) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Upload_WebFile struct implement
type Upload_WebFile struct {
	Constructor int32               `json:"constructor"`
	Data        Upload_WebFile_Data `json:"data"`
}

func (st *Upload_WebFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Upload_WebFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Upload_WebFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Upload_WebFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Upload_WebFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Upload_WebFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Upload_WebFile_Data struct implement
type Upload_WebFile_Data struct {
	Size      int32            `json:"size"`
	Mime_type string           `json:"mime_type"`
	File_type Storage_FileType `json:"file_type"`
	Mtime     int32            `json:"mtime"`
	Bytes     []uint8          `json:"bytes"`
}

func (st *Upload_WebFile_Data) ResetDefault() {
	st.File_type.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Upload_WebFile_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Size, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Mime_type, 1, false)
	if err != nil {
		return err
	}

	err = st.File_type.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Mtime, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Bytes = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Bytes[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Bytes, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Upload_WebFile_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Upload_WebFile_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Upload_WebFile_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Size, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Mime_type, 1)
	if err != nil {
		return err
	}

	err = st.File_type.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Mtime, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Bytes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Bytes {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Upload_WebFile_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupload_webFile struct implement
type TLupload_webFile struct {
	Data Upload_WebFile_Data `json:"data"`
}

func (st *TLupload_webFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupload_webFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupload_webFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupload_webFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupload_webFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupload_webFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Contacts_Found struct implement
type Contacts_Found struct {
	Constructor int32               `json:"constructor"`
	Data        Contacts_Found_Data `json:"data"`
}

func (st *Contacts_Found) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Contacts_Found) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Contacts_Found) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Contacts_Found, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Contacts_Found) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Contacts_Found) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Contacts_Found_Data struct implement
type Contacts_Found_Data struct {
	My_results []Peer `json:"my_results"`
	Results    []Peer `json:"results"`
	Chats      []Chat `json:"chats"`
	Users      []User `json:"users"`
}

func (st *Contacts_Found_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Contacts_Found_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.My_results = make([]Peer, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.My_results[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Results = make([]Peer, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Results[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Chats[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Users[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Contacts_Found_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Contacts_Found_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Contacts_Found_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.My_results)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.My_results {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Results)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Results {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Contacts_Found_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_found struct implement
type TLcontacts_found struct {
	Data Contacts_Found_Data `json:"data"`
}

func (st *TLcontacts_found) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_found) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_found) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_found, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_found) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_found) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureValue struct implement
type SecureValue struct {
	Constructor int32            `json:"constructor"`
	Data        SecureValue_Data `json:"data"`
}

func (st *SecureValue) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureValue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureValue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureValue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureValue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureValue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureValue_Data struct implement
type SecureValue_Data struct {
	Type         SecureValueType `json:"type"`
	Data         SecureData      `json:"data"`
	Front_side   SecureFile      `json:"front_side"`
	Reverse_side SecureFile      `json:"reverse_side"`
	Selfie       SecureFile      `json:"selfie"`
	Translation  []SecureFile    `json:"translation"`
	Files        []SecureFile    `json:"files"`
	Plain_data   SecurePlainData `json:"plain_data"`
	Hash         []uint8         `json:"hash"`
}

func (st *SecureValue_Data) ResetDefault() {
	st.Type.ResetDefault()
	st.Data.ResetDefault()
	st.Front_side.ResetDefault()
	st.Reverse_side.ResetDefault()
	st.Selfie.ResetDefault()
	st.Plain_data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureValue_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Type.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.Front_side.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = st.Reverse_side.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = st.Selfie.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Translation = make([]SecureFile, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Translation[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Files = make([]SecureFile, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Files[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Plain_data.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Hash = make([]uint8, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = _is.Read_uint8(&st.Hash[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Hash, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureValue_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureValue_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureValue_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Type.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.Front_side.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = st.Reverse_side.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = st.Selfie.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Translation)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Translation {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Files)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Files {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Plain_data.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Hash)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Hash {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureValue_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValue struct implement
type TLsecureValue struct {
	Data SecureValue_Data `json:"data"`
}

func (st *TLsecureValue) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// LangPackString struct implement
type LangPackString struct {
	Constructor int32               `json:"constructor"`
	Data        LangPackString_Data `json:"data"`
}

func (st *LangPackString) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *LangPackString) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *LangPackString) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require LangPackString, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *LangPackString) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *LangPackString) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// LangPackString_Data struct implement
type LangPackString_Data struct {
	Key_key     string `json:"key_key"`
	Value       string `json:"value"`
	Zero_value  string `json:"zero_value"`
	One_value   string `json:"one_value"`
	Two_value   string `json:"two_value"`
	Few_value   string `json:"few_value"`
	Many_value  string `json:"many_value"`
	Other_value string `json:"other_value"`
}

func (st *LangPackString_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *LangPackString_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Key_key, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Value, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Zero_value, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.One_value, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Two_value, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Few_value, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Many_value, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Other_value, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *LangPackString_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require LangPackString_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *LangPackString_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Key_key, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Value, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Zero_value, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.One_value, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Two_value, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Few_value, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Many_value, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Other_value, 7)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *LangPackString_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLlangPackString struct implement
type TLlangPackString struct {
	Data LangPackString_Data `json:"data"`
}

func (st *TLlangPackString) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLlangPackString) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLlangPackString) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLlangPackString, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLlangPackString) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLlangPackString) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLlangPackStringPluralized struct implement
type TLlangPackStringPluralized struct {
	Data LangPackString_Data `json:"data"`
}

func (st *TLlangPackStringPluralized) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLlangPackStringPluralized) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLlangPackStringPluralized) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLlangPackStringPluralized, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLlangPackStringPluralized) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLlangPackStringPluralized) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLlangPackStringDeleted struct implement
type TLlangPackStringDeleted struct {
	Data LangPackString_Data `json:"data"`
}

func (st *TLlangPackStringDeleted) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLlangPackStringDeleted) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLlangPackStringDeleted) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLlangPackStringDeleted, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLlangPackStringDeleted) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLlangPackStringDeleted) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_Support struct implement
type Help_Support struct {
	Constructor int32             `json:"constructor"`
	Data        Help_Support_Data `json:"data"`
}

func (st *Help_Support) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_Support) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_Support) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_Support, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_Support) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_Support) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_Support_Data struct implement
type Help_Support_Data struct {
	Phone_number string `json:"phone_number"`
	User         User   `json:"user"`
}

func (st *Help_Support_Data) ResetDefault() {
	st.User.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_Support_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Phone_number, 0, false)
	if err != nil {
		return err
	}

	err = st.User.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_Support_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_Support_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_Support_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Phone_number, 0)
	if err != nil {
		return err
	}

	err = st.User.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_Support_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_support struct implement
type TLhelp_support struct {
	Data Help_Support_Data `json:"data"`
}

func (st *TLhelp_support) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_support) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_support) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_support, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_support) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_support) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MaskCoords struct implement
type MaskCoords struct {
	Constructor int32           `json:"constructor"`
	Data        MaskCoords_Data `json:"data"`
}

func (st *MaskCoords) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MaskCoords) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MaskCoords) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MaskCoords, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MaskCoords) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MaskCoords) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MaskCoords_Data struct implement
type MaskCoords_Data struct {
	N    int32   `json:"n"`
	X    float64 `json:"x"`
	Y    float64 `json:"y"`
	Zoom float64 `json:"zoom"`
}

func (st *MaskCoords_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *MaskCoords_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.N, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.X, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Y, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Zoom, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MaskCoords_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MaskCoords_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MaskCoords_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.N, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.X, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Y, 2)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Zoom, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MaskCoords_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmaskCoords struct implement
type TLmaskCoords struct {
	Data MaskCoords_Data `json:"data"`
}

func (st *TLmaskCoords) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmaskCoords) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmaskCoords) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmaskCoords, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmaskCoords) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmaskCoords) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// LabeledPrice struct implement
type LabeledPrice struct {
	Constructor int32             `json:"constructor"`
	Data        LabeledPrice_Data `json:"data"`
}

func (st *LabeledPrice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *LabeledPrice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *LabeledPrice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require LabeledPrice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *LabeledPrice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *LabeledPrice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// LabeledPrice_Data struct implement
type LabeledPrice_Data struct {
	Label  string `json:"label"`
	Amount int64  `json:"amount"`
}

func (st *LabeledPrice_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *LabeledPrice_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Label, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Amount, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *LabeledPrice_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require LabeledPrice_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *LabeledPrice_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Label, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Amount, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *LabeledPrice_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLlabeledPrice struct implement
type TLlabeledPrice struct {
	Data LabeledPrice_Data `json:"data"`
}

func (st *TLlabeledPrice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLlabeledPrice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLlabeledPrice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLlabeledPrice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLlabeledPrice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLlabeledPrice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_AppUpdate struct implement
type Help_AppUpdate struct {
	Constructor int32               `json:"constructor"`
	Data        Help_AppUpdate_Data `json:"data"`
}

func (st *Help_AppUpdate) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_AppUpdate) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_AppUpdate) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_AppUpdate, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_AppUpdate) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_AppUpdate) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_AppUpdate_Data struct implement
type Help_AppUpdate_Data struct {
	Can_not_skip bool            `json:"can_not_skip"`
	Id           int32           `json:"id"`
	Version      string          `json:"version"`
	Text         string          `json:"text"`
	Entities     []MessageEntity `json:"entities"`
	Document     Document        `json:"document"`
	Url          string          `json:"url"`
}

func (st *Help_AppUpdate_Data) ResetDefault() {
	st.Document.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_AppUpdate_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Can_not_skip, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Version, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Text, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Document.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Url, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_AppUpdate_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_AppUpdate_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_AppUpdate_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Can_not_skip, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Version, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Text, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Document.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Url, 6)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_AppUpdate_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_appUpdate struct implement
type TLhelp_appUpdate struct {
	Data Help_AppUpdate_Data `json:"data"`
}

func (st *TLhelp_appUpdate) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_appUpdate) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_appUpdate) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_appUpdate, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_appUpdate) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_appUpdate) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_noAppUpdate struct implement
type TLhelp_noAppUpdate struct {
	Data Help_AppUpdate_Data `json:"data"`
}

func (st *TLhelp_noAppUpdate) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_noAppUpdate) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_noAppUpdate) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_noAppUpdate, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_noAppUpdate) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_noAppUpdate) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Payments_PaymentResult struct implement
type Payments_PaymentResult struct {
	Constructor int32                       `json:"constructor"`
	Data        Payments_PaymentResult_Data `json:"data"`
}

func (st *Payments_PaymentResult) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Payments_PaymentResult) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Payments_PaymentResult) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Payments_PaymentResult, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Payments_PaymentResult) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Payments_PaymentResult) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Payments_PaymentResult_Data struct implement
type Payments_PaymentResult_Data struct {
	Updates Updates `json:"updates"`
	Url     string  `json:"url"`
}

func (st *Payments_PaymentResult_Data) ResetDefault() {
	st.Updates.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Payments_PaymentResult_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Updates.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Url, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Payments_PaymentResult_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Payments_PaymentResult_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Payments_PaymentResult_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Updates.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Url, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Payments_PaymentResult_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpayments_paymentResult struct implement
type TLpayments_paymentResult struct {
	Data Payments_PaymentResult_Data `json:"data"`
}

func (st *TLpayments_paymentResult) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpayments_paymentResult) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpayments_paymentResult) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpayments_paymentResult, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpayments_paymentResult) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpayments_paymentResult) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpayments_paymentVerificationNeeded struct implement
type TLpayments_paymentVerificationNeeded struct {
	Data Payments_PaymentResult_Data `json:"data"`
}

func (st *TLpayments_paymentVerificationNeeded) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpayments_paymentVerificationNeeded) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpayments_paymentVerificationNeeded) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpayments_paymentVerificationNeeded, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpayments_paymentVerificationNeeded) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpayments_paymentVerificationNeeded) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureCredentialsEncrypted struct implement
type SecureCredentialsEncrypted struct {
	Constructor int32                           `json:"constructor"`
	Data        SecureCredentialsEncrypted_Data `json:"data"`
}

func (st *SecureCredentialsEncrypted) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureCredentialsEncrypted) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureCredentialsEncrypted) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureCredentialsEncrypted, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureCredentialsEncrypted) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureCredentialsEncrypted) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureCredentialsEncrypted_Data struct implement
type SecureCredentialsEncrypted_Data struct {
	Data   []uint8 `json:"data"`
	Hash   []uint8 `json:"hash"`
	Secret []uint8 `json:"secret"`
}

func (st *SecureCredentialsEncrypted_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureCredentialsEncrypted_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Data = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Data[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Data, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Hash = make([]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_uint8(&st.Hash[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Hash, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Secret = make([]uint8, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = _is.Read_uint8(&st.Secret[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Secret, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureCredentialsEncrypted_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureCredentialsEncrypted_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureCredentialsEncrypted_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Data)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Data {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Hash)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Hash {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Secret)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Secret {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureCredentialsEncrypted_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureCredentialsEncrypted struct implement
type TLsecureCredentialsEncrypted struct {
	Data SecureCredentialsEncrypted_Data `json:"data"`
}

func (st *TLsecureCredentialsEncrypted) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureCredentialsEncrypted) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureCredentialsEncrypted) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureCredentialsEncrypted, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureCredentialsEncrypted) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureCredentialsEncrypted) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Page struct implement
type Page struct {
	Constructor int32     `json:"constructor"`
	Data        Page_Data `json:"data"`
}

func (st *Page) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Page) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Page) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Page, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Page) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Page) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Page_Data struct implement
type Page_Data struct {
	Part      bool        `json:"part"`
	Rtl       bool        `json:"rtl"`
	V2        bool        `json:"v2"`
	Url       string      `json:"url"`
	Blocks    []PageBlock `json:"blocks"`
	Photos    []Photo     `json:"photos"`
	Documents []Document  `json:"documents"`
	Views     int32       `json:"views"`
}

func (st *Page_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Page_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Part, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Rtl, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.V2, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Url, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Blocks = make([]PageBlock, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Blocks[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Photos = make([]Photo, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Photos[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Documents = make([]Document, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Documents[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Views, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Page_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Page_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Page_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Part, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Rtl, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.V2, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Url, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Blocks)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Blocks {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Photos)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Photos {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Documents)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Documents {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Views, 7)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Page_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpage struct implement
type TLpage struct {
	Data Page_Data `json:"data"`
}

func (st *TLpage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PasswordKdfAlgo struct implement
type PasswordKdfAlgo struct {
	Constructor int32                `json:"constructor"`
	Data        PasswordKdfAlgo_Data `json:"data"`
}

func (st *PasswordKdfAlgo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PasswordKdfAlgo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PasswordKdfAlgo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PasswordKdfAlgo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PasswordKdfAlgo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PasswordKdfAlgo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PasswordKdfAlgo_Data struct implement
type PasswordKdfAlgo_Data struct {
	Salt1 []uint8 `json:"salt1"`
	Salt2 []uint8 `json:"salt2"`
	G     int32   `json:"g"`
	P     []uint8 `json:"p"`
}

func (st *PasswordKdfAlgo_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *PasswordKdfAlgo_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Salt1 = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Salt1[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Salt1, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Salt2 = make([]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_uint8(&st.Salt2[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Salt2, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.G, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.P = make([]uint8, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = _is.Read_uint8(&st.P[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.P, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PasswordKdfAlgo_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PasswordKdfAlgo_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PasswordKdfAlgo_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Salt1)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Salt1 {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Salt2)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Salt2 {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.G, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.P)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.P {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PasswordKdfAlgo_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpasswordKdfAlgoUnknown struct implement
type TLpasswordKdfAlgoUnknown struct {
	Data PasswordKdfAlgo_Data `json:"data"`
}

func (st *TLpasswordKdfAlgoUnknown) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpasswordKdfAlgoUnknown) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpasswordKdfAlgoUnknown) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpasswordKdfAlgoUnknown, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpasswordKdfAlgoUnknown) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpasswordKdfAlgoUnknown) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpasswordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow struct implement
type TLpasswordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow struct {
	Data PasswordKdfAlgo_Data `json:"data"`
}

func (st *TLpasswordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpasswordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpasswordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpasswordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpasswordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpasswordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_DiscussionMessage struct implement
type Messages_DiscussionMessage struct {
	Constructor int32                           `json:"constructor"`
	Data        Messages_DiscussionMessage_Data `json:"data"`
}

func (st *Messages_DiscussionMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_DiscussionMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_DiscussionMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_DiscussionMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_DiscussionMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_DiscussionMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_DiscussionMessage_Data struct implement
type Messages_DiscussionMessage_Data struct {
	Messages           []Message `json:"messages"`
	Max_id             int32     `json:"max_id"`
	Read_inbox_max_id  int32     `json:"read_inbox_max_id"`
	Read_outbox_max_id int32     `json:"read_outbox_max_id"`
	Chats              []Chat    `json:"chats"`
	Users              []User    `json:"users"`
}

func (st *Messages_DiscussionMessage_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_DiscussionMessage_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Messages = make([]Message, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Messages[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Max_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Read_inbox_max_id, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Read_outbox_max_id, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Chats[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Users[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_DiscussionMessage_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_DiscussionMessage_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_DiscussionMessage_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Messages)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Messages {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Max_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Read_inbox_max_id, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Read_outbox_max_id, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_DiscussionMessage_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_discussionMessage struct implement
type TLmessages_discussionMessage struct {
	Data Messages_DiscussionMessage_Data `json:"data"`
}

func (st *TLmessages_discussionMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_discussionMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_discussionMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_discussionMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_discussionMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_discussionMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChannelParticipant struct implement
type ChannelParticipant struct {
	Constructor int32                   `json:"constructor"`
	Data        ChannelParticipant_Data `json:"data"`
}

func (st *ChannelParticipant) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChannelParticipant) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChannelParticipant) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChannelParticipant, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChannelParticipant) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChannelParticipant) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChannelParticipant_Data struct implement
type ChannelParticipant_Data struct {
	User_id       int32            `json:"user_id"`
	Date          int32            `json:"date"`
	Inviter_id    int32            `json:"inviter_id"`
	Admin_rights  ChatAdminRights  `json:"admin_rights"`
	Rank          string           `json:"rank"`
	Can_edit      bool             `json:"can_edit"`
	Self          bool             `json:"self"`
	Promoted_by   int32            `json:"promoted_by"`
	Left          bool             `json:"left"`
	Kicked_by     int32            `json:"kicked_by"`
	Banned_rights ChatBannedRights `json:"banned_rights"`
}

func (st *ChannelParticipant_Data) ResetDefault() {
	st.Admin_rights.ResetDefault()
	st.Banned_rights.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChannelParticipant_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Inviter_id, 2, false)
	if err != nil {
		return err
	}

	err = st.Admin_rights.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Rank, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Can_edit, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Self, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Promoted_by, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Left, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Kicked_by, 9, false)
	if err != nil {
		return err
	}

	err = st.Banned_rights.ReadBlock(_is, 10, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChannelParticipant_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChannelParticipant_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChannelParticipant_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.User_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Inviter_id, 2)
	if err != nil {
		return err
	}

	err = st.Admin_rights.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Rank, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Can_edit, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Self, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Promoted_by, 7)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Left, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Kicked_by, 9)
	if err != nil {
		return err
	}

	err = st.Banned_rights.WriteBlock(_os, 10)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChannelParticipant_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelParticipant struct implement
type TLchannelParticipant struct {
	Data ChannelParticipant_Data `json:"data"`
}

func (st *TLchannelParticipant) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelParticipant) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelParticipant) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelParticipant, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelParticipant) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelParticipant) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelParticipantSelf struct implement
type TLchannelParticipantSelf struct {
	Data ChannelParticipant_Data `json:"data"`
}

func (st *TLchannelParticipantSelf) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelParticipantSelf) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelParticipantSelf) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelParticipantSelf, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelParticipantSelf) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelParticipantSelf) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelParticipantCreator struct implement
type TLchannelParticipantCreator struct {
	Data ChannelParticipant_Data `json:"data"`
}

func (st *TLchannelParticipantCreator) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelParticipantCreator) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelParticipantCreator) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelParticipantCreator, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelParticipantCreator) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelParticipantCreator) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelParticipantAdmin struct implement
type TLchannelParticipantAdmin struct {
	Data ChannelParticipant_Data `json:"data"`
}

func (st *TLchannelParticipantAdmin) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelParticipantAdmin) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelParticipantAdmin) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelParticipantAdmin, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelParticipantAdmin) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelParticipantAdmin) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelParticipantBanned struct implement
type TLchannelParticipantBanned struct {
	Data ChannelParticipant_Data `json:"data"`
}

func (st *TLchannelParticipantBanned) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelParticipantBanned) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelParticipantBanned) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelParticipantBanned, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelParticipantBanned) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelParticipantBanned) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelParticipantLeft struct implement
type TLchannelParticipantLeft struct {
	Data ChannelParticipant_Data `json:"data"`
}

func (st *TLchannelParticipantLeft) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelParticipantLeft) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelParticipantLeft) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelParticipantLeft, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelParticipantLeft) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelParticipantLeft) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_Authorizations struct implement
type Account_Authorizations struct {
	Constructor int32                       `json:"constructor"`
	Data        Account_Authorizations_Data `json:"data"`
}

func (st *Account_Authorizations) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_Authorizations) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_Authorizations) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_Authorizations, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_Authorizations) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_Authorizations) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_Authorizations_Data struct implement
type Account_Authorizations_Data struct {
	Authorizations []Authorization `json:"authorizations"`
}

func (st *Account_Authorizations_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_Authorizations_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Authorizations = make([]Authorization, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Authorizations[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_Authorizations_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_Authorizations_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_Authorizations_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Authorizations)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Authorizations {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_Authorizations_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_authorizations struct implement
type TLaccount_authorizations struct {
	Data Account_Authorizations_Data `json:"data"`
}

func (st *TLaccount_authorizations) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_authorizations) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_authorizations) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_authorizations, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_authorizations) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_authorizations) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PopularContact struct implement
type PopularContact struct {
	Constructor int32               `json:"constructor"`
	Data        PopularContact_Data `json:"data"`
}

func (st *PopularContact) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PopularContact) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PopularContact) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PopularContact, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PopularContact) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PopularContact) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PopularContact_Data struct implement
type PopularContact_Data struct {
	Client_id int64 `json:"client_id"`
	Importers int32 `json:"importers"`
}

func (st *PopularContact_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *PopularContact_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Client_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Importers, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PopularContact_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PopularContact_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PopularContact_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Client_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Importers, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PopularContact_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpopularContact struct implement
type TLpopularContact struct {
	Data PopularContact_Data `json:"data"`
}

func (st *TLpopularContact) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpopularContact) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpopularContact) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpopularContact, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpopularContact) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpopularContact) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// WebPageAttribute struct implement
type WebPageAttribute struct {
	Constructor int32                 `json:"constructor"`
	Data        WebPageAttribute_Data `json:"data"`
}

func (st *WebPageAttribute) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *WebPageAttribute) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *WebPageAttribute) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require WebPageAttribute, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *WebPageAttribute) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *WebPageAttribute) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// WebPageAttribute_Data struct implement
type WebPageAttribute_Data struct {
	Documents []Document    `json:"documents"`
	Settings  ThemeSettings `json:"settings"`
}

func (st *WebPageAttribute_Data) ResetDefault() {
	st.Settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *WebPageAttribute_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Documents = make([]Document, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Documents[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Settings.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *WebPageAttribute_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require WebPageAttribute_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *WebPageAttribute_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Documents)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Documents {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Settings.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *WebPageAttribute_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLwebPageAttributeTheme struct implement
type TLwebPageAttributeTheme struct {
	Data WebPageAttribute_Data `json:"data"`
}

func (st *TLwebPageAttributeTheme) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLwebPageAttributeTheme) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLwebPageAttributeTheme) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLwebPageAttributeTheme, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLwebPageAttributeTheme) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLwebPageAttributeTheme) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StatsAbsValueAndPrev struct implement
type StatsAbsValueAndPrev struct {
	Constructor int32                     `json:"constructor"`
	Data        StatsAbsValueAndPrev_Data `json:"data"`
}

func (st *StatsAbsValueAndPrev) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *StatsAbsValueAndPrev) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StatsAbsValueAndPrev) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StatsAbsValueAndPrev, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StatsAbsValueAndPrev) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StatsAbsValueAndPrev) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StatsAbsValueAndPrev_Data struct implement
type StatsAbsValueAndPrev_Data struct {
	Current  float64 `json:"current"`
	Previous float64 `json:"previous"`
}

func (st *StatsAbsValueAndPrev_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *StatsAbsValueAndPrev_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_float64(&st.Current, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Previous, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StatsAbsValueAndPrev_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StatsAbsValueAndPrev_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StatsAbsValueAndPrev_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_float64(st.Current, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Previous, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StatsAbsValueAndPrev_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstatsAbsValueAndPrev struct implement
type TLstatsAbsValueAndPrev struct {
	Data StatsAbsValueAndPrev_Data `json:"data"`
}

func (st *TLstatsAbsValueAndPrev) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstatsAbsValueAndPrev) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstatsAbsValueAndPrev) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstatsAbsValueAndPrev, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstatsAbsValueAndPrev) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstatsAbsValueAndPrev) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PhoneCallDiscardReason struct implement
type PhoneCallDiscardReason struct {
	Constructor int32                       `json:"constructor"`
	Data        PhoneCallDiscardReason_Data `json:"data"`
}

func (st *PhoneCallDiscardReason) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PhoneCallDiscardReason) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PhoneCallDiscardReason) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PhoneCallDiscardReason, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PhoneCallDiscardReason) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PhoneCallDiscardReason) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PhoneCallDiscardReason_Data struct implement
type PhoneCallDiscardReason_Data struct {
}

func (st *PhoneCallDiscardReason_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *PhoneCallDiscardReason_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PhoneCallDiscardReason_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PhoneCallDiscardReason_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PhoneCallDiscardReason_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PhoneCallDiscardReason_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphoneCallDiscardReasonMissed struct implement
type TLphoneCallDiscardReasonMissed struct {
	Data PhoneCallDiscardReason_Data `json:"data"`
}

func (st *TLphoneCallDiscardReasonMissed) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphoneCallDiscardReasonMissed) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphoneCallDiscardReasonMissed) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphoneCallDiscardReasonMissed, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphoneCallDiscardReasonMissed) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphoneCallDiscardReasonMissed) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphoneCallDiscardReasonDisconnect struct implement
type TLphoneCallDiscardReasonDisconnect struct {
	Data PhoneCallDiscardReason_Data `json:"data"`
}

func (st *TLphoneCallDiscardReasonDisconnect) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphoneCallDiscardReasonDisconnect) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphoneCallDiscardReasonDisconnect) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphoneCallDiscardReasonDisconnect, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphoneCallDiscardReasonDisconnect) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphoneCallDiscardReasonDisconnect) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphoneCallDiscardReasonHangup struct implement
type TLphoneCallDiscardReasonHangup struct {
	Data PhoneCallDiscardReason_Data `json:"data"`
}

func (st *TLphoneCallDiscardReasonHangup) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphoneCallDiscardReasonHangup) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphoneCallDiscardReasonHangup) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphoneCallDiscardReasonHangup, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphoneCallDiscardReasonHangup) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphoneCallDiscardReasonHangup) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphoneCallDiscardReasonBusy struct implement
type TLphoneCallDiscardReasonBusy struct {
	Data PhoneCallDiscardReason_Data `json:"data"`
}

func (st *TLphoneCallDiscardReasonBusy) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphoneCallDiscardReasonBusy) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphoneCallDiscardReasonBusy) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphoneCallDiscardReasonBusy, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphoneCallDiscardReasonBusy) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphoneCallDiscardReasonBusy) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Theme struct implement
type Theme struct {
	Constructor int32      `json:"constructor"`
	Data        Theme_Data `json:"data"`
}

func (st *Theme) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Theme) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Theme) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Theme, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Theme) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Theme) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Theme_Data struct implement
type Theme_Data struct {
	Creator        bool          `json:"creator"`
	Default        bool          `json:"default"`
	Id             int64         `json:"id"`
	Access_hash    int64         `json:"access_hash"`
	Slug           string        `json:"slug"`
	Title          string        `json:"title"`
	Document       Document      `json:"document"`
	Settings       ThemeSettings `json:"settings"`
	Installs_count int32         `json:"installs_count"`
}

func (st *Theme_Data) ResetDefault() {
	st.Document.ResetDefault()
	st.Settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Theme_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Creator, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Default, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Id, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Slug, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 5, false)
	if err != nil {
		return err
	}

	err = st.Document.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	err = st.Settings.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Installs_count, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Theme_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Theme_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Theme_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Creator, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Default, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Id, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Slug, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 5)
	if err != nil {
		return err
	}

	err = st.Document.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	err = st.Settings.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Installs_count, 8)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Theme_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtheme struct implement
type TLtheme struct {
	Data Theme_Data `json:"data"`
}

func (st *TLtheme) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtheme) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtheme) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtheme, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtheme) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtheme) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChatParticipants struct implement
type ChatParticipants struct {
	Constructor int32                 `json:"constructor"`
	Data        ChatParticipants_Data `json:"data"`
}

func (st *ChatParticipants) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChatParticipants) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChatParticipants) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChatParticipants, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChatParticipants) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChatParticipants) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChatParticipants_Data struct implement
type ChatParticipants_Data struct {
	Chat_id          int32             `json:"chat_id"`
	Self_participant ChatParticipant   `json:"self_participant"`
	Participants     []ChatParticipant `json:"participants"`
	Version          int32             `json:"version"`
}

func (st *ChatParticipants_Data) ResetDefault() {
	st.Self_participant.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChatParticipants_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Chat_id, 0, false)
	if err != nil {
		return err
	}

	err = st.Self_participant.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Participants = make([]ChatParticipant, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Participants[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Version, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChatParticipants_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChatParticipants_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChatParticipants_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Chat_id, 0)
	if err != nil {
		return err
	}

	err = st.Self_participant.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Participants)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Participants {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Version, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChatParticipants_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatParticipantsForbidden struct implement
type TLchatParticipantsForbidden struct {
	Data ChatParticipants_Data `json:"data"`
}

func (st *TLchatParticipantsForbidden) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatParticipantsForbidden) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatParticipantsForbidden) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatParticipantsForbidden, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatParticipantsForbidden) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatParticipantsForbidden) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatParticipants struct implement
type TLchatParticipants struct {
	Data ChatParticipants_Data `json:"data"`
}

func (st *TLchatParticipants) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatParticipants) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatParticipants) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatParticipants, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatParticipants) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatParticipants) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessagesFilter struct implement
type MessagesFilter struct {
	Constructor int32               `json:"constructor"`
	Data        MessagesFilter_Data `json:"data"`
}

func (st *MessagesFilter) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessagesFilter) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessagesFilter) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessagesFilter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessagesFilter) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessagesFilter) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessagesFilter_Data struct implement
type MessagesFilter_Data struct {
	Missed bool `json:"missed"`
}

func (st *MessagesFilter_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *MessagesFilter_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Missed, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessagesFilter_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessagesFilter_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessagesFilter_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Missed, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessagesFilter_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterEmpty struct implement
type TLinputMessagesFilterEmpty struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterPhotos struct implement
type TLinputMessagesFilterPhotos struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterPhotos) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterPhotos) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterPhotos) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterPhotos, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterPhotos) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterPhotos) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterVideo struct implement
type TLinputMessagesFilterVideo struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterVideo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterVideo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterVideo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterVideo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterVideo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterVideo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterPhotoVideo struct implement
type TLinputMessagesFilterPhotoVideo struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterPhotoVideo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterPhotoVideo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterPhotoVideo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterPhotoVideo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterPhotoVideo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterPhotoVideo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterDocument struct implement
type TLinputMessagesFilterDocument struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterDocument) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterDocument) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterDocument) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterDocument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterDocument) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterDocument) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterUrl struct implement
type TLinputMessagesFilterUrl struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterUrl) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterUrl) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterUrl) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterUrl, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterUrl) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterUrl) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterGif struct implement
type TLinputMessagesFilterGif struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterGif) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterGif) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterGif) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterGif, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterGif) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterGif) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterVoice struct implement
type TLinputMessagesFilterVoice struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterVoice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterVoice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterVoice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterVoice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterVoice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterVoice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterMusic struct implement
type TLinputMessagesFilterMusic struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterMusic) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterMusic) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterMusic) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterMusic, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterMusic) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterMusic) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterChatPhotos struct implement
type TLinputMessagesFilterChatPhotos struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterChatPhotos) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterChatPhotos) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterChatPhotos) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterChatPhotos, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterChatPhotos) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterChatPhotos) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterPhoneCalls struct implement
type TLinputMessagesFilterPhoneCalls struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterPhoneCalls) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterPhoneCalls) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterPhoneCalls) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterPhoneCalls, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterPhoneCalls) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterPhoneCalls) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterRoundVoice struct implement
type TLinputMessagesFilterRoundVoice struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterRoundVoice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterRoundVoice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterRoundVoice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterRoundVoice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterRoundVoice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterRoundVoice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterRoundVideo struct implement
type TLinputMessagesFilterRoundVideo struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterRoundVideo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterRoundVideo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterRoundVideo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterRoundVideo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterRoundVideo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterRoundVideo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterMyMentions struct implement
type TLinputMessagesFilterMyMentions struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterMyMentions) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterMyMentions) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterMyMentions) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterMyMentions, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterMyMentions) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterMyMentions) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterGeo struct implement
type TLinputMessagesFilterGeo struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterGeo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterGeo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterGeo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterGeo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterGeo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterGeo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterContacts struct implement
type TLinputMessagesFilterContacts struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterContacts) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterContacts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterContacts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterContacts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterContacts) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterContacts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagesFilterPinned struct implement
type TLinputMessagesFilterPinned struct {
	Data MessagesFilter_Data `json:"data"`
}

func (st *TLinputMessagesFilterPinned) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagesFilterPinned) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagesFilterPinned) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagesFilterPinned, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagesFilterPinned) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagesFilterPinned) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Error struct implement
type Error struct {
	Constructor int32      `json:"constructor"`
	Data        Error_Data `json:"data"`
}

func (st *Error) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Error) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Error) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Error, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Error) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Error) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Error_Data struct implement
type Error_Data struct {
	Code int32  `json:"code"`
	Text string `json:"text"`
}

func (st *Error_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Error_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Code, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Text, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Error_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Error_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Error_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Code, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Text, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Error_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLerror struct implement
type TLerror struct {
	Data Error_Data `json:"data"`
}

func (st *TLerror) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLerror) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLerror) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLerror, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLerror) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLerror) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputClientProxy struct implement
type InputClientProxy struct {
	Constructor int32                 `json:"constructor"`
	Data        InputClientProxy_Data `json:"data"`
}

func (st *InputClientProxy) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputClientProxy) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputClientProxy) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputClientProxy, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputClientProxy) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputClientProxy) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputClientProxy_Data struct implement
type InputClientProxy_Data struct {
	Address string `json:"address"`
	Port    int32  `json:"port"`
}

func (st *InputClientProxy_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputClientProxy_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Address, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Port, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputClientProxy_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputClientProxy_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputClientProxy_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Address, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Port, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputClientProxy_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputClientProxy struct implement
type TLinputClientProxy struct {
	Data InputClientProxy_Data `json:"data"`
}

func (st *TLinputClientProxy) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputClientProxy) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputClientProxy) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputClientProxy, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputClientProxy) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputClientProxy) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// DialogFilter struct implement
type DialogFilter struct {
	Constructor int32             `json:"constructor"`
	Data        DialogFilter_Data `json:"data"`
}

func (st *DialogFilter) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *DialogFilter) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DialogFilter) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DialogFilter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DialogFilter) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DialogFilter) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// DialogFilter_Data struct implement
type DialogFilter_Data struct {
	Contacts         bool        `json:"contacts"`
	Non_contacts     bool        `json:"non_contacts"`
	Groups           bool        `json:"groups"`
	Broadcasts       bool        `json:"broadcasts"`
	Bots             bool        `json:"bots"`
	Exclude_muted    bool        `json:"exclude_muted"`
	Exclude_read     bool        `json:"exclude_read"`
	Exclude_archived bool        `json:"exclude_archived"`
	Id               int32       `json:"id"`
	Title            string      `json:"title"`
	Emoticon         string      `json:"emoticon"`
	Pinned_peers     []InputPeer `json:"pinned_peers"`
	Include_peers    []InputPeer `json:"include_peers"`
	Exclude_peers    []InputPeer `json:"exclude_peers"`
}

func (st *DialogFilter_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *DialogFilter_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Contacts, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Non_contacts, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Groups, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Broadcasts, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Bots, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Exclude_muted, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Exclude_read, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Exclude_archived, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Id, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Emoticon, 10, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(11, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Pinned_peers = make([]InputPeer, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Pinned_peers[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(12, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Include_peers = make([]InputPeer, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Include_peers[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(13, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Exclude_peers = make([]InputPeer, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Exclude_peers[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DialogFilter_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DialogFilter_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DialogFilter_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Contacts, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Non_contacts, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Groups, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Broadcasts, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Bots, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Exclude_muted, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Exclude_read, 6)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Exclude_archived, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Id, 8)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Emoticon, 10)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Pinned_peers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Pinned_peers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 12)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Include_peers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Include_peers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Exclude_peers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Exclude_peers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DialogFilter_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdialogFilter struct implement
type TLdialogFilter struct {
	Data DialogFilter_Data `json:"data"`
}

func (st *TLdialogFilter) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdialogFilter) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdialogFilter) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdialogFilter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdialogFilter) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdialogFilter) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputSecureValue struct implement
type InputSecureValue struct {
	Constructor int32                 `json:"constructor"`
	Data        InputSecureValue_Data `json:"data"`
}

func (st *InputSecureValue) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputSecureValue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputSecureValue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputSecureValue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputSecureValue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputSecureValue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputSecureValue_Data struct implement
type InputSecureValue_Data struct {
	Type         SecureValueType   `json:"type"`
	Data         SecureData        `json:"data"`
	Front_side   InputSecureFile   `json:"front_side"`
	Reverse_side InputSecureFile   `json:"reverse_side"`
	Selfie       InputSecureFile   `json:"selfie"`
	Translation  []InputSecureFile `json:"translation"`
	Files        []InputSecureFile `json:"files"`
	Plain_data   SecurePlainData   `json:"plain_data"`
}

func (st *InputSecureValue_Data) ResetDefault() {
	st.Type.ResetDefault()
	st.Data.ResetDefault()
	st.Front_side.ResetDefault()
	st.Reverse_side.ResetDefault()
	st.Selfie.ResetDefault()
	st.Plain_data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputSecureValue_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Type.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.Front_side.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = st.Reverse_side.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = st.Selfie.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Translation = make([]InputSecureFile, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Translation[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Files = make([]InputSecureFile, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Files[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Plain_data.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputSecureValue_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputSecureValue_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputSecureValue_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Type.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.Front_side.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = st.Reverse_side.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = st.Selfie.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Translation)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Translation {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Files)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Files {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Plain_data.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputSecureValue_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputSecureValue struct implement
type TLinputSecureValue struct {
	Data InputSecureValue_Data `json:"data"`
}

func (st *TLinputSecureValue) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputSecureValue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputSecureValue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputSecureValue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputSecureValue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputSecureValue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_SentEncryptedMessage struct implement
type Messages_SentEncryptedMessage struct {
	Constructor int32                              `json:"constructor"`
	Data        Messages_SentEncryptedMessage_Data `json:"data"`
}

func (st *Messages_SentEncryptedMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_SentEncryptedMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_SentEncryptedMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_SentEncryptedMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_SentEncryptedMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_SentEncryptedMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_SentEncryptedMessage_Data struct implement
type Messages_SentEncryptedMessage_Data struct {
	Date int32         `json:"date"`
	File EncryptedFile `json:"file"`
}

func (st *Messages_SentEncryptedMessage_Data) ResetDefault() {
	st.File.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_SentEncryptedMessage_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Date, 0, false)
	if err != nil {
		return err
	}

	err = st.File.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_SentEncryptedMessage_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_SentEncryptedMessage_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_SentEncryptedMessage_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Date, 0)
	if err != nil {
		return err
	}

	err = st.File.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_SentEncryptedMessage_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_sentEncryptedMessage struct implement
type TLmessages_sentEncryptedMessage struct {
	Data Messages_SentEncryptedMessage_Data `json:"data"`
}

func (st *TLmessages_sentEncryptedMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_sentEncryptedMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_sentEncryptedMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_sentEncryptedMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_sentEncryptedMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_sentEncryptedMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_sentEncryptedFile struct implement
type TLmessages_sentEncryptedFile struct {
	Data Messages_SentEncryptedMessage_Data `json:"data"`
}

func (st *TLmessages_sentEncryptedFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_sentEncryptedFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_sentEncryptedFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_sentEncryptedFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_sentEncryptedFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_sentEncryptedFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Auth_SentCode struct implement
type Auth_SentCode struct {
	Constructor int32              `json:"constructor"`
	Data        Auth_SentCode_Data `json:"data"`
}

func (st *Auth_SentCode) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Auth_SentCode) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Auth_SentCode) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Auth_SentCode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Auth_SentCode) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Auth_SentCode) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Auth_SentCode_Data struct implement
type Auth_SentCode_Data struct {
	Type            Auth_SentCodeType `json:"type"`
	Phone_code_hash string            `json:"phone_code_hash"`
	Next_type       Auth_CodeType     `json:"next_type"`
	Timeout         int32             `json:"timeout"`
}

func (st *Auth_SentCode_Data) ResetDefault() {
	st.Type.ResetDefault()
	st.Next_type.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Auth_SentCode_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Type.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone_code_hash, 1, false)
	if err != nil {
		return err
	}

	err = st.Next_type.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Timeout, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Auth_SentCode_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Auth_SentCode_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Auth_SentCode_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Type.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone_code_hash, 1)
	if err != nil {
		return err
	}

	err = st.Next_type.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Timeout, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Auth_SentCode_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_sentCode struct implement
type TLauth_sentCode struct {
	Data Auth_SentCode_Data `json:"data"`
}

func (st *TLauth_sentCode) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_sentCode) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_sentCode) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_sentCode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_sentCode) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_sentCode) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputPhoto struct implement
type InputPhoto struct {
	Constructor int32           `json:"constructor"`
	Data        InputPhoto_Data `json:"data"`
}

func (st *InputPhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputPhoto_Data struct implement
type InputPhoto_Data struct {
	Id             int64   `json:"id"`
	Access_hash    int64   `json:"access_hash"`
	File_reference []uint8 `json:"file_reference"`
}

func (st *InputPhoto_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputPhoto_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.File_reference = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.File_reference[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.File_reference, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputPhoto_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputPhoto_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputPhoto_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.File_reference)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.File_reference {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputPhoto_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPhotoEmpty struct implement
type TLinputPhotoEmpty struct {
	Data InputPhoto_Data `json:"data"`
}

func (st *TLinputPhotoEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPhotoEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPhotoEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPhotoEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPhotoEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPhotoEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPhoto struct implement
type TLinputPhoto struct {
	Data InputPhoto_Data `json:"data"`
}

func (st *TLinputPhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureValueError struct implement
type SecureValueError struct {
	Constructor int32                 `json:"constructor"`
	Data        SecureValueError_Data `json:"data"`
}

func (st *SecureValueError) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureValueError) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureValueError) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureValueError, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureValueError) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureValueError) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureValueError_Data struct implement
type SecureValueError_Data struct {
	Type        SecureValueType `json:"type"`
	Data_hash   []uint8         `json:"data_hash"`
	Field       string          `json:"field"`
	Text        string          `json:"text"`
	File_hash   []uint8         `json:"file_hash"`
	File_hash_6 [][]uint8       `json:"file_hash_6"`
	Hash        []uint8         `json:"hash"`
}

func (st *SecureValueError_Data) ResetDefault() {
	st.Type.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureValueError_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Type.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Data_hash = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Data_hash[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Data_hash, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Field, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Text, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.File_hash = make([]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_uint8(&st.File_hash[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.File_hash, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.File_hash_6 = make([][]uint8, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err, have, ty = _is.SkipToNoCheck(0, false)
				if err != nil {
					return err
				}

				if have {
					if ty == codec.LIST {
						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}

						st.File_hash_6[i2] = make([]uint8, length)
						for i3, e3 := int32(0), length; i3 < e3; i3++ {

							err = _is.Read_uint8(&st.File_hash_6[i2][i3], 0, false)
							if err != nil {
								return err
							}

						}
					} else if ty == codec.SIMPLE_LIST {

						err, _ = _is.SkipTo(codec.BYTE, 0, true)
						if err != nil {
							return err
						}

						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}

						err = _is.Read_slice_uint8(&st.File_hash_6[i2], length, true)
						if err != nil {
							return err
						}

					} else {
						err = fmt.Errorf("require vector, but not")
						if err != nil {
							return err
						}

					}
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Hash = make([]uint8, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = _is.Read_uint8(&st.Hash[i4], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Hash, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureValueError_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureValueError_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureValueError_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Type.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Data_hash)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Data_hash {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Field, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Text, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.File_hash)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.File_hash {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.File_hash_6)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.File_hash_6 {

		err = _os.WriteHead(codec.LIST, 0)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v)), 0)
		if err != nil {
			return err
		}

		for _, v := range v {

			err = _os.Write_uint8(v, 0)
			if err != nil {
				return err
			}

		}
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Hash)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Hash {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureValueError_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueErrorData struct implement
type TLsecureValueErrorData struct {
	Data SecureValueError_Data `json:"data"`
}

func (st *TLsecureValueErrorData) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueErrorData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueErrorData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueErrorData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueErrorData) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueErrorData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueErrorFrontSide struct implement
type TLsecureValueErrorFrontSide struct {
	Data SecureValueError_Data `json:"data"`
}

func (st *TLsecureValueErrorFrontSide) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueErrorFrontSide) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueErrorFrontSide) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueErrorFrontSide, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueErrorFrontSide) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueErrorFrontSide) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueErrorReverseSide struct implement
type TLsecureValueErrorReverseSide struct {
	Data SecureValueError_Data `json:"data"`
}

func (st *TLsecureValueErrorReverseSide) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueErrorReverseSide) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueErrorReverseSide) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueErrorReverseSide, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueErrorReverseSide) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueErrorReverseSide) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueErrorSelfie struct implement
type TLsecureValueErrorSelfie struct {
	Data SecureValueError_Data `json:"data"`
}

func (st *TLsecureValueErrorSelfie) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueErrorSelfie) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueErrorSelfie) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueErrorSelfie, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueErrorSelfie) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueErrorSelfie) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueErrorFile struct implement
type TLsecureValueErrorFile struct {
	Data SecureValueError_Data `json:"data"`
}

func (st *TLsecureValueErrorFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueErrorFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueErrorFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueErrorFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueErrorFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueErrorFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueErrorFiles struct implement
type TLsecureValueErrorFiles struct {
	Data SecureValueError_Data `json:"data"`
}

func (st *TLsecureValueErrorFiles) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueErrorFiles) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueErrorFiles) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueErrorFiles, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueErrorFiles) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueErrorFiles) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueError struct implement
type TLsecureValueError struct {
	Data SecureValueError_Data `json:"data"`
}

func (st *TLsecureValueError) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueError) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueError) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueError, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueError) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueError) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueErrorTranslationFile struct implement
type TLsecureValueErrorTranslationFile struct {
	Data SecureValueError_Data `json:"data"`
}

func (st *TLsecureValueErrorTranslationFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueErrorTranslationFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueErrorTranslationFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueErrorTranslationFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueErrorTranslationFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueErrorTranslationFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueErrorTranslationFiles struct implement
type TLsecureValueErrorTranslationFiles struct {
	Data SecureValueError_Data `json:"data"`
}

func (st *TLsecureValueErrorTranslationFiles) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueErrorTranslationFiles) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueErrorTranslationFiles) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueErrorTranslationFiles, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueErrorTranslationFiles) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueErrorTranslationFiles) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// WallPaperSettings struct implement
type WallPaperSettings struct {
	Constructor int32                  `json:"constructor"`
	Data        WallPaperSettings_Data `json:"data"`
}

func (st *WallPaperSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *WallPaperSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *WallPaperSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require WallPaperSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *WallPaperSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *WallPaperSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// WallPaperSettings_Data struct implement
type WallPaperSettings_Data struct {
	Blur                    bool  `json:"blur"`
	Motion                  bool  `json:"motion"`
	Background_color        int32 `json:"background_color"`
	Second_background_color int32 `json:"second_background_color"`
	Intensity               int32 `json:"intensity"`
	Rotation                int32 `json:"rotation"`
}

func (st *WallPaperSettings_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *WallPaperSettings_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Blur, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Motion, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Background_color, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Second_background_color, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Intensity, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Rotation, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *WallPaperSettings_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require WallPaperSettings_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *WallPaperSettings_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Blur, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Motion, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Background_color, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Second_background_color, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Intensity, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Rotation, 5)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *WallPaperSettings_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLwallPaperSettings struct implement
type TLwallPaperSettings struct {
	Data WallPaperSettings_Data `json:"data"`
}

func (st *TLwallPaperSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLwallPaperSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLwallPaperSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLwallPaperSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLwallPaperSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLwallPaperSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Auth_CodeType struct implement
type Auth_CodeType struct {
	Constructor int32              `json:"constructor"`
	Data        Auth_CodeType_Data `json:"data"`
}

func (st *Auth_CodeType) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Auth_CodeType) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Auth_CodeType) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Auth_CodeType, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Auth_CodeType) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Auth_CodeType) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Auth_CodeType_Data struct implement
type Auth_CodeType_Data struct {
}

func (st *Auth_CodeType_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Auth_CodeType_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Auth_CodeType_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Auth_CodeType_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Auth_CodeType_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Auth_CodeType_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_codeTypeSms struct implement
type TLauth_codeTypeSms struct {
	Data Auth_CodeType_Data `json:"data"`
}

func (st *TLauth_codeTypeSms) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_codeTypeSms) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_codeTypeSms) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_codeTypeSms, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_codeTypeSms) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_codeTypeSms) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_codeTypeCall struct implement
type TLauth_codeTypeCall struct {
	Data Auth_CodeType_Data `json:"data"`
}

func (st *TLauth_codeTypeCall) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_codeTypeCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_codeTypeCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_codeTypeCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_codeTypeCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_codeTypeCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_codeTypeFlashCall struct implement
type TLauth_codeTypeFlashCall struct {
	Data Auth_CodeType_Data `json:"data"`
}

func (st *TLauth_codeTypeFlashCall) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_codeTypeFlashCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_codeTypeFlashCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_codeTypeFlashCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_codeTypeFlashCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_codeTypeFlashCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// BotInlineResult struct implement
type BotInlineResult struct {
	Constructor int32                `json:"constructor"`
	Data        BotInlineResult_Data `json:"data"`
}

func (st *BotInlineResult) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *BotInlineResult) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *BotInlineResult) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BotInlineResult, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *BotInlineResult) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *BotInlineResult) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// BotInlineResult_Data struct implement
type BotInlineResult_Data struct {
	Id           string           `json:"id"`
	Type         string           `json:"type"`
	Title        string           `json:"title"`
	Description  string           `json:"description"`
	Url          string           `json:"url"`
	Thumb        WebDocument      `json:"thumb"`
	Content      WebDocument      `json:"content"`
	Send_message BotInlineMessage `json:"send_message"`
	Photo        Photo            `json:"photo"`
	Document     Document         `json:"document"`
}

func (st *BotInlineResult_Data) ResetDefault() {
	st.Thumb.ResetDefault()
	st.Content.ResetDefault()
	st.Send_message.ResetDefault()
	st.Photo.ResetDefault()
	st.Document.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *BotInlineResult_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Type, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Description, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Url, 4, false)
	if err != nil {
		return err
	}

	err = st.Thumb.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = st.Content.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	err = st.Send_message.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	err = st.Photo.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err = st.Document.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *BotInlineResult_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BotInlineResult_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *BotInlineResult_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Type, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Description, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Url, 4)
	if err != nil {
		return err
	}

	err = st.Thumb.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = st.Content.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	err = st.Send_message.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	err = st.Photo.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = st.Document.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *BotInlineResult_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbotInlineResult struct implement
type TLbotInlineResult struct {
	Data BotInlineResult_Data `json:"data"`
}

func (st *TLbotInlineResult) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbotInlineResult) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbotInlineResult) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbotInlineResult, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbotInlineResult) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbotInlineResult) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbotInlineMediaResult struct implement
type TLbotInlineMediaResult struct {
	Data BotInlineResult_Data `json:"data"`
}

func (st *TLbotInlineMediaResult) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbotInlineMediaResult) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbotInlineMediaResult) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbotInlineMediaResult, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbotInlineMediaResult) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbotInlineMediaResult) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChatPhoto struct implement
type ChatPhoto struct {
	Constructor int32          `json:"constructor"`
	Data        ChatPhoto_Data `json:"data"`
}

func (st *ChatPhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChatPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChatPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChatPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChatPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChatPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChatPhoto_Data struct implement
type ChatPhoto_Data struct {
	Has_video   bool         `json:"has_video"`
	Photo_small FileLocation `json:"photo_small"`
	Photo_big   FileLocation `json:"photo_big"`
	Dc_id       int32        `json:"dc_id"`
}

func (st *ChatPhoto_Data) ResetDefault() {
	st.Photo_small.ResetDefault()
	st.Photo_big.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChatPhoto_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Has_video, 0, false)
	if err != nil {
		return err
	}

	err = st.Photo_small.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.Photo_big.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Dc_id, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChatPhoto_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChatPhoto_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChatPhoto_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Has_video, 0)
	if err != nil {
		return err
	}

	err = st.Photo_small.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.Photo_big.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Dc_id, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChatPhoto_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatPhotoEmpty struct implement
type TLchatPhotoEmpty struct {
	Data ChatPhoto_Data `json:"data"`
}

func (st *TLchatPhotoEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatPhotoEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatPhotoEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatPhotoEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatPhotoEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatPhotoEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatPhoto struct implement
type TLchatPhoto struct {
	Data ChatPhoto_Data `json:"data"`
}

func (st *TLchatPhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PollAnswer struct implement
type PollAnswer struct {
	Constructor int32           `json:"constructor"`
	Data        PollAnswer_Data `json:"data"`
}

func (st *PollAnswer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PollAnswer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PollAnswer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PollAnswer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PollAnswer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PollAnswer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PollAnswer_Data struct implement
type PollAnswer_Data struct {
	Text   string  `json:"text"`
	Option []uint8 `json:"option"`
}

func (st *PollAnswer_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *PollAnswer_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Text, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Option = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Option[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Option, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PollAnswer_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PollAnswer_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PollAnswer_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Text, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Option)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Option {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PollAnswer_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpollAnswer struct implement
type TLpollAnswer struct {
	Data PollAnswer_Data `json:"data"`
}

func (st *TLpollAnswer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpollAnswer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpollAnswer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpollAnswer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpollAnswer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpollAnswer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// BotInfo struct implement
type BotInfo struct {
	Constructor int32        `json:"constructor"`
	Data        BotInfo_Data `json:"data"`
}

func (st *BotInfo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *BotInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *BotInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BotInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *BotInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *BotInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// BotInfo_Data struct implement
type BotInfo_Data struct {
	User_id     int32        `json:"user_id"`
	Description string       `json:"description"`
	Commands    []BotCommand `json:"commands"`
}

func (st *BotInfo_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *BotInfo_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Description, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Commands = make([]BotCommand, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Commands[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *BotInfo_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BotInfo_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *BotInfo_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.User_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Description, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Commands)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Commands {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *BotInfo_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbotInfo struct implement
type TLbotInfo struct {
	Data BotInfo_Data `json:"data"`
}

func (st *TLbotInfo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbotInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbotInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbotInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbotInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbotInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_HighScores struct implement
type Messages_HighScores struct {
	Constructor int32                    `json:"constructor"`
	Data        Messages_HighScores_Data `json:"data"`
}

func (st *Messages_HighScores) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_HighScores) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_HighScores) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_HighScores, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_HighScores) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_HighScores) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_HighScores_Data struct implement
type Messages_HighScores_Data struct {
	Scores []HighScore `json:"scores"`
	Users  []User      `json:"users"`
}

func (st *Messages_HighScores_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_HighScores_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Scores = make([]HighScore, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Scores[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Users[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_HighScores_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_HighScores_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_HighScores_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Scores)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Scores {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_HighScores_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_highScores struct implement
type TLmessages_highScores struct {
	Data Messages_HighScores_Data `json:"data"`
}

func (st *TLmessages_highScores) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_highScores) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_highScores) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_highScores, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_highScores) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_highScores) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputMessage struct implement
type InputMessage struct {
	Constructor int32             `json:"constructor"`
	Data        InputMessage_Data `json:"data"`
}

func (st *InputMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputMessage_Data struct implement
type InputMessage_Data struct {
	Id       int32 `json:"id"`
	Query_id int64 `json:"query_id"`
}

func (st *InputMessage_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputMessage_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Query_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputMessage_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputMessage_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputMessage_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Query_id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputMessage_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessageID struct implement
type TLinputMessageID struct {
	Data InputMessage_Data `json:"data"`
}

func (st *TLinputMessageID) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessageID) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessageID) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessageID, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessageID) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessageID) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessageReplyTo struct implement
type TLinputMessageReplyTo struct {
	Data InputMessage_Data `json:"data"`
}

func (st *TLinputMessageReplyTo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessageReplyTo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessageReplyTo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessageReplyTo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessageReplyTo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessageReplyTo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessagePinned struct implement
type TLinputMessagePinned struct {
	Data InputMessage_Data `json:"data"`
}

func (st *TLinputMessagePinned) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessagePinned) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessagePinned) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessagePinned, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessagePinned) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessagePinned) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMessageCallbackQuery struct implement
type TLinputMessageCallbackQuery struct {
	Data InputMessage_Data `json:"data"`
}

func (st *TLinputMessageCallbackQuery) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMessageCallbackQuery) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMessageCallbackQuery) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMessageCallbackQuery, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMessageCallbackQuery) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMessageCallbackQuery) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// EmojiURL struct implement
type EmojiURL struct {
	Constructor int32         `json:"constructor"`
	Data        EmojiURL_Data `json:"data"`
}

func (st *EmojiURL) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *EmojiURL) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *EmojiURL) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EmojiURL, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *EmojiURL) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *EmojiURL) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// EmojiURL_Data struct implement
type EmojiURL_Data struct {
	Url string `json:"url"`
}

func (st *EmojiURL_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *EmojiURL_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Url, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *EmojiURL_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EmojiURL_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *EmojiURL_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Url, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *EmojiURL_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLemojiURL struct implement
type TLemojiURL struct {
	Data EmojiURL_Data `json:"data"`
}

func (st *TLemojiURL) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLemojiURL) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLemojiURL) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLemojiURL, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLemojiURL) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLemojiURL) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// RecentMeUrl struct implement
type RecentMeUrl struct {
	Constructor int32            `json:"constructor"`
	Data        RecentMeUrl_Data `json:"data"`
}

func (st *RecentMeUrl) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *RecentMeUrl) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *RecentMeUrl) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RecentMeUrl, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *RecentMeUrl) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *RecentMeUrl) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// RecentMeUrl_Data struct implement
type RecentMeUrl_Data struct {
	Url         string            `json:"url"`
	User_id     int32             `json:"user_id"`
	Chat_id     int32             `json:"chat_id"`
	Chat_invite ChatInvite        `json:"chat_invite"`
	Set         StickerSetCovered `json:"set"`
}

func (st *RecentMeUrl_Data) ResetDefault() {
	st.Chat_invite.ResetDefault()
	st.Set.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *RecentMeUrl_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Url, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.User_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Chat_id, 2, false)
	if err != nil {
		return err
	}

	err = st.Chat_invite.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = st.Set.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *RecentMeUrl_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RecentMeUrl_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *RecentMeUrl_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Url, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.User_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Chat_id, 2)
	if err != nil {
		return err
	}

	err = st.Chat_invite.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = st.Set.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *RecentMeUrl_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLrecentMeUrlUnknown struct implement
type TLrecentMeUrlUnknown struct {
	Data RecentMeUrl_Data `json:"data"`
}

func (st *TLrecentMeUrlUnknown) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLrecentMeUrlUnknown) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLrecentMeUrlUnknown) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLrecentMeUrlUnknown, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLrecentMeUrlUnknown) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLrecentMeUrlUnknown) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLrecentMeUrlUser struct implement
type TLrecentMeUrlUser struct {
	Data RecentMeUrl_Data `json:"data"`
}

func (st *TLrecentMeUrlUser) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLrecentMeUrlUser) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLrecentMeUrlUser) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLrecentMeUrlUser, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLrecentMeUrlUser) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLrecentMeUrlUser) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLrecentMeUrlChat struct implement
type TLrecentMeUrlChat struct {
	Data RecentMeUrl_Data `json:"data"`
}

func (st *TLrecentMeUrlChat) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLrecentMeUrlChat) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLrecentMeUrlChat) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLrecentMeUrlChat, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLrecentMeUrlChat) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLrecentMeUrlChat) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLrecentMeUrlChatInvite struct implement
type TLrecentMeUrlChatInvite struct {
	Data RecentMeUrl_Data `json:"data"`
}

func (st *TLrecentMeUrlChatInvite) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLrecentMeUrlChatInvite) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLrecentMeUrlChatInvite) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLrecentMeUrlChatInvite, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLrecentMeUrlChatInvite) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLrecentMeUrlChatInvite) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLrecentMeUrlStickerSet struct implement
type TLrecentMeUrlStickerSet struct {
	Data RecentMeUrl_Data `json:"data"`
}

func (st *TLrecentMeUrlStickerSet) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLrecentMeUrlStickerSet) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLrecentMeUrlStickerSet) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLrecentMeUrlStickerSet, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLrecentMeUrlStickerSet) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLrecentMeUrlStickerSet) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputUser struct implement
type InputUser struct {
	Constructor int32          `json:"constructor"`
	Data        InputUser_Data `json:"data"`
}

func (st *InputUser) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputUser) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputUser) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputUser, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputUser) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputUser) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputUser_Data struct implement
type InputUser_Data struct {
	User_id     int32     `json:"user_id"`
	Access_hash int64     `json:"access_hash"`
	Peer        InputPeer `json:"peer"`
	Msg_id      int32     `json:"msg_id"`
}

func (st *InputUser_Data) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputUser_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Msg_id, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputUser_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputUser_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputUser_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.User_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Msg_id, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputUser_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputUserEmpty struct implement
type TLinputUserEmpty struct {
	Data InputUser_Data `json:"data"`
}

func (st *TLinputUserEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputUserEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputUserEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputUserEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputUserEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputUserEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputUserSelf struct implement
type TLinputUserSelf struct {
	Data InputUser_Data `json:"data"`
}

func (st *TLinputUserSelf) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputUserSelf) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputUserSelf) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputUserSelf, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputUserSelf) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputUserSelf) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputUser struct implement
type TLinputUser struct {
	Data InputUser_Data `json:"data"`
}

func (st *TLinputUser) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputUser) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputUser) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputUser, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputUser) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputUser) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputUserFromMessage struct implement
type TLinputUserFromMessage struct {
	Data InputUser_Data `json:"data"`
}

func (st *TLinputUserFromMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputUserFromMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputUserFromMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputUserFromMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputUserFromMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputUserFromMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PhotoSize struct implement
type PhotoSize struct {
	Constructor int32          `json:"constructor"`
	Data        PhotoSize_Data `json:"data"`
}

func (st *PhotoSize) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PhotoSize) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PhotoSize) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PhotoSize, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PhotoSize) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PhotoSize) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PhotoSize_Data struct implement
type PhotoSize_Data struct {
	Type     string       `json:"type"`
	Location FileLocation `json:"location"`
	W        int32        `json:"w"`
	H        int32        `json:"h"`
	Size     int32        `json:"size"`
	Bytes    []uint8      `json:"bytes"`
	Sizes    []int32      `json:"sizes"`
}

func (st *PhotoSize_Data) ResetDefault() {
	st.Location.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PhotoSize_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Type, 0, false)
	if err != nil {
		return err
	}

	err = st.Location.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.W, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.H, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Size, 4, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Bytes = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Bytes[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Bytes, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Sizes = make([]int32, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int32(&st.Sizes[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PhotoSize_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PhotoSize_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PhotoSize_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Type, 0)
	if err != nil {
		return err
	}

	err = st.Location.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.W, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.H, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Size, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Bytes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Bytes {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Sizes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Sizes {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PhotoSize_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphotoSizeEmpty struct implement
type TLphotoSizeEmpty struct {
	Data PhotoSize_Data `json:"data"`
}

func (st *TLphotoSizeEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphotoSizeEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphotoSizeEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphotoSizeEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphotoSizeEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphotoSizeEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphotoSize struct implement
type TLphotoSize struct {
	Data PhotoSize_Data `json:"data"`
}

func (st *TLphotoSize) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphotoSize) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphotoSize) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphotoSize, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphotoSize) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphotoSize) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphotoCachedSize struct implement
type TLphotoCachedSize struct {
	Data PhotoSize_Data `json:"data"`
}

func (st *TLphotoCachedSize) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphotoCachedSize) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphotoCachedSize) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphotoCachedSize, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphotoCachedSize) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphotoCachedSize) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphotoStrippedSize struct implement
type TLphotoStrippedSize struct {
	Data PhotoSize_Data `json:"data"`
}

func (st *TLphotoStrippedSize) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphotoStrippedSize) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphotoStrippedSize) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphotoStrippedSize, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphotoStrippedSize) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphotoStrippedSize) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphotoSizeProgressive struct implement
type TLphotoSizeProgressive struct {
	Data PhotoSize_Data `json:"data"`
}

func (st *TLphotoSizeProgressive) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphotoSizeProgressive) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphotoSizeProgressive) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphotoSizeProgressive, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphotoSizeProgressive) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphotoSizeProgressive) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphotoPathSize struct implement
type TLphotoPathSize struct {
	Data PhotoSize_Data `json:"data"`
}

func (st *TLphotoPathSize) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphotoPathSize) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphotoPathSize) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphotoPathSize, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphotoPathSize) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphotoPathSize) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ExportedChatInvite struct implement
type ExportedChatInvite struct {
	Constructor int32                   `json:"constructor"`
	Data        ExportedChatInvite_Data `json:"data"`
}

func (st *ExportedChatInvite) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ExportedChatInvite) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ExportedChatInvite) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ExportedChatInvite, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ExportedChatInvite) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ExportedChatInvite) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ExportedChatInvite_Data struct implement
type ExportedChatInvite_Data struct {
	Link string `json:"link"`
}

func (st *ExportedChatInvite_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *ExportedChatInvite_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Link, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ExportedChatInvite_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ExportedChatInvite_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ExportedChatInvite_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Link, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ExportedChatInvite_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatInviteEmpty struct implement
type TLchatInviteEmpty struct {
	Data ExportedChatInvite_Data `json:"data"`
}

func (st *TLchatInviteEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatInviteEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatInviteEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatInviteEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatInviteEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatInviteEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatInviteExported struct implement
type TLchatInviteExported struct {
	Data ExportedChatInvite_Data `json:"data"`
}

func (st *TLchatInviteExported) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatInviteExported) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatInviteExported) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatInviteExported, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatInviteExported) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatInviteExported) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Contacts_TopPeers struct implement
type Contacts_TopPeers struct {
	Constructor int32                  `json:"constructor"`
	Data        Contacts_TopPeers_Data `json:"data"`
}

func (st *Contacts_TopPeers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Contacts_TopPeers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Contacts_TopPeers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Contacts_TopPeers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Contacts_TopPeers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Contacts_TopPeers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Contacts_TopPeers_Data struct implement
type Contacts_TopPeers_Data struct {
	Categories []TopPeerCategoryPeers `json:"categories"`
	Chats      []Chat                 `json:"chats"`
	Users      []User                 `json:"users"`
}

func (st *Contacts_TopPeers_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Contacts_TopPeers_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Categories = make([]TopPeerCategoryPeers, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Categories[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Chats[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Users[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Contacts_TopPeers_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Contacts_TopPeers_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Contacts_TopPeers_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Categories)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Categories {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Contacts_TopPeers_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_topPeersNotModified struct implement
type TLcontacts_topPeersNotModified struct {
	Data Contacts_TopPeers_Data `json:"data"`
}

func (st *TLcontacts_topPeersNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_topPeersNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_topPeersNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_topPeersNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_topPeersNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_topPeersNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_topPeers struct implement
type TLcontacts_topPeers struct {
	Data Contacts_TopPeers_Data `json:"data"`
}

func (st *TLcontacts_topPeers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_topPeers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_topPeers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_topPeers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_topPeers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_topPeers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_topPeersDisabled struct implement
type TLcontacts_topPeersDisabled struct {
	Data Contacts_TopPeers_Data `json:"data"`
}

func (st *TLcontacts_topPeersDisabled) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_topPeersDisabled) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_topPeersDisabled) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_topPeersDisabled, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_topPeersDisabled) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_topPeersDisabled) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Dialog struct implement
type Dialog struct {
	Constructor int32       `json:"constructor"`
	Data        Dialog_Data `json:"data"`
}

func (st *Dialog) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Dialog) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Dialog) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Dialog, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Dialog) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Dialog) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Dialog_Data struct implement
type Dialog_Data struct {
	Pinned                        bool               `json:"pinned"`
	Unread_mark                   bool               `json:"unread_mark"`
	Peer                          Peer               `json:"peer"`
	Top_message                   int32              `json:"top_message"`
	Read_inbox_max_id             int32              `json:"read_inbox_max_id"`
	Read_outbox_max_id            int32              `json:"read_outbox_max_id"`
	Unread_count                  int32              `json:"unread_count"`
	Unread_mentions_count         int32              `json:"unread_mentions_count"`
	Notify_settings               PeerNotifySettings `json:"notify_settings"`
	Pts                           int32              `json:"pts"`
	Draft                         DraftMessage       `json:"draft"`
	Folder_id                     int32              `json:"folder_id"`
	Folder                        Folder             `json:"folder"`
	Unread_muted_peers_count      int32              `json:"unread_muted_peers_count"`
	Unread_unmuted_peers_count    int32              `json:"unread_unmuted_peers_count"`
	Unread_muted_messages_count   int32              `json:"unread_muted_messages_count"`
	Unread_unmuted_messages_count int32              `json:"unread_unmuted_messages_count"`
}

func (st *Dialog_Data) ResetDefault() {
	st.Peer.ResetDefault()
	st.Notify_settings.ResetDefault()
	st.Draft.ResetDefault()
	st.Folder.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Dialog_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Pinned, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Unread_mark, 1, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Top_message, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Read_inbox_max_id, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Read_outbox_max_id, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Unread_count, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Unread_mentions_count, 7, false)
	if err != nil {
		return err
	}

	err = st.Notify_settings.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Pts, 9, false)
	if err != nil {
		return err
	}

	err = st.Draft.ReadBlock(_is, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Folder_id, 11, false)
	if err != nil {
		return err
	}

	err = st.Folder.ReadBlock(_is, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Unread_muted_peers_count, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Unread_unmuted_peers_count, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Unread_muted_messages_count, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Unread_unmuted_messages_count, 16, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Dialog_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Dialog_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Dialog_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Pinned, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Unread_mark, 1)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Top_message, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Read_inbox_max_id, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Read_outbox_max_id, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Unread_count, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Unread_mentions_count, 7)
	if err != nil {
		return err
	}

	err = st.Notify_settings.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Pts, 9)
	if err != nil {
		return err
	}

	err = st.Draft.WriteBlock(_os, 10)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Folder_id, 11)
	if err != nil {
		return err
	}

	err = st.Folder.WriteBlock(_os, 12)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Unread_muted_peers_count, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Unread_unmuted_peers_count, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Unread_muted_messages_count, 15)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Unread_unmuted_messages_count, 16)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Dialog_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdialog struct implement
type TLdialog struct {
	Data Dialog_Data `json:"data"`
}

func (st *TLdialog) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdialog) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdialog) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdialog, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdialog) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdialog) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdialogFolder struct implement
type TLdialogFolder struct {
	Data Dialog_Data `json:"data"`
}

func (st *TLdialogFolder) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdialogFolder) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdialogFolder) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdialogFolder, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdialogFolder) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdialogFolder) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StatsDateRangeDays struct implement
type StatsDateRangeDays struct {
	Constructor int32                   `json:"constructor"`
	Data        StatsDateRangeDays_Data `json:"data"`
}

func (st *StatsDateRangeDays) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *StatsDateRangeDays) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StatsDateRangeDays) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StatsDateRangeDays, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StatsDateRangeDays) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StatsDateRangeDays) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StatsDateRangeDays_Data struct implement
type StatsDateRangeDays_Data struct {
	Min_date int32 `json:"min_date"`
	Max_date int32 `json:"max_date"`
}

func (st *StatsDateRangeDays_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *StatsDateRangeDays_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Min_date, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_date, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StatsDateRangeDays_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StatsDateRangeDays_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StatsDateRangeDays_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Min_date, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_date, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StatsDateRangeDays_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstatsDateRangeDays struct implement
type TLstatsDateRangeDays struct {
	Data StatsDateRangeDays_Data `json:"data"`
}

func (st *TLstatsDateRangeDays) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstatsDateRangeDays) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstatsDateRangeDays) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstatsDateRangeDays, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstatsDateRangeDays) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstatsDateRangeDays) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_WebAuthorizations struct implement
type Account_WebAuthorizations struct {
	Constructor int32                          `json:"constructor"`
	Data        Account_WebAuthorizations_Data `json:"data"`
}

func (st *Account_WebAuthorizations) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_WebAuthorizations) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_WebAuthorizations) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_WebAuthorizations, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_WebAuthorizations) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_WebAuthorizations) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_WebAuthorizations_Data struct implement
type Account_WebAuthorizations_Data struct {
	Authorizations []WebAuthorization `json:"authorizations"`
	Users          []User             `json:"users"`
}

func (st *Account_WebAuthorizations_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_WebAuthorizations_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Authorizations = make([]WebAuthorization, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Authorizations[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Users[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_WebAuthorizations_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_WebAuthorizations_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_WebAuthorizations_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Authorizations)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Authorizations {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_WebAuthorizations_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_webAuthorizations struct implement
type TLaccount_webAuthorizations struct {
	Data Account_WebAuthorizations_Data `json:"data"`
}

func (st *TLaccount_webAuthorizations) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_webAuthorizations) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_webAuthorizations) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_webAuthorizations, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_webAuthorizations) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_webAuthorizations) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Stats_MegagroupStats struct implement
type Stats_MegagroupStats struct {
	Constructor int32                     `json:"constructor"`
	Data        Stats_MegagroupStats_Data `json:"data"`
}

func (st *Stats_MegagroupStats) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Stats_MegagroupStats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Stats_MegagroupStats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Stats_MegagroupStats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Stats_MegagroupStats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Stats_MegagroupStats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Stats_MegagroupStats_Data struct implement
type Stats_MegagroupStats_Data struct {
	Period                      StatsDateRangeDays     `json:"period"`
	Members                     StatsAbsValueAndPrev   `json:"members"`
	Messages                    StatsAbsValueAndPrev   `json:"messages"`
	Viewers                     StatsAbsValueAndPrev   `json:"viewers"`
	Posters                     StatsAbsValueAndPrev   `json:"posters"`
	Growth_graph                StatsGraph             `json:"growth_graph"`
	Members_graph               StatsGraph             `json:"members_graph"`
	New_members_by_source_graph StatsGraph             `json:"new_members_by_source_graph"`
	Languages_graph             StatsGraph             `json:"languages_graph"`
	Messages_graph              StatsGraph             `json:"messages_graph"`
	Actions_graph               StatsGraph             `json:"actions_graph"`
	Top_hours_graph             StatsGraph             `json:"top_hours_graph"`
	Weekdays_graph              StatsGraph             `json:"weekdays_graph"`
	Top_posters                 []StatsGroupTopPoster  `json:"top_posters"`
	Top_admins                  []StatsGroupTopAdmin   `json:"top_admins"`
	Top_inviters                []StatsGroupTopInviter `json:"top_inviters"`
	Users                       []User                 `json:"users"`
}

func (st *Stats_MegagroupStats_Data) ResetDefault() {
	st.Period.ResetDefault()
	st.Members.ResetDefault()
	st.Messages.ResetDefault()
	st.Viewers.ResetDefault()
	st.Posters.ResetDefault()
	st.Growth_graph.ResetDefault()
	st.Members_graph.ResetDefault()
	st.New_members_by_source_graph.ResetDefault()
	st.Languages_graph.ResetDefault()
	st.Messages_graph.ResetDefault()
	st.Actions_graph.ResetDefault()
	st.Top_hours_graph.ResetDefault()
	st.Weekdays_graph.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Stats_MegagroupStats_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Period.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Members.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.Messages.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = st.Viewers.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = st.Posters.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = st.Growth_graph.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = st.Members_graph.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	err = st.New_members_by_source_graph.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	err = st.Languages_graph.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err = st.Messages_graph.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err = st.Actions_graph.ReadBlock(_is, 10, false)
	if err != nil {
		return err
	}

	err = st.Top_hours_graph.ReadBlock(_is, 11, false)
	if err != nil {
		return err
	}

	err = st.Weekdays_graph.ReadBlock(_is, 12, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(13, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Top_posters = make([]StatsGroupTopPoster, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Top_posters[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(14, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Top_admins = make([]StatsGroupTopAdmin, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Top_admins[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(15, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Top_inviters = make([]StatsGroupTopInviter, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Top_inviters[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(16, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Users[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Stats_MegagroupStats_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Stats_MegagroupStats_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Stats_MegagroupStats_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Period.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Members.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.Messages.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = st.Viewers.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = st.Posters.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = st.Growth_graph.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = st.Members_graph.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	err = st.New_members_by_source_graph.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	err = st.Languages_graph.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = st.Messages_graph.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = st.Actions_graph.WriteBlock(_os, 10)
	if err != nil {
		return err
	}

	err = st.Top_hours_graph.WriteBlock(_os, 11)
	if err != nil {
		return err
	}

	err = st.Weekdays_graph.WriteBlock(_os, 12)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Top_posters)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Top_posters {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Top_admins)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Top_admins {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 15)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Top_inviters)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Top_inviters {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 16)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Stats_MegagroupStats_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstats_megagroupStats struct implement
type TLstats_megagroupStats struct {
	Data Stats_MegagroupStats_Data `json:"data"`
}

func (st *TLstats_megagroupStats) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstats_megagroupStats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstats_megagroupStats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstats_megagroupStats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstats_megagroupStats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstats_megagroupStats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_PasswordSettings struct implement
type Account_PasswordSettings struct {
	Constructor int32                         `json:"constructor"`
	Data        Account_PasswordSettings_Data `json:"data"`
}

func (st *Account_PasswordSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_PasswordSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_PasswordSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_PasswordSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_PasswordSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_PasswordSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_PasswordSettings_Data struct implement
type Account_PasswordSettings_Data struct {
	Email           string               `json:"email"`
	Secure_settings SecureSecretSettings `json:"secure_settings"`
}

func (st *Account_PasswordSettings_Data) ResetDefault() {
	st.Secure_settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_PasswordSettings_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Email, 0, false)
	if err != nil {
		return err
	}

	err = st.Secure_settings.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_PasswordSettings_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_PasswordSettings_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_PasswordSettings_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Email, 0)
	if err != nil {
		return err
	}

	err = st.Secure_settings.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_PasswordSettings_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_passwordSettings struct implement
type TLaccount_passwordSettings struct {
	Data Account_PasswordSettings_Data `json:"data"`
}

func (st *TLaccount_passwordSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_passwordSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_passwordSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_passwordSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_passwordSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_passwordSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputChatPhoto struct implement
type InputChatPhoto struct {
	Constructor int32               `json:"constructor"`
	Data        InputChatPhoto_Data `json:"data"`
}

func (st *InputChatPhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputChatPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputChatPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputChatPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputChatPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputChatPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputChatPhoto_Data struct implement
type InputChatPhoto_Data struct {
	File           InputFile  `json:"file"`
	Video          InputFile  `json:"video"`
	Video_start_ts float64    `json:"video_start_ts"`
	Id             InputPhoto `json:"id"`
}

func (st *InputChatPhoto_Data) ResetDefault() {
	st.File.ResetDefault()
	st.Video.ResetDefault()
	st.Id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputChatPhoto_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.File.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Video.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Video_start_ts, 2, false)
	if err != nil {
		return err
	}

	err = st.Id.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputChatPhoto_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputChatPhoto_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputChatPhoto_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.File.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Video.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Video_start_ts, 2)
	if err != nil {
		return err
	}

	err = st.Id.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputChatPhoto_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputChatPhotoEmpty struct implement
type TLinputChatPhotoEmpty struct {
	Data InputChatPhoto_Data `json:"data"`
}

func (st *TLinputChatPhotoEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputChatPhotoEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputChatPhotoEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputChatPhotoEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputChatPhotoEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputChatPhotoEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputChatUploadedPhoto struct implement
type TLinputChatUploadedPhoto struct {
	Data InputChatPhoto_Data `json:"data"`
}

func (st *TLinputChatUploadedPhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputChatUploadedPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputChatUploadedPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputChatUploadedPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputChatUploadedPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputChatUploadedPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputChatPhoto struct implement
type TLinputChatPhoto struct {
	Data InputChatPhoto_Data `json:"data"`
}

func (st *TLinputChatPhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputChatPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputChatPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputChatPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputChatPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputChatPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChannelParticipantsFilter struct implement
type ChannelParticipantsFilter struct {
	Constructor int32                          `json:"constructor"`
	Data        ChannelParticipantsFilter_Data `json:"data"`
}

func (st *ChannelParticipantsFilter) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChannelParticipantsFilter) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChannelParticipantsFilter) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChannelParticipantsFilter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChannelParticipantsFilter) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChannelParticipantsFilter) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChannelParticipantsFilter_Data struct implement
type ChannelParticipantsFilter_Data struct {
	Q          string `json:"q"`
	Top_msg_id int32  `json:"top_msg_id"`
}

func (st *ChannelParticipantsFilter_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *ChannelParticipantsFilter_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Q, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Top_msg_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChannelParticipantsFilter_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChannelParticipantsFilter_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChannelParticipantsFilter_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Q, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Top_msg_id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChannelParticipantsFilter_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelParticipantsRecent struct implement
type TLchannelParticipantsRecent struct {
	Data ChannelParticipantsFilter_Data `json:"data"`
}

func (st *TLchannelParticipantsRecent) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelParticipantsRecent) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelParticipantsRecent) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelParticipantsRecent, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelParticipantsRecent) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelParticipantsRecent) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelParticipantsAdmins struct implement
type TLchannelParticipantsAdmins struct {
	Data ChannelParticipantsFilter_Data `json:"data"`
}

func (st *TLchannelParticipantsAdmins) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelParticipantsAdmins) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelParticipantsAdmins) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelParticipantsAdmins, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelParticipantsAdmins) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelParticipantsAdmins) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelParticipantsKicked struct implement
type TLchannelParticipantsKicked struct {
	Data ChannelParticipantsFilter_Data `json:"data"`
}

func (st *TLchannelParticipantsKicked) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelParticipantsKicked) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelParticipantsKicked) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelParticipantsKicked, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelParticipantsKicked) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelParticipantsKicked) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelParticipantsBots struct implement
type TLchannelParticipantsBots struct {
	Data ChannelParticipantsFilter_Data `json:"data"`
}

func (st *TLchannelParticipantsBots) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelParticipantsBots) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelParticipantsBots) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelParticipantsBots, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelParticipantsBots) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelParticipantsBots) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelParticipantsBanned struct implement
type TLchannelParticipantsBanned struct {
	Data ChannelParticipantsFilter_Data `json:"data"`
}

func (st *TLchannelParticipantsBanned) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelParticipantsBanned) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelParticipantsBanned) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelParticipantsBanned, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelParticipantsBanned) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelParticipantsBanned) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelParticipantsSearch struct implement
type TLchannelParticipantsSearch struct {
	Data ChannelParticipantsFilter_Data `json:"data"`
}

func (st *TLchannelParticipantsSearch) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelParticipantsSearch) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelParticipantsSearch) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelParticipantsSearch, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelParticipantsSearch) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelParticipantsSearch) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelParticipantsContacts struct implement
type TLchannelParticipantsContacts struct {
	Data ChannelParticipantsFilter_Data `json:"data"`
}

func (st *TLchannelParticipantsContacts) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelParticipantsContacts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelParticipantsContacts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelParticipantsContacts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelParticipantsContacts) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelParticipantsContacts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelParticipantsMentions struct implement
type TLchannelParticipantsMentions struct {
	Data ChannelParticipantsFilter_Data `json:"data"`
}

func (st *TLchannelParticipantsMentions) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelParticipantsMentions) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelParticipantsMentions) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelParticipantsMentions, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelParticipantsMentions) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelParticipantsMentions) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_Chats struct implement
type Messages_Chats struct {
	Constructor int32               `json:"constructor"`
	Data        Messages_Chats_Data `json:"data"`
}

func (st *Messages_Chats) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_Chats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_Chats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_Chats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_Chats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_Chats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_Chats_Data struct implement
type Messages_Chats_Data struct {
	Chats []Chat `json:"chats"`
	Count int32  `json:"count"`
}

func (st *Messages_Chats_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_Chats_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Chats[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Count, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_Chats_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_Chats_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_Chats_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Count, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_Chats_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_chats struct implement
type TLmessages_chats struct {
	Data Messages_Chats_Data `json:"data"`
}

func (st *TLmessages_chats) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_chats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_chats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_chats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_chats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_chats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_chatsSlice struct implement
type TLmessages_chatsSlice struct {
	Data Messages_Chats_Data `json:"data"`
}

func (st *TLmessages_chatsSlice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_chatsSlice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_chatsSlice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_chatsSlice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_chatsSlice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_chatsSlice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// EmojiKeywordsDifference struct implement
type EmojiKeywordsDifference struct {
	Constructor int32                        `json:"constructor"`
	Data        EmojiKeywordsDifference_Data `json:"data"`
}

func (st *EmojiKeywordsDifference) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *EmojiKeywordsDifference) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *EmojiKeywordsDifference) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EmojiKeywordsDifference, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *EmojiKeywordsDifference) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *EmojiKeywordsDifference) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// EmojiKeywordsDifference_Data struct implement
type EmojiKeywordsDifference_Data struct {
	Lang_code    string         `json:"lang_code"`
	From_version int32          `json:"from_version"`
	Version      int32          `json:"version"`
	Keywords     []EmojiKeyword `json:"keywords"`
}

func (st *EmojiKeywordsDifference_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *EmojiKeywordsDifference_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Lang_code, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.From_version, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Version, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Keywords = make([]EmojiKeyword, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Keywords[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *EmojiKeywordsDifference_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EmojiKeywordsDifference_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *EmojiKeywordsDifference_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Lang_code, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.From_version, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Version, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Keywords)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Keywords {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *EmojiKeywordsDifference_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLemojiKeywordsDifference struct implement
type TLemojiKeywordsDifference struct {
	Data EmojiKeywordsDifference_Data `json:"data"`
}

func (st *TLemojiKeywordsDifference) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLemojiKeywordsDifference) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLemojiKeywordsDifference) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLemojiKeywordsDifference, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLemojiKeywordsDifference) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLemojiKeywordsDifference) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureData struct implement
type SecureData struct {
	Constructor int32           `json:"constructor"`
	Data        SecureData_Data `json:"data"`
}

func (st *SecureData) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureData) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureData_Data struct implement
type SecureData_Data struct {
	Data      []uint8 `json:"data"`
	Data_hash []uint8 `json:"data_hash"`
	Secret    []uint8 `json:"secret"`
}

func (st *SecureData_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureData_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Data = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Data[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Data, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Data_hash = make([]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_uint8(&st.Data_hash[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Data_hash, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Secret = make([]uint8, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = _is.Read_uint8(&st.Secret[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Secret, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureData_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureData_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureData_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Data)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Data {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Data_hash)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Data_hash {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Secret)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Secret {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureData_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureData struct implement
type TLsecureData struct {
	Data SecureData_Data `json:"data"`
}

func (st *TLsecureData) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureData) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChannelAdminLogEventsFilter struct implement
type ChannelAdminLogEventsFilter struct {
	Constructor int32                            `json:"constructor"`
	Data        ChannelAdminLogEventsFilter_Data `json:"data"`
}

func (st *ChannelAdminLogEventsFilter) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChannelAdminLogEventsFilter) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChannelAdminLogEventsFilter) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChannelAdminLogEventsFilter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChannelAdminLogEventsFilter) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChannelAdminLogEventsFilter) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChannelAdminLogEventsFilter_Data struct implement
type ChannelAdminLogEventsFilter_Data struct {
	Join       bool `json:"join"`
	Leave      bool `json:"leave"`
	Invite     bool `json:"invite"`
	Ban        bool `json:"ban"`
	Unban      bool `json:"unban"`
	Kick       bool `json:"kick"`
	Unkick     bool `json:"unkick"`
	Promote    bool `json:"promote"`
	Demote     bool `json:"demote"`
	Info       bool `json:"info"`
	Settings   bool `json:"settings"`
	Pinned     bool `json:"pinned"`
	Edit       bool `json:"edit"`
	Delete     bool `json:"delete"`
	Group_call bool `json:"group_call"`
}

func (st *ChannelAdminLogEventsFilter_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *ChannelAdminLogEventsFilter_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Join, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Leave, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Invite, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Ban, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Unban, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Kick, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Unkick, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Promote, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Demote, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Info, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Settings, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Pinned, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Edit, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Delete, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Group_call, 14, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChannelAdminLogEventsFilter_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChannelAdminLogEventsFilter_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChannelAdminLogEventsFilter_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Join, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Leave, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Invite, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Ban, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Unban, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Kick, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Unkick, 6)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Promote, 7)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Demote, 8)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Info, 9)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Settings, 10)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Pinned, 11)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Edit, 12)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Delete, 13)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Group_call, 14)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChannelAdminLogEventsFilter_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventsFilter struct implement
type TLchannelAdminLogEventsFilter struct {
	Data ChannelAdminLogEventsFilter_Data `json:"data"`
}

func (st *TLchannelAdminLogEventsFilter) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventsFilter) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventsFilter) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventsFilter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventsFilter) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventsFilter) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PhoneConnection struct implement
type PhoneConnection struct {
	Constructor int32                `json:"constructor"`
	Data        PhoneConnection_Data `json:"data"`
}

func (st *PhoneConnection) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PhoneConnection) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PhoneConnection) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PhoneConnection, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PhoneConnection) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PhoneConnection) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PhoneConnection_Data struct implement
type PhoneConnection_Data struct {
	Id       int64   `json:"id"`
	Ip       string  `json:"ip"`
	Ipv6     string  `json:"ipv6"`
	Port     int32   `json:"port"`
	Peer_tag []uint8 `json:"peer_tag"`
	Turn     bool    `json:"turn"`
	Stun     bool    `json:"stun"`
	Username string  `json:"username"`
	Password string  `json:"password"`
}

func (st *PhoneConnection_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *PhoneConnection_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Ip, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Ipv6, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Port, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Peer_tag = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Peer_tag[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Peer_tag, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_bool(&st.Turn, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Stun, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Username, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Password, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PhoneConnection_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PhoneConnection_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PhoneConnection_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Ip, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Ipv6, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Port, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Peer_tag)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Peer_tag {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_bool(st.Turn, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Stun, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Username, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Password, 8)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PhoneConnection_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphoneConnection struct implement
type TLphoneConnection struct {
	Data PhoneConnection_Data `json:"data"`
}

func (st *TLphoneConnection) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphoneConnection) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphoneConnection) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphoneConnection, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphoneConnection) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphoneConnection) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphoneConnectionWebrtc struct implement
type TLphoneConnectionWebrtc struct {
	Data PhoneConnection_Data `json:"data"`
}

func (st *TLphoneConnectionWebrtc) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphoneConnectionWebrtc) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphoneConnectionWebrtc) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphoneConnectionWebrtc, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphoneConnectionWebrtc) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphoneConnectionWebrtc) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Photos_Photo struct implement
type Photos_Photo struct {
	Constructor int32             `json:"constructor"`
	Data        Photos_Photo_Data `json:"data"`
}

func (st *Photos_Photo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Photos_Photo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Photos_Photo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Photos_Photo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Photos_Photo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Photos_Photo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Photos_Photo_Data struct implement
type Photos_Photo_Data struct {
	Photo Photo  `json:"photo"`
	Users []User `json:"users"`
}

func (st *Photos_Photo_Data) ResetDefault() {
	st.Photo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Photos_Photo_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Photo.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Users[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Photos_Photo_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Photos_Photo_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Photos_Photo_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Photo.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Photos_Photo_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphotos_photo struct implement
type TLphotos_photo struct {
	Data Photos_Photo_Data `json:"data"`
}

func (st *TLphotos_photo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphotos_photo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphotos_photo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphotos_photo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphotos_photo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphotos_photo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_ContentSettings struct implement
type Account_ContentSettings struct {
	Constructor int32                        `json:"constructor"`
	Data        Account_ContentSettings_Data `json:"data"`
}

func (st *Account_ContentSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_ContentSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_ContentSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_ContentSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_ContentSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_ContentSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_ContentSettings_Data struct implement
type Account_ContentSettings_Data struct {
	Sensitive_enabled    bool `json:"sensitive_enabled"`
	Sensitive_can_change bool `json:"sensitive_can_change"`
}

func (st *Account_ContentSettings_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_ContentSettings_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Sensitive_enabled, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Sensitive_can_change, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_ContentSettings_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_ContentSettings_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_ContentSettings_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Sensitive_enabled, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Sensitive_can_change, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_ContentSettings_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_contentSettings struct implement
type TLaccount_contentSettings struct {
	Data Account_ContentSettings_Data `json:"data"`
}

func (st *TLaccount_contentSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_contentSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_contentSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_contentSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_contentSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_contentSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// BotCommand struct implement
type BotCommand struct {
	Constructor int32           `json:"constructor"`
	Data        BotCommand_Data `json:"data"`
}

func (st *BotCommand) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *BotCommand) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *BotCommand) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BotCommand, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *BotCommand) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *BotCommand) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// BotCommand_Data struct implement
type BotCommand_Data struct {
	Command     string `json:"command"`
	Description string `json:"description"`
}

func (st *BotCommand_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *BotCommand_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Command, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Description, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *BotCommand_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BotCommand_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *BotCommand_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Command, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Description, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *BotCommand_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbotCommand struct implement
type TLbotCommand struct {
	Data BotCommand_Data `json:"data"`
}

func (st *TLbotCommand) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbotCommand) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbotCommand) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbotCommand, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbotCommand) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbotCommand) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_PasswordInputSettings struct implement
type Account_PasswordInputSettings struct {
	Constructor int32                              `json:"constructor"`
	Data        Account_PasswordInputSettings_Data `json:"data"`
}

func (st *Account_PasswordInputSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_PasswordInputSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_PasswordInputSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_PasswordInputSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_PasswordInputSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_PasswordInputSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_PasswordInputSettings_Data struct implement
type Account_PasswordInputSettings_Data struct {
	New_algo            PasswordKdfAlgo      `json:"new_algo"`
	New_password_hash   []uint8              `json:"new_password_hash"`
	Hint                string               `json:"hint"`
	Email               string               `json:"email"`
	New_secure_settings SecureSecretSettings `json:"new_secure_settings"`
}

func (st *Account_PasswordInputSettings_Data) ResetDefault() {
	st.New_algo.ResetDefault()
	st.New_secure_settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_PasswordInputSettings_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.New_algo.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.New_password_hash = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.New_password_hash[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.New_password_hash, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Hint, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Email, 3, false)
	if err != nil {
		return err
	}

	err = st.New_secure_settings.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_PasswordInputSettings_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_PasswordInputSettings_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_PasswordInputSettings_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.New_algo.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.New_password_hash)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.New_password_hash {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Hint, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Email, 3)
	if err != nil {
		return err
	}

	err = st.New_secure_settings.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_PasswordInputSettings_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_passwordInputSettings struct implement
type TLaccount_passwordInputSettings struct {
	Data Account_PasswordInputSettings_Data `json:"data"`
}

func (st *TLaccount_passwordInputSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_passwordInputSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_passwordInputSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_passwordInputSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_passwordInputSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_passwordInputSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Stats_MessageStats struct implement
type Stats_MessageStats struct {
	Constructor int32                   `json:"constructor"`
	Data        Stats_MessageStats_Data `json:"data"`
}

func (st *Stats_MessageStats) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Stats_MessageStats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Stats_MessageStats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Stats_MessageStats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Stats_MessageStats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Stats_MessageStats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Stats_MessageStats_Data struct implement
type Stats_MessageStats_Data struct {
	Views_graph StatsGraph `json:"views_graph"`
}

func (st *Stats_MessageStats_Data) ResetDefault() {
	st.Views_graph.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Stats_MessageStats_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Views_graph.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Stats_MessageStats_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Stats_MessageStats_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Stats_MessageStats_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Views_graph.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Stats_MessageStats_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstats_messageStats struct implement
type TLstats_messageStats struct {
	Data Stats_MessageStats_Data `json:"data"`
}

func (st *TLstats_messageStats) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstats_messageStats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstats_messageStats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstats_messageStats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstats_messageStats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstats_messageStats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureSecretSettings struct implement
type SecureSecretSettings struct {
	Constructor int32                     `json:"constructor"`
	Data        SecureSecretSettings_Data `json:"data"`
}

func (st *SecureSecretSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureSecretSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureSecretSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureSecretSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureSecretSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureSecretSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureSecretSettings_Data struct implement
type SecureSecretSettings_Data struct {
	Secure_algo      SecurePasswordKdfAlgo `json:"secure_algo"`
	Secure_secret    []uint8               `json:"secure_secret"`
	Secure_secret_id int64                 `json:"secure_secret_id"`
}

func (st *SecureSecretSettings_Data) ResetDefault() {
	st.Secure_algo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureSecretSettings_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Secure_algo.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Secure_secret = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Secure_secret[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Secure_secret, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int64(&st.Secure_secret_id, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureSecretSettings_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureSecretSettings_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureSecretSettings_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Secure_algo.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Secure_secret)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Secure_secret {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int64(st.Secure_secret_id, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureSecretSettings_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureSecretSettings struct implement
type TLsecureSecretSettings struct {
	Data SecureSecretSettings_Data `json:"data"`
}

func (st *TLsecureSecretSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureSecretSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureSecretSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureSecretSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureSecretSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureSecretSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_WallPapers struct implement
type Account_WallPapers struct {
	Constructor int32                   `json:"constructor"`
	Data        Account_WallPapers_Data `json:"data"`
}

func (st *Account_WallPapers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_WallPapers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_WallPapers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_WallPapers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_WallPapers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_WallPapers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_WallPapers_Data struct implement
type Account_WallPapers_Data struct {
	Hash       int32       `json:"hash"`
	Wallpapers []WallPaper `json:"wallpapers"`
}

func (st *Account_WallPapers_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_WallPapers_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Wallpapers = make([]WallPaper, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Wallpapers[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_WallPapers_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_WallPapers_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_WallPapers_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Wallpapers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Wallpapers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_WallPapers_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_wallPapersNotModified struct implement
type TLaccount_wallPapersNotModified struct {
	Data Account_WallPapers_Data `json:"data"`
}

func (st *TLaccount_wallPapersNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_wallPapersNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_wallPapersNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_wallPapersNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_wallPapersNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_wallPapersNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_wallPapers struct implement
type TLaccount_wallPapers struct {
	Data Account_WallPapers_Data `json:"data"`
}

func (st *TLaccount_wallPapers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_wallPapers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_wallPapers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_wallPapers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_wallPapers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_wallPapers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputSingleMedia struct implement
type InputSingleMedia struct {
	Constructor int32                 `json:"constructor"`
	Data        InputSingleMedia_Data `json:"data"`
}

func (st *InputSingleMedia) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputSingleMedia) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputSingleMedia) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputSingleMedia, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputSingleMedia) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputSingleMedia) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputSingleMedia_Data struct implement
type InputSingleMedia_Data struct {
	Media     InputMedia      `json:"media"`
	Random_id int64           `json:"random_id"`
	Message   string          `json:"message"`
	Entities  []MessageEntity `json:"entities"`
}

func (st *InputSingleMedia_Data) ResetDefault() {
	st.Media.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputSingleMedia_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Media.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Random_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputSingleMedia_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputSingleMedia_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputSingleMedia_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Media.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Random_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputSingleMedia_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputSingleMedia struct implement
type TLinputSingleMedia struct {
	Data InputSingleMedia_Data `json:"data"`
}

func (st *TLinputSingleMedia) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputSingleMedia) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputSingleMedia) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputSingleMedia, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputSingleMedia) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputSingleMedia) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputFolderPeer struct implement
type InputFolderPeer struct {
	Constructor int32                `json:"constructor"`
	Data        InputFolderPeer_Data `json:"data"`
}

func (st *InputFolderPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputFolderPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputFolderPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputFolderPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputFolderPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputFolderPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputFolderPeer_Data struct implement
type InputFolderPeer_Data struct {
	Peer      InputPeer `json:"peer"`
	Folder_id int32     `json:"folder_id"`
}

func (st *InputFolderPeer_Data) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputFolderPeer_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Folder_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputFolderPeer_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputFolderPeer_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputFolderPeer_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Folder_id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputFolderPeer_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputFolderPeer struct implement
type TLinputFolderPeer struct {
	Data InputFolderPeer_Data `json:"data"`
}

func (st *TLinputFolderPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputFolderPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputFolderPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputFolderPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputFolderPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputFolderPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_SavedGifs struct implement
type Messages_SavedGifs struct {
	Constructor int32                   `json:"constructor"`
	Data        Messages_SavedGifs_Data `json:"data"`
}

func (st *Messages_SavedGifs) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_SavedGifs) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_SavedGifs) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_SavedGifs, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_SavedGifs) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_SavedGifs) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_SavedGifs_Data struct implement
type Messages_SavedGifs_Data struct {
	Hash int32      `json:"hash"`
	Gifs []Document `json:"gifs"`
}

func (st *Messages_SavedGifs_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_SavedGifs_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Gifs = make([]Document, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Gifs[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_SavedGifs_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_SavedGifs_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_SavedGifs_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Gifs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Gifs {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_SavedGifs_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_savedGifsNotModified struct implement
type TLmessages_savedGifsNotModified struct {
	Data Messages_SavedGifs_Data `json:"data"`
}

func (st *TLmessages_savedGifsNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_savedGifsNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_savedGifsNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_savedGifsNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_savedGifsNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_savedGifsNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_savedGifs struct implement
type TLmessages_savedGifs struct {
	Data Messages_SavedGifs_Data `json:"data"`
}

func (st *TLmessages_savedGifs) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_savedGifs) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_savedGifs) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_savedGifs, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_savedGifs) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_savedGifs) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// AutoDownloadSettings struct implement
type AutoDownloadSettings struct {
	Constructor int32                     `json:"constructor"`
	Data        AutoDownloadSettings_Data `json:"data"`
}

func (st *AutoDownloadSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *AutoDownloadSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *AutoDownloadSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AutoDownloadSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *AutoDownloadSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *AutoDownloadSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// AutoDownloadSettings_Data struct implement
type AutoDownloadSettings_Data struct {
	Disabled                bool  `json:"disabled"`
	Video_preload_large     bool  `json:"video_preload_large"`
	Audio_preload_next      bool  `json:"audio_preload_next"`
	Phonecalls_less_data    bool  `json:"phonecalls_less_data"`
	Photo_size_max          int32 `json:"photo_size_max"`
	Video_size_max          int32 `json:"video_size_max"`
	File_size_max           int32 `json:"file_size_max"`
	Video_upload_maxbitrate int32 `json:"video_upload_maxbitrate"`
}

func (st *AutoDownloadSettings_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *AutoDownloadSettings_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Disabled, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Video_preload_large, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Audio_preload_next, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Phonecalls_less_data, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Photo_size_max, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Video_size_max, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.File_size_max, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Video_upload_maxbitrate, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *AutoDownloadSettings_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AutoDownloadSettings_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *AutoDownloadSettings_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Disabled, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Video_preload_large, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Audio_preload_next, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Phonecalls_less_data, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Photo_size_max, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Video_size_max, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.File_size_max, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Video_upload_maxbitrate, 7)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *AutoDownloadSettings_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLautoDownloadSettings struct implement
type TLautoDownloadSettings struct {
	Data AutoDownloadSettings_Data `json:"data"`
}

func (st *TLautoDownloadSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLautoDownloadSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLautoDownloadSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLautoDownloadSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLautoDownloadSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLautoDownloadSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// CdnConfig struct implement
type CdnConfig struct {
	Constructor int32          `json:"constructor"`
	Data        CdnConfig_Data `json:"data"`
}

func (st *CdnConfig) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *CdnConfig) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *CdnConfig) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CdnConfig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *CdnConfig) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *CdnConfig) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// CdnConfig_Data struct implement
type CdnConfig_Data struct {
	Public_keys []CdnPublicKey `json:"public_keys"`
}

func (st *CdnConfig_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *CdnConfig_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Public_keys = make([]CdnPublicKey, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Public_keys[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *CdnConfig_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CdnConfig_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *CdnConfig_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Public_keys)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Public_keys {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *CdnConfig_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcdnConfig struct implement
type TLcdnConfig struct {
	Data CdnConfig_Data `json:"data"`
}

func (st *TLcdnConfig) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcdnConfig) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcdnConfig) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcdnConfig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcdnConfig) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcdnConfig) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PrivacyRule struct implement
type PrivacyRule struct {
	Constructor int32            `json:"constructor"`
	Data        PrivacyRule_Data `json:"data"`
}

func (st *PrivacyRule) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PrivacyRule) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PrivacyRule) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PrivacyRule, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PrivacyRule) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PrivacyRule) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PrivacyRule_Data struct implement
type PrivacyRule_Data struct {
	Users []int32 `json:"users"`
	Chats []int32 `json:"chats"`
}

func (st *PrivacyRule_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *PrivacyRule_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Users[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]int32, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int32(&st.Chats[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PrivacyRule_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PrivacyRule_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PrivacyRule_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PrivacyRule_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLprivacyValueAllowContacts struct implement
type TLprivacyValueAllowContacts struct {
	Data PrivacyRule_Data `json:"data"`
}

func (st *TLprivacyValueAllowContacts) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLprivacyValueAllowContacts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLprivacyValueAllowContacts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLprivacyValueAllowContacts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLprivacyValueAllowContacts) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLprivacyValueAllowContacts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLprivacyValueAllowAll struct implement
type TLprivacyValueAllowAll struct {
	Data PrivacyRule_Data `json:"data"`
}

func (st *TLprivacyValueAllowAll) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLprivacyValueAllowAll) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLprivacyValueAllowAll) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLprivacyValueAllowAll, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLprivacyValueAllowAll) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLprivacyValueAllowAll) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLprivacyValueAllowUsers struct implement
type TLprivacyValueAllowUsers struct {
	Data PrivacyRule_Data `json:"data"`
}

func (st *TLprivacyValueAllowUsers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLprivacyValueAllowUsers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLprivacyValueAllowUsers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLprivacyValueAllowUsers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLprivacyValueAllowUsers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLprivacyValueAllowUsers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLprivacyValueDisallowContacts struct implement
type TLprivacyValueDisallowContacts struct {
	Data PrivacyRule_Data `json:"data"`
}

func (st *TLprivacyValueDisallowContacts) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLprivacyValueDisallowContacts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLprivacyValueDisallowContacts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLprivacyValueDisallowContacts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLprivacyValueDisallowContacts) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLprivacyValueDisallowContacts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLprivacyValueDisallowAll struct implement
type TLprivacyValueDisallowAll struct {
	Data PrivacyRule_Data `json:"data"`
}

func (st *TLprivacyValueDisallowAll) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLprivacyValueDisallowAll) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLprivacyValueDisallowAll) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLprivacyValueDisallowAll, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLprivacyValueDisallowAll) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLprivacyValueDisallowAll) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLprivacyValueDisallowUsers struct implement
type TLprivacyValueDisallowUsers struct {
	Data PrivacyRule_Data `json:"data"`
}

func (st *TLprivacyValueDisallowUsers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLprivacyValueDisallowUsers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLprivacyValueDisallowUsers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLprivacyValueDisallowUsers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLprivacyValueDisallowUsers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLprivacyValueDisallowUsers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLprivacyValueAllowChatParticipants struct implement
type TLprivacyValueAllowChatParticipants struct {
	Data PrivacyRule_Data `json:"data"`
}

func (st *TLprivacyValueAllowChatParticipants) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLprivacyValueAllowChatParticipants) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLprivacyValueAllowChatParticipants) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLprivacyValueAllowChatParticipants, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLprivacyValueAllowChatParticipants) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLprivacyValueAllowChatParticipants) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLprivacyValueDisallowChatParticipants struct implement
type TLprivacyValueDisallowChatParticipants struct {
	Data PrivacyRule_Data `json:"data"`
}

func (st *TLprivacyValueDisallowChatParticipants) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLprivacyValueDisallowChatParticipants) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLprivacyValueDisallowChatParticipants) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLprivacyValueDisallowChatParticipants, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLprivacyValueDisallowChatParticipants) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLprivacyValueDisallowChatParticipants) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ExportedMessageLink struct implement
type ExportedMessageLink struct {
	Constructor int32                    `json:"constructor"`
	Data        ExportedMessageLink_Data `json:"data"`
}

func (st *ExportedMessageLink) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ExportedMessageLink) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ExportedMessageLink) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ExportedMessageLink, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ExportedMessageLink) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ExportedMessageLink) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ExportedMessageLink_Data struct implement
type ExportedMessageLink_Data struct {
	Link string `json:"link"`
	Html string `json:"html"`
}

func (st *ExportedMessageLink_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *ExportedMessageLink_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Link, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Html, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ExportedMessageLink_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ExportedMessageLink_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ExportedMessageLink_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Link, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Html, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ExportedMessageLink_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLexportedMessageLink struct implement
type TLexportedMessageLink struct {
	Data ExportedMessageLink_Data `json:"data"`
}

func (st *TLexportedMessageLink) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLexportedMessageLink) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLexportedMessageLink) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLexportedMessageLink, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLexportedMessageLink) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLexportedMessageLink) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Payments_PaymentForm struct implement
type Payments_PaymentForm struct {
	Constructor int32                     `json:"constructor"`
	Data        Payments_PaymentForm_Data `json:"data"`
}

func (st *Payments_PaymentForm) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Payments_PaymentForm) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Payments_PaymentForm) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Payments_PaymentForm, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Payments_PaymentForm) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Payments_PaymentForm) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Payments_PaymentForm_Data struct implement
type Payments_PaymentForm_Data struct {
	Can_save_credentials bool                    `json:"can_save_credentials"`
	Password_missing     bool                    `json:"password_missing"`
	Bot_id               int32                   `json:"bot_id"`
	Invoice              Invoice                 `json:"invoice"`
	Provider_id          int32                   `json:"provider_id"`
	Url                  string                  `json:"url"`
	Native_provider      string                  `json:"native_provider"`
	Native_params        DataJSON                `json:"native_params"`
	Saved_info           PaymentRequestedInfo    `json:"saved_info"`
	Saved_credentials    PaymentSavedCredentials `json:"saved_credentials"`
	Users                []User                  `json:"users"`
}

func (st *Payments_PaymentForm_Data) ResetDefault() {
	st.Invoice.ResetDefault()
	st.Native_params.ResetDefault()
	st.Saved_info.ResetDefault()
	st.Saved_credentials.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Payments_PaymentForm_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Can_save_credentials, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Password_missing, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Bot_id, 2, false)
	if err != nil {
		return err
	}

	err = st.Invoice.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Provider_id, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Url, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Native_provider, 6, false)
	if err != nil {
		return err
	}

	err = st.Native_params.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	err = st.Saved_info.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err = st.Saved_credentials.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(10, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Users[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Payments_PaymentForm_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Payments_PaymentForm_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Payments_PaymentForm_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Can_save_credentials, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Password_missing, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Bot_id, 2)
	if err != nil {
		return err
	}

	err = st.Invoice.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Provider_id, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Url, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Native_provider, 6)
	if err != nil {
		return err
	}

	err = st.Native_params.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	err = st.Saved_info.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = st.Saved_credentials.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 10)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Payments_PaymentForm_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpayments_paymentForm struct implement
type TLpayments_paymentForm struct {
	Data Payments_PaymentForm_Data `json:"data"`
}

func (st *TLpayments_paymentForm) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpayments_paymentForm) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpayments_paymentForm) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpayments_paymentForm, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpayments_paymentForm) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpayments_paymentForm) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TopPeerCategory struct implement
type TopPeerCategory struct {
	Constructor int32                `json:"constructor"`
	Data        TopPeerCategory_Data `json:"data"`
}

func (st *TopPeerCategory) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TopPeerCategory) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TopPeerCategory) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TopPeerCategory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TopPeerCategory) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TopPeerCategory) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TopPeerCategory_Data struct implement
type TopPeerCategory_Data struct {
}

func (st *TopPeerCategory_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TopPeerCategory_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TopPeerCategory_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TopPeerCategory_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TopPeerCategory_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TopPeerCategory_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtopPeerCategoryBotsPM struct implement
type TLtopPeerCategoryBotsPM struct {
	Data TopPeerCategory_Data `json:"data"`
}

func (st *TLtopPeerCategoryBotsPM) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtopPeerCategoryBotsPM) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtopPeerCategoryBotsPM) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtopPeerCategoryBotsPM, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtopPeerCategoryBotsPM) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtopPeerCategoryBotsPM) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtopPeerCategoryBotsInline struct implement
type TLtopPeerCategoryBotsInline struct {
	Data TopPeerCategory_Data `json:"data"`
}

func (st *TLtopPeerCategoryBotsInline) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtopPeerCategoryBotsInline) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtopPeerCategoryBotsInline) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtopPeerCategoryBotsInline, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtopPeerCategoryBotsInline) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtopPeerCategoryBotsInline) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtopPeerCategoryCorrespondents struct implement
type TLtopPeerCategoryCorrespondents struct {
	Data TopPeerCategory_Data `json:"data"`
}

func (st *TLtopPeerCategoryCorrespondents) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtopPeerCategoryCorrespondents) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtopPeerCategoryCorrespondents) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtopPeerCategoryCorrespondents, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtopPeerCategoryCorrespondents) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtopPeerCategoryCorrespondents) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtopPeerCategoryGroups struct implement
type TLtopPeerCategoryGroups struct {
	Data TopPeerCategory_Data `json:"data"`
}

func (st *TLtopPeerCategoryGroups) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtopPeerCategoryGroups) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtopPeerCategoryGroups) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtopPeerCategoryGroups, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtopPeerCategoryGroups) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtopPeerCategoryGroups) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtopPeerCategoryChannels struct implement
type TLtopPeerCategoryChannels struct {
	Data TopPeerCategory_Data `json:"data"`
}

func (st *TLtopPeerCategoryChannels) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtopPeerCategoryChannels) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtopPeerCategoryChannels) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtopPeerCategoryChannels, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtopPeerCategoryChannels) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtopPeerCategoryChannels) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtopPeerCategoryPhoneCalls struct implement
type TLtopPeerCategoryPhoneCalls struct {
	Data TopPeerCategory_Data `json:"data"`
}

func (st *TLtopPeerCategoryPhoneCalls) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtopPeerCategoryPhoneCalls) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtopPeerCategoryPhoneCalls) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtopPeerCategoryPhoneCalls, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtopPeerCategoryPhoneCalls) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtopPeerCategoryPhoneCalls) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtopPeerCategoryForwardUsers struct implement
type TLtopPeerCategoryForwardUsers struct {
	Data TopPeerCategory_Data `json:"data"`
}

func (st *TLtopPeerCategoryForwardUsers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtopPeerCategoryForwardUsers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtopPeerCategoryForwardUsers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtopPeerCategoryForwardUsers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtopPeerCategoryForwardUsers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtopPeerCategoryForwardUsers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtopPeerCategoryForwardChats struct implement
type TLtopPeerCategoryForwardChats struct {
	Data TopPeerCategory_Data `json:"data"`
}

func (st *TLtopPeerCategoryForwardChats) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtopPeerCategoryForwardChats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtopPeerCategoryForwardChats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtopPeerCategoryForwardChats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtopPeerCategoryForwardChats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtopPeerCategoryForwardChats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PageRelatedArticle struct implement
type PageRelatedArticle struct {
	Constructor int32                   `json:"constructor"`
	Data        PageRelatedArticle_Data `json:"data"`
}

func (st *PageRelatedArticle) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PageRelatedArticle) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PageRelatedArticle) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PageRelatedArticle, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PageRelatedArticle) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PageRelatedArticle) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PageRelatedArticle_Data struct implement
type PageRelatedArticle_Data struct {
	Url            string `json:"url"`
	Webpage_id     int64  `json:"webpage_id"`
	Title          string `json:"title"`
	Description    string `json:"description"`
	Photo_id       int64  `json:"photo_id"`
	Author         string `json:"author"`
	Published_date int32  `json:"published_date"`
}

func (st *PageRelatedArticle_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *PageRelatedArticle_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Url, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Webpage_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Description, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Photo_id, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Author, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Published_date, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PageRelatedArticle_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PageRelatedArticle_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PageRelatedArticle_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Url, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Webpage_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Description, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Photo_id, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Author, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Published_date, 6)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PageRelatedArticle_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageRelatedArticle struct implement
type TLpageRelatedArticle struct {
	Data PageRelatedArticle_Data `json:"data"`
}

func (st *TLpageRelatedArticle) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageRelatedArticle) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageRelatedArticle) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageRelatedArticle, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageRelatedArticle) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageRelatedArticle) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_BotCallbackAnswer struct implement
type Messages_BotCallbackAnswer struct {
	Constructor int32                           `json:"constructor"`
	Data        Messages_BotCallbackAnswer_Data `json:"data"`
}

func (st *Messages_BotCallbackAnswer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_BotCallbackAnswer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_BotCallbackAnswer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_BotCallbackAnswer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_BotCallbackAnswer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_BotCallbackAnswer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_BotCallbackAnswer_Data struct implement
type Messages_BotCallbackAnswer_Data struct {
	Alert      bool   `json:"alert"`
	Has_url    bool   `json:"has_url"`
	Native_ui  bool   `json:"native_ui"`
	Message    string `json:"message"`
	Url        string `json:"url"`
	Cache_time int32  `json:"cache_time"`
}

func (st *Messages_BotCallbackAnswer_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_BotCallbackAnswer_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Alert, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Has_url, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Native_ui, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Url, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Cache_time, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_BotCallbackAnswer_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_BotCallbackAnswer_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_BotCallbackAnswer_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Alert, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Has_url, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Native_ui, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Url, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Cache_time, 5)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_BotCallbackAnswer_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_botCallbackAnswer struct implement
type TLmessages_botCallbackAnswer struct {
	Data Messages_BotCallbackAnswer_Data `json:"data"`
}

func (st *TLmessages_botCallbackAnswer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_botCallbackAnswer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_botCallbackAnswer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_botCallbackAnswer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_botCallbackAnswer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_botCallbackAnswer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputStickerSetItem struct implement
type InputStickerSetItem struct {
	Constructor int32                    `json:"constructor"`
	Data        InputStickerSetItem_Data `json:"data"`
}

func (st *InputStickerSetItem) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputStickerSetItem) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputStickerSetItem) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputStickerSetItem, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputStickerSetItem) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputStickerSetItem) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputStickerSetItem_Data struct implement
type InputStickerSetItem_Data struct {
	Document    InputDocument `json:"document"`
	Emoji       string        `json:"emoji"`
	Mask_coords MaskCoords    `json:"mask_coords"`
}

func (st *InputStickerSetItem_Data) ResetDefault() {
	st.Document.ResetDefault()
	st.Mask_coords.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputStickerSetItem_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Document.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Emoji, 1, false)
	if err != nil {
		return err
	}

	err = st.Mask_coords.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputStickerSetItem_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputStickerSetItem_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputStickerSetItem_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Document.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Emoji, 1)
	if err != nil {
		return err
	}

	err = st.Mask_coords.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputStickerSetItem_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputStickerSetItem struct implement
type TLinputStickerSetItem struct {
	Data InputStickerSetItem_Data `json:"data"`
}

func (st *TLinputStickerSetItem) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputStickerSetItem) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputStickerSetItem) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputStickerSetItem, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputStickerSetItem) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputStickerSetItem) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputGeoPoint struct implement
type InputGeoPoint struct {
	Constructor int32              `json:"constructor"`
	Data        InputGeoPoint_Data `json:"data"`
}

func (st *InputGeoPoint) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputGeoPoint) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputGeoPoint) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputGeoPoint, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputGeoPoint) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputGeoPoint) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputGeoPoint_Data struct implement
type InputGeoPoint_Data struct {
	Lat             float64 `json:"lat"`
	Long_key        float64 `json:"long_key"`
	Accuracy_radius int32   `json:"accuracy_radius"`
}

func (st *InputGeoPoint_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputGeoPoint_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_float64(&st.Lat, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Long_key, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Accuracy_radius, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputGeoPoint_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputGeoPoint_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputGeoPoint_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_float64(st.Lat, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Long_key, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Accuracy_radius, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputGeoPoint_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputGeoPointEmpty struct implement
type TLinputGeoPointEmpty struct {
	Data InputGeoPoint_Data `json:"data"`
}

func (st *TLinputGeoPointEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputGeoPointEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputGeoPointEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputGeoPointEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputGeoPointEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputGeoPointEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputGeoPoint struct implement
type TLinputGeoPoint struct {
	Data InputGeoPoint_Data `json:"data"`
}

func (st *TLinputGeoPoint) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputGeoPoint) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputGeoPoint) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputGeoPoint, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputGeoPoint) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputGeoPoint) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Auth_PasswordRecovery struct implement
type Auth_PasswordRecovery struct {
	Constructor int32                      `json:"constructor"`
	Data        Auth_PasswordRecovery_Data `json:"data"`
}

func (st *Auth_PasswordRecovery) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Auth_PasswordRecovery) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Auth_PasswordRecovery) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Auth_PasswordRecovery, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Auth_PasswordRecovery) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Auth_PasswordRecovery) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Auth_PasswordRecovery_Data struct implement
type Auth_PasswordRecovery_Data struct {
	Email_pattern string `json:"email_pattern"`
}

func (st *Auth_PasswordRecovery_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Auth_PasswordRecovery_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Email_pattern, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Auth_PasswordRecovery_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Auth_PasswordRecovery_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Auth_PasswordRecovery_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Email_pattern, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Auth_PasswordRecovery_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_passwordRecovery struct implement
type TLauth_passwordRecovery struct {
	Data Auth_PasswordRecovery_Data `json:"data"`
}

func (st *TLauth_passwordRecovery) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_passwordRecovery) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_passwordRecovery) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_passwordRecovery, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_passwordRecovery) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_passwordRecovery) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// BankCardOpenUrl struct implement
type BankCardOpenUrl struct {
	Constructor int32                `json:"constructor"`
	Data        BankCardOpenUrl_Data `json:"data"`
}

func (st *BankCardOpenUrl) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *BankCardOpenUrl) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *BankCardOpenUrl) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BankCardOpenUrl, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *BankCardOpenUrl) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *BankCardOpenUrl) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// BankCardOpenUrl_Data struct implement
type BankCardOpenUrl_Data struct {
	Url  string `json:"url"`
	Name string `json:"name"`
}

func (st *BankCardOpenUrl_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *BankCardOpenUrl_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Url, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Name, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *BankCardOpenUrl_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BankCardOpenUrl_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *BankCardOpenUrl_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Url, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Name, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *BankCardOpenUrl_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbankCardOpenUrl struct implement
type TLbankCardOpenUrl struct {
	Data BankCardOpenUrl_Data `json:"data"`
}

func (st *TLbankCardOpenUrl) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbankCardOpenUrl) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbankCardOpenUrl) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbankCardOpenUrl, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbankCardOpenUrl) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbankCardOpenUrl) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ContactStatus struct implement
type ContactStatus struct {
	Constructor int32              `json:"constructor"`
	Data        ContactStatus_Data `json:"data"`
}

func (st *ContactStatus) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ContactStatus) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ContactStatus) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ContactStatus, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ContactStatus) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ContactStatus) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ContactStatus_Data struct implement
type ContactStatus_Data struct {
	User_id int32      `json:"user_id"`
	Status  UserStatus `json:"status"`
}

func (st *ContactStatus_Data) ResetDefault() {
	st.Status.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ContactStatus_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = st.Status.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ContactStatus_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ContactStatus_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ContactStatus_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.User_id, 0)
	if err != nil {
		return err
	}

	err = st.Status.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ContactStatus_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontactStatus struct implement
type TLcontactStatus struct {
	Data ContactStatus_Data `json:"data"`
}

func (st *TLcontactStatus) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontactStatus) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontactStatus) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontactStatus, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontactStatus) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontactStatus) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// KeyboardButtonRow struct implement
type KeyboardButtonRow struct {
	Constructor int32                  `json:"constructor"`
	Data        KeyboardButtonRow_Data `json:"data"`
}

func (st *KeyboardButtonRow) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *KeyboardButtonRow) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *KeyboardButtonRow) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require KeyboardButtonRow, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *KeyboardButtonRow) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *KeyboardButtonRow) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// KeyboardButtonRow_Data struct implement
type KeyboardButtonRow_Data struct {
	Buttons []KeyboardButton `json:"buttons"`
}

func (st *KeyboardButtonRow_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *KeyboardButtonRow_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Buttons = make([]KeyboardButton, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Buttons[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *KeyboardButtonRow_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require KeyboardButtonRow_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *KeyboardButtonRow_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Buttons)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Buttons {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *KeyboardButtonRow_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLkeyboardButtonRow struct implement
type TLkeyboardButtonRow struct {
	Data KeyboardButtonRow_Data `json:"data"`
}

func (st *TLkeyboardButtonRow) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLkeyboardButtonRow) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLkeyboardButtonRow) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLkeyboardButtonRow, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLkeyboardButtonRow) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLkeyboardButtonRow) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputFile struct implement
type InputFile struct {
	Constructor int32          `json:"constructor"`
	Data        InputFile_Data `json:"data"`
}

func (st *InputFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputFile_Data struct implement
type InputFile_Data struct {
	Id           int64  `json:"id"`
	Parts        int32  `json:"parts"`
	Name         string `json:"name"`
	Md5_checksum string `json:"md5_checksum"`
}

func (st *InputFile_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputFile_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Parts, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Name, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Md5_checksum, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputFile_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputFile_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputFile_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Parts, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Name, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Md5_checksum, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputFile_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputFile struct implement
type TLinputFile struct {
	Data InputFile_Data `json:"data"`
}

func (st *TLinputFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputFileBig struct implement
type TLinputFileBig struct {
	Data InputFile_Data `json:"data"`
}

func (st *TLinputFileBig) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputFileBig) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputFileBig) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputFileBig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputFileBig) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputFileBig) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PrivacyKey struct implement
type PrivacyKey struct {
	Constructor int32           `json:"constructor"`
	Data        PrivacyKey_Data `json:"data"`
}

func (st *PrivacyKey) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PrivacyKey) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PrivacyKey) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PrivacyKey, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PrivacyKey) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PrivacyKey) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PrivacyKey_Data struct implement
type PrivacyKey_Data struct {
}

func (st *PrivacyKey_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *PrivacyKey_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PrivacyKey_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PrivacyKey_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PrivacyKey_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PrivacyKey_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLprivacyKeyStatusTimestamp struct implement
type TLprivacyKeyStatusTimestamp struct {
	Data PrivacyKey_Data `json:"data"`
}

func (st *TLprivacyKeyStatusTimestamp) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLprivacyKeyStatusTimestamp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLprivacyKeyStatusTimestamp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLprivacyKeyStatusTimestamp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLprivacyKeyStatusTimestamp) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLprivacyKeyStatusTimestamp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLprivacyKeyChatInvite struct implement
type TLprivacyKeyChatInvite struct {
	Data PrivacyKey_Data `json:"data"`
}

func (st *TLprivacyKeyChatInvite) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLprivacyKeyChatInvite) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLprivacyKeyChatInvite) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLprivacyKeyChatInvite, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLprivacyKeyChatInvite) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLprivacyKeyChatInvite) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLprivacyKeyPhoneCall struct implement
type TLprivacyKeyPhoneCall struct {
	Data PrivacyKey_Data `json:"data"`
}

func (st *TLprivacyKeyPhoneCall) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLprivacyKeyPhoneCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLprivacyKeyPhoneCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLprivacyKeyPhoneCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLprivacyKeyPhoneCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLprivacyKeyPhoneCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLprivacyKeyPhoneP2P struct implement
type TLprivacyKeyPhoneP2P struct {
	Data PrivacyKey_Data `json:"data"`
}

func (st *TLprivacyKeyPhoneP2P) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLprivacyKeyPhoneP2P) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLprivacyKeyPhoneP2P) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLprivacyKeyPhoneP2P, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLprivacyKeyPhoneP2P) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLprivacyKeyPhoneP2P) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLprivacyKeyForwards struct implement
type TLprivacyKeyForwards struct {
	Data PrivacyKey_Data `json:"data"`
}

func (st *TLprivacyKeyForwards) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLprivacyKeyForwards) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLprivacyKeyForwards) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLprivacyKeyForwards, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLprivacyKeyForwards) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLprivacyKeyForwards) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLprivacyKeyProfilePhoto struct implement
type TLprivacyKeyProfilePhoto struct {
	Data PrivacyKey_Data `json:"data"`
}

func (st *TLprivacyKeyProfilePhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLprivacyKeyProfilePhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLprivacyKeyProfilePhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLprivacyKeyProfilePhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLprivacyKeyProfilePhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLprivacyKeyProfilePhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLprivacyKeyPhoneNumber struct implement
type TLprivacyKeyPhoneNumber struct {
	Data PrivacyKey_Data `json:"data"`
}

func (st *TLprivacyKeyPhoneNumber) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLprivacyKeyPhoneNumber) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLprivacyKeyPhoneNumber) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLprivacyKeyPhoneNumber, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLprivacyKeyPhoneNumber) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLprivacyKeyPhoneNumber) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLprivacyKeyAddedByPhone struct implement
type TLprivacyKeyAddedByPhone struct {
	Data PrivacyKey_Data `json:"data"`
}

func (st *TLprivacyKeyAddedByPhone) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLprivacyKeyAddedByPhone) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLprivacyKeyAddedByPhone) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLprivacyKeyAddedByPhone, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLprivacyKeyAddedByPhone) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLprivacyKeyAddedByPhone) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// WebDocument struct implement
type WebDocument struct {
	Constructor int32            `json:"constructor"`
	Data        WebDocument_Data `json:"data"`
}

func (st *WebDocument) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *WebDocument) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *WebDocument) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require WebDocument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *WebDocument) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *WebDocument) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// WebDocument_Data struct implement
type WebDocument_Data struct {
	Url         string              `json:"url"`
	Access_hash int64               `json:"access_hash"`
	Size        int32               `json:"size"`
	Mime_type   string              `json:"mime_type"`
	Attributes  []DocumentAttribute `json:"attributes"`
}

func (st *WebDocument_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *WebDocument_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Url, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Size, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Mime_type, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Attributes = make([]DocumentAttribute, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Attributes[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *WebDocument_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require WebDocument_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *WebDocument_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Url, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Size, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Mime_type, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Attributes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Attributes {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *WebDocument_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLwebDocument struct implement
type TLwebDocument struct {
	Data WebDocument_Data `json:"data"`
}

func (st *TLwebDocument) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLwebDocument) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLwebDocument) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLwebDocument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLwebDocument) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLwebDocument) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLwebDocumentNoProxy struct implement
type TLwebDocumentNoProxy struct {
	Data WebDocument_Data `json:"data"`
}

func (st *TLwebDocumentNoProxy) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLwebDocumentNoProxy) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLwebDocumentNoProxy) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLwebDocumentNoProxy, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLwebDocumentNoProxy) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLwebDocumentNoProxy) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_RecentMeUrls struct implement
type Help_RecentMeUrls struct {
	Constructor int32                  `json:"constructor"`
	Data        Help_RecentMeUrls_Data `json:"data"`
}

func (st *Help_RecentMeUrls) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_RecentMeUrls) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_RecentMeUrls) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_RecentMeUrls, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_RecentMeUrls) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_RecentMeUrls) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_RecentMeUrls_Data struct implement
type Help_RecentMeUrls_Data struct {
	Urls  []RecentMeUrl `json:"urls"`
	Chats []Chat        `json:"chats"`
	Users []User        `json:"users"`
}

func (st *Help_RecentMeUrls_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_RecentMeUrls_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Urls = make([]RecentMeUrl, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Urls[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Chats[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Users[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_RecentMeUrls_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_RecentMeUrls_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_RecentMeUrls_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Urls)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Urls {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_RecentMeUrls_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_recentMeUrls struct implement
type TLhelp_recentMeUrls struct {
	Data Help_RecentMeUrls_Data `json:"data"`
}

func (st *TLhelp_recentMeUrls) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_recentMeUrls) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_recentMeUrls) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_recentMeUrls, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_recentMeUrls) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_recentMeUrls) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Payments_ValidatedRequestedInfo struct implement
type Payments_ValidatedRequestedInfo struct {
	Constructor int32                                `json:"constructor"`
	Data        Payments_ValidatedRequestedInfo_Data `json:"data"`
}

func (st *Payments_ValidatedRequestedInfo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Payments_ValidatedRequestedInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Payments_ValidatedRequestedInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Payments_ValidatedRequestedInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Payments_ValidatedRequestedInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Payments_ValidatedRequestedInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Payments_ValidatedRequestedInfo_Data struct implement
type Payments_ValidatedRequestedInfo_Data struct {
	Id               string           `json:"id"`
	Shipping_options []ShippingOption `json:"shipping_options"`
}

func (st *Payments_ValidatedRequestedInfo_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Payments_ValidatedRequestedInfo_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Shipping_options = make([]ShippingOption, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Shipping_options[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Payments_ValidatedRequestedInfo_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Payments_ValidatedRequestedInfo_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Payments_ValidatedRequestedInfo_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Shipping_options)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Shipping_options {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Payments_ValidatedRequestedInfo_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpayments_validatedRequestedInfo struct implement
type TLpayments_validatedRequestedInfo struct {
	Data Payments_ValidatedRequestedInfo_Data `json:"data"`
}

func (st *TLpayments_validatedRequestedInfo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpayments_validatedRequestedInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpayments_validatedRequestedInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpayments_validatedRequestedInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpayments_validatedRequestedInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpayments_validatedRequestedInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageReplyHeader struct implement
type MessageReplyHeader struct {
	Constructor int32                   `json:"constructor"`
	Data        MessageReplyHeader_Data `json:"data"`
}

func (st *MessageReplyHeader) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageReplyHeader) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageReplyHeader) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageReplyHeader, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageReplyHeader) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageReplyHeader) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageReplyHeader_Data struct implement
type MessageReplyHeader_Data struct {
	Reply_to_msg_id  int32 `json:"reply_to_msg_id"`
	Reply_to_peer_id Peer  `json:"reply_to_peer_id"`
	Reply_to_top_id  int32 `json:"reply_to_top_id"`
}

func (st *MessageReplyHeader_Data) ResetDefault() {
	st.Reply_to_peer_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageReplyHeader_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Reply_to_msg_id, 0, false)
	if err != nil {
		return err
	}

	err = st.Reply_to_peer_id.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Reply_to_top_id, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageReplyHeader_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageReplyHeader_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageReplyHeader_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Reply_to_msg_id, 0)
	if err != nil {
		return err
	}

	err = st.Reply_to_peer_id.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Reply_to_top_id, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageReplyHeader_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageReplyHeader struct implement
type TLmessageReplyHeader struct {
	Data MessageReplyHeader_Data `json:"data"`
}

func (st *TLmessageReplyHeader) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageReplyHeader) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageReplyHeader) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageReplyHeader, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageReplyHeader) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageReplyHeader) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_CountryCode struct implement
type Help_CountryCode struct {
	Constructor int32                 `json:"constructor"`
	Data        Help_CountryCode_Data `json:"data"`
}

func (st *Help_CountryCode) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_CountryCode) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_CountryCode) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_CountryCode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_CountryCode) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_CountryCode) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_CountryCode_Data struct implement
type Help_CountryCode_Data struct {
	Country_code string   `json:"country_code"`
	Prefixes     []string `json:"prefixes"`
	Patterns     []string `json:"patterns"`
}

func (st *Help_CountryCode_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_CountryCode_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Country_code, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Prefixes = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_string(&st.Prefixes[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Patterns = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_string(&st.Patterns[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_CountryCode_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_CountryCode_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_CountryCode_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Country_code, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Prefixes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Prefixes {

		err = _os.Write_string(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Patterns)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Patterns {

		err = _os.Write_string(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_CountryCode_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_countryCode struct implement
type TLhelp_countryCode struct {
	Data Help_CountryCode_Data `json:"data"`
}

func (st *TLhelp_countryCode) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_countryCode) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_countryCode) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_countryCode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_countryCode) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_countryCode) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChatOnlines struct implement
type ChatOnlines struct {
	Constructor int32            `json:"constructor"`
	Data        ChatOnlines_Data `json:"data"`
}

func (st *ChatOnlines) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChatOnlines) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChatOnlines) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChatOnlines, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChatOnlines) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChatOnlines) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChatOnlines_Data struct implement
type ChatOnlines_Data struct {
	Onlines int32 `json:"onlines"`
}

func (st *ChatOnlines_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *ChatOnlines_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Onlines, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChatOnlines_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChatOnlines_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChatOnlines_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Onlines, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChatOnlines_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatOnlines struct implement
type TLchatOnlines struct {
	Data ChatOnlines_Data `json:"data"`
}

func (st *TLchatOnlines) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatOnlines) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatOnlines) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatOnlines, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatOnlines) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatOnlines) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// User struct implement
type User struct {
	Constructor int32     `json:"constructor"`
	Data        User_Data `json:"data"`
}

func (st *User) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *User) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *User) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require User, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *User) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *User) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// User_Data struct implement
type User_Data struct {
	Id                     int32               `json:"id"`
	Self                   bool                `json:"self"`
	Contact                bool                `json:"contact"`
	Mutual_contact         bool                `json:"mutual_contact"`
	Deleted                bool                `json:"deleted"`
	Bot                    bool                `json:"bot"`
	Bot_chat_history       bool                `json:"bot_chat_history"`
	Bot_nochats            bool                `json:"bot_nochats"`
	Verified               bool                `json:"verified"`
	Restricted             bool                `json:"restricted"`
	Min                    bool                `json:"min"`
	Bot_inline_geo         bool                `json:"bot_inline_geo"`
	Support                bool                `json:"support"`
	Scam                   bool                `json:"scam"`
	Apply_min_photo        bool                `json:"apply_min_photo"`
	Access_hash            int64               `json:"access_hash"`
	First_name             string              `json:"first_name"`
	Last_name              string              `json:"last_name"`
	Username               string              `json:"username"`
	Phone                  string              `json:"phone"`
	Photo                  UserProfilePhoto    `json:"photo"`
	Status                 UserStatus          `json:"status"`
	Bot_info_version       int32               `json:"bot_info_version"`
	Restriction_reason     []RestrictionReason `json:"restriction_reason"`
	Bot_inline_placeholder string              `json:"bot_inline_placeholder"`
	Lang_code              string              `json:"lang_code"`
}

func (st *User_Data) ResetDefault() {
	st.Photo.ResetDefault()
	st.Status.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *User_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Self, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Contact, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Mutual_contact, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Deleted, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Bot, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Bot_chat_history, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Bot_nochats, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Verified, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Restricted, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Min, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Bot_inline_geo, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Support, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Scam, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Apply_min_photo, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.First_name, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Last_name, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Username, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone, 19, false)
	if err != nil {
		return err
	}

	err = st.Photo.ReadBlock(_is, 20, false)
	if err != nil {
		return err
	}

	err = st.Status.ReadBlock(_is, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Bot_info_version, 22, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(23, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Restriction_reason = make([]RestrictionReason, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Restriction_reason[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Bot_inline_placeholder, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Lang_code, 25, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *User_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require User_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *User_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Self, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Contact, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Mutual_contact, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Deleted, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Bot, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Bot_chat_history, 6)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Bot_nochats, 7)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Verified, 8)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Restricted, 9)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Min, 10)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Bot_inline_geo, 11)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Support, 12)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Scam, 13)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Apply_min_photo, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 15)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.First_name, 16)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Last_name, 17)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Username, 18)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone, 19)
	if err != nil {
		return err
	}

	err = st.Photo.WriteBlock(_os, 20)
	if err != nil {
		return err
	}

	err = st.Status.WriteBlock(_os, 21)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Bot_info_version, 22)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 23)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Restriction_reason)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Restriction_reason {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Bot_inline_placeholder, 24)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Lang_code, 25)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *User_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLuserEmpty struct implement
type TLuserEmpty struct {
	Data User_Data `json:"data"`
}

func (st *TLuserEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLuserEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLuserEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLuserEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLuserEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLuserEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLuser struct implement
type TLuser struct {
	Data User_Data `json:"data"`
}

func (st *TLuser) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLuser) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLuser) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLuser, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLuser) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLuser) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_TermsOfServiceUpdate struct implement
type Help_TermsOfServiceUpdate struct {
	Constructor int32                          `json:"constructor"`
	Data        Help_TermsOfServiceUpdate_Data `json:"data"`
}

func (st *Help_TermsOfServiceUpdate) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_TermsOfServiceUpdate) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_TermsOfServiceUpdate) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_TermsOfServiceUpdate, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_TermsOfServiceUpdate) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_TermsOfServiceUpdate) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_TermsOfServiceUpdate_Data struct implement
type Help_TermsOfServiceUpdate_Data struct {
	Expires          int32               `json:"expires"`
	Terms_of_service Help_TermsOfService `json:"terms_of_service"`
}

func (st *Help_TermsOfServiceUpdate_Data) ResetDefault() {
	st.Terms_of_service.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_TermsOfServiceUpdate_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Expires, 0, false)
	if err != nil {
		return err
	}

	err = st.Terms_of_service.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_TermsOfServiceUpdate_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_TermsOfServiceUpdate_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_TermsOfServiceUpdate_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Expires, 0)
	if err != nil {
		return err
	}

	err = st.Terms_of_service.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_TermsOfServiceUpdate_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_termsOfServiceUpdateEmpty struct implement
type TLhelp_termsOfServiceUpdateEmpty struct {
	Data Help_TermsOfServiceUpdate_Data `json:"data"`
}

func (st *TLhelp_termsOfServiceUpdateEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_termsOfServiceUpdateEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_termsOfServiceUpdateEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_termsOfServiceUpdateEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_termsOfServiceUpdateEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_termsOfServiceUpdateEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_termsOfServiceUpdate struct implement
type TLhelp_termsOfServiceUpdate struct {
	Data Help_TermsOfServiceUpdate_Data `json:"data"`
}

func (st *TLhelp_termsOfServiceUpdate) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_termsOfServiceUpdate) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_termsOfServiceUpdate) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_termsOfServiceUpdate, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_termsOfServiceUpdate) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_termsOfServiceUpdate) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// FileLocation struct implement
type FileLocation struct {
	Constructor int32             `json:"constructor"`
	Data        FileLocation_Data `json:"data"`
}

func (st *FileLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *FileLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *FileLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require FileLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *FileLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *FileLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// FileLocation_Data struct implement
type FileLocation_Data struct {
	Volume_id int64 `json:"volume_id"`
	Local_id  int32 `json:"local_id"`
}

func (st *FileLocation_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *FileLocation_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Volume_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Local_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *FileLocation_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require FileLocation_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *FileLocation_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Volume_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Local_id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *FileLocation_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLfileLocationToBeDeprecated struct implement
type TLfileLocationToBeDeprecated struct {
	Data FileLocation_Data `json:"data"`
}

func (st *TLfileLocationToBeDeprecated) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLfileLocationToBeDeprecated) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLfileLocationToBeDeprecated) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLfileLocationToBeDeprecated, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLfileLocationToBeDeprecated) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLfileLocationToBeDeprecated) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_SearchCounter struct implement
type Messages_SearchCounter struct {
	Constructor int32                       `json:"constructor"`
	Data        Messages_SearchCounter_Data `json:"data"`
}

func (st *Messages_SearchCounter) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_SearchCounter) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_SearchCounter) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_SearchCounter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_SearchCounter) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_SearchCounter) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_SearchCounter_Data struct implement
type Messages_SearchCounter_Data struct {
	Inexact bool           `json:"inexact"`
	Filter  MessagesFilter `json:"filter"`
	Count   int32          `json:"count"`
}

func (st *Messages_SearchCounter_Data) ResetDefault() {
	st.Filter.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_SearchCounter_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Inexact, 0, false)
	if err != nil {
		return err
	}

	err = st.Filter.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Count, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_SearchCounter_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_SearchCounter_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_SearchCounter_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Inexact, 0)
	if err != nil {
		return err
	}

	err = st.Filter.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Count, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_SearchCounter_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_searchCounter struct implement
type TLmessages_searchCounter struct {
	Data Messages_SearchCounter_Data `json:"data"`
}

func (st *TLmessages_searchCounter) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_searchCounter) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_searchCounter) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_searchCounter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_searchCounter) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_searchCounter) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PageListItem struct implement
type PageListItem struct {
	Constructor int32             `json:"constructor"`
	Data        PageListItem_Data `json:"data"`
}

func (st *PageListItem) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PageListItem) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PageListItem) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PageListItem, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PageListItem) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PageListItem) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PageListItem_Data struct implement
type PageListItem_Data struct {
	Text   RichText    `json:"text"`
	Blocks []PageBlock `json:"blocks"`
}

func (st *PageListItem_Data) ResetDefault() {
	st.Text.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PageListItem_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Text.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Blocks = make([]PageBlock, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Blocks[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PageListItem_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PageListItem_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PageListItem_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Text.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Blocks)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Blocks {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PageListItem_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageListItemText struct implement
type TLpageListItemText struct {
	Data PageListItem_Data `json:"data"`
}

func (st *TLpageListItemText) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageListItemText) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageListItemText) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageListItemText, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageListItemText) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageListItemText) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageListItemBlocks struct implement
type TLpageListItemBlocks struct {
	Data PageListItem_Data `json:"data"`
}

func (st *TLpageListItemBlocks) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageListItemBlocks) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageListItemBlocks) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageListItemBlocks, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageListItemBlocks) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageListItemBlocks) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SendMessageAction struct implement
type SendMessageAction struct {
	Constructor int32                  `json:"constructor"`
	Data        SendMessageAction_Data `json:"data"`
}

func (st *SendMessageAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SendMessageAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SendMessageAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SendMessageAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SendMessageAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SendMessageAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SendMessageAction_Data struct implement
type SendMessageAction_Data struct {
	Progress int32 `json:"progress"`
}

func (st *SendMessageAction_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *SendMessageAction_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Progress, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SendMessageAction_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SendMessageAction_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SendMessageAction_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Progress, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SendMessageAction_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsendMessageTypingAction struct implement
type TLsendMessageTypingAction struct {
	Data SendMessageAction_Data `json:"data"`
}

func (st *TLsendMessageTypingAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsendMessageTypingAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsendMessageTypingAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsendMessageTypingAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsendMessageTypingAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsendMessageTypingAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsendMessageCancelAction struct implement
type TLsendMessageCancelAction struct {
	Data SendMessageAction_Data `json:"data"`
}

func (st *TLsendMessageCancelAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsendMessageCancelAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsendMessageCancelAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsendMessageCancelAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsendMessageCancelAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsendMessageCancelAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsendMessageRecordVideoAction struct implement
type TLsendMessageRecordVideoAction struct {
	Data SendMessageAction_Data `json:"data"`
}

func (st *TLsendMessageRecordVideoAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsendMessageRecordVideoAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsendMessageRecordVideoAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsendMessageRecordVideoAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsendMessageRecordVideoAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsendMessageRecordVideoAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsendMessageUploadVideoAction struct implement
type TLsendMessageUploadVideoAction struct {
	Data SendMessageAction_Data `json:"data"`
}

func (st *TLsendMessageUploadVideoAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsendMessageUploadVideoAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsendMessageUploadVideoAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsendMessageUploadVideoAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsendMessageUploadVideoAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsendMessageUploadVideoAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsendMessageRecordAudioAction struct implement
type TLsendMessageRecordAudioAction struct {
	Data SendMessageAction_Data `json:"data"`
}

func (st *TLsendMessageRecordAudioAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsendMessageRecordAudioAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsendMessageRecordAudioAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsendMessageRecordAudioAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsendMessageRecordAudioAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsendMessageRecordAudioAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsendMessageUploadAudioAction struct implement
type TLsendMessageUploadAudioAction struct {
	Data SendMessageAction_Data `json:"data"`
}

func (st *TLsendMessageUploadAudioAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsendMessageUploadAudioAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsendMessageUploadAudioAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsendMessageUploadAudioAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsendMessageUploadAudioAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsendMessageUploadAudioAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsendMessageUploadPhotoAction struct implement
type TLsendMessageUploadPhotoAction struct {
	Data SendMessageAction_Data `json:"data"`
}

func (st *TLsendMessageUploadPhotoAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsendMessageUploadPhotoAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsendMessageUploadPhotoAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsendMessageUploadPhotoAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsendMessageUploadPhotoAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsendMessageUploadPhotoAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsendMessageUploadDocumentAction struct implement
type TLsendMessageUploadDocumentAction struct {
	Data SendMessageAction_Data `json:"data"`
}

func (st *TLsendMessageUploadDocumentAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsendMessageUploadDocumentAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsendMessageUploadDocumentAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsendMessageUploadDocumentAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsendMessageUploadDocumentAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsendMessageUploadDocumentAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsendMessageGeoLocationAction struct implement
type TLsendMessageGeoLocationAction struct {
	Data SendMessageAction_Data `json:"data"`
}

func (st *TLsendMessageGeoLocationAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsendMessageGeoLocationAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsendMessageGeoLocationAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsendMessageGeoLocationAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsendMessageGeoLocationAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsendMessageGeoLocationAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsendMessageChooseContactAction struct implement
type TLsendMessageChooseContactAction struct {
	Data SendMessageAction_Data `json:"data"`
}

func (st *TLsendMessageChooseContactAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsendMessageChooseContactAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsendMessageChooseContactAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsendMessageChooseContactAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsendMessageChooseContactAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsendMessageChooseContactAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsendMessageGamePlayAction struct implement
type TLsendMessageGamePlayAction struct {
	Data SendMessageAction_Data `json:"data"`
}

func (st *TLsendMessageGamePlayAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsendMessageGamePlayAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsendMessageGamePlayAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsendMessageGamePlayAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsendMessageGamePlayAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsendMessageGamePlayAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsendMessageRecordRoundAction struct implement
type TLsendMessageRecordRoundAction struct {
	Data SendMessageAction_Data `json:"data"`
}

func (st *TLsendMessageRecordRoundAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsendMessageRecordRoundAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsendMessageRecordRoundAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsendMessageRecordRoundAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsendMessageRecordRoundAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsendMessageRecordRoundAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsendMessageUploadRoundAction struct implement
type TLsendMessageUploadRoundAction struct {
	Data SendMessageAction_Data `json:"data"`
}

func (st *TLsendMessageUploadRoundAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsendMessageUploadRoundAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsendMessageUploadRoundAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsendMessageUploadRoundAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsendMessageUploadRoundAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsendMessageUploadRoundAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountDaysTTL struct implement
type AccountDaysTTL struct {
	Constructor int32               `json:"constructor"`
	Data        AccountDaysTTL_Data `json:"data"`
}

func (st *AccountDaysTTL) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *AccountDaysTTL) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *AccountDaysTTL) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountDaysTTL, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *AccountDaysTTL) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *AccountDaysTTL) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountDaysTTL_Data struct implement
type AccountDaysTTL_Data struct {
	Days int32 `json:"days"`
}

func (st *AccountDaysTTL_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *AccountDaysTTL_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Days, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *AccountDaysTTL_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountDaysTTL_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *AccountDaysTTL_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Days, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *AccountDaysTTL_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccountDaysTTL struct implement
type TLaccountDaysTTL struct {
	Data AccountDaysTTL_Data `json:"data"`
}

func (st *TLaccountDaysTTL) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccountDaysTTL) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccountDaysTTL) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccountDaysTTL, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccountDaysTTL) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccountDaysTTL) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Contact struct implement
type Contact struct {
	Constructor int32        `json:"constructor"`
	Data        Contact_Data `json:"data"`
}

func (st *Contact) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Contact) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Contact) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Contact, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Contact) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Contact) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Contact_Data struct implement
type Contact_Data struct {
	User_id int32 `json:"user_id"`
	Mutual  Bool  `json:"mutual"`
}

func (st *Contact_Data) ResetDefault() {
	st.Mutual.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Contact_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = st.Mutual.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Contact_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Contact_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Contact_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.User_id, 0)
	if err != nil {
		return err
	}

	err = st.Mutual.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Contact_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontact struct implement
type TLcontact struct {
	Data Contact_Data `json:"data"`
}

func (st *TLcontact) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontact) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontact) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontact, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontact) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontact) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_ArchivedStickers struct implement
type Messages_ArchivedStickers struct {
	Constructor int32                          `json:"constructor"`
	Data        Messages_ArchivedStickers_Data `json:"data"`
}

func (st *Messages_ArchivedStickers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_ArchivedStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_ArchivedStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_ArchivedStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_ArchivedStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_ArchivedStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_ArchivedStickers_Data struct implement
type Messages_ArchivedStickers_Data struct {
	Count int32               `json:"count"`
	Sets  []StickerSetCovered `json:"sets"`
}

func (st *Messages_ArchivedStickers_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_ArchivedStickers_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Count, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Sets = make([]StickerSetCovered, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Sets[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_ArchivedStickers_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_ArchivedStickers_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_ArchivedStickers_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Count, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Sets)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Sets {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_ArchivedStickers_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_archivedStickers struct implement
type TLmessages_archivedStickers struct {
	Data Messages_ArchivedStickers_Data `json:"data"`
}

func (st *TLmessages_archivedStickers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_archivedStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_archivedStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_archivedStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_archivedStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_archivedStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PageTableCell struct implement
type PageTableCell struct {
	Constructor int32              `json:"constructor"`
	Data        PageTableCell_Data `json:"data"`
}

func (st *PageTableCell) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PageTableCell) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PageTableCell) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PageTableCell, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PageTableCell) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PageTableCell) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PageTableCell_Data struct implement
type PageTableCell_Data struct {
	Header        bool     `json:"header"`
	Align_center  bool     `json:"align_center"`
	Align_right   bool     `json:"align_right"`
	Valign_middle bool     `json:"valign_middle"`
	Valign_bottom bool     `json:"valign_bottom"`
	Text          RichText `json:"text"`
	Colspan       int32    `json:"colspan"`
	Rowspan       int32    `json:"rowspan"`
}

func (st *PageTableCell_Data) ResetDefault() {
	st.Text.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PageTableCell_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Header, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Align_center, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Align_right, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Valign_middle, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Valign_bottom, 4, false)
	if err != nil {
		return err
	}

	err = st.Text.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Colspan, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Rowspan, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PageTableCell_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PageTableCell_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PageTableCell_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Header, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Align_center, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Align_right, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Valign_middle, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Valign_bottom, 4)
	if err != nil {
		return err
	}

	err = st.Text.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Colspan, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Rowspan, 7)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PageTableCell_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageTableCell struct implement
type TLpageTableCell struct {
	Data PageTableCell_Data `json:"data"`
}

func (st *TLpageTableCell) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageTableCell) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageTableCell) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageTableCell, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageTableCell) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageTableCell) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_Takeout struct implement
type Account_Takeout struct {
	Constructor int32                `json:"constructor"`
	Data        Account_Takeout_Data `json:"data"`
}

func (st *Account_Takeout) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_Takeout) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_Takeout) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_Takeout, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_Takeout) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_Takeout) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_Takeout_Data struct implement
type Account_Takeout_Data struct {
	Id int64 `json:"id"`
}

func (st *Account_Takeout_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_Takeout_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_Takeout_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_Takeout_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_Takeout_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_Takeout_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_takeout struct implement
type TLaccount_takeout struct {
	Data Account_Takeout_Data `json:"data"`
}

func (st *TLaccount_takeout) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_takeout) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_takeout) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_takeout, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_takeout) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_takeout) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Payments_PaymentReceipt struct implement
type Payments_PaymentReceipt struct {
	Constructor int32                        `json:"constructor"`
	Data        Payments_PaymentReceipt_Data `json:"data"`
}

func (st *Payments_PaymentReceipt) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Payments_PaymentReceipt) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Payments_PaymentReceipt) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Payments_PaymentReceipt, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Payments_PaymentReceipt) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Payments_PaymentReceipt) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Payments_PaymentReceipt_Data struct implement
type Payments_PaymentReceipt_Data struct {
	Date              int32                `json:"date"`
	Bot_id            int32                `json:"bot_id"`
	Invoice           Invoice              `json:"invoice"`
	Provider_id       int32                `json:"provider_id"`
	Info              PaymentRequestedInfo `json:"info"`
	Shipping          ShippingOption       `json:"shipping"`
	Currency          string               `json:"currency"`
	Total_amount      int64                `json:"total_amount"`
	Credentials_title string               `json:"credentials_title"`
	Users             []User               `json:"users"`
}

func (st *Payments_PaymentReceipt_Data) ResetDefault() {
	st.Invoice.ResetDefault()
	st.Info.ResetDefault()
	st.Shipping.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Payments_PaymentReceipt_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Date, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Bot_id, 1, false)
	if err != nil {
		return err
	}

	err = st.Invoice.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Provider_id, 3, false)
	if err != nil {
		return err
	}

	err = st.Info.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = st.Shipping.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Currency, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Total_amount, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Credentials_title, 8, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(9, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Users[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Payments_PaymentReceipt_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Payments_PaymentReceipt_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Payments_PaymentReceipt_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Date, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Bot_id, 1)
	if err != nil {
		return err
	}

	err = st.Invoice.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Provider_id, 3)
	if err != nil {
		return err
	}

	err = st.Info.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = st.Shipping.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Currency, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Total_amount, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Credentials_title, 8)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Payments_PaymentReceipt_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpayments_paymentReceipt struct implement
type TLpayments_paymentReceipt struct {
	Data Payments_PaymentReceipt_Data `json:"data"`
}

func (st *TLpayments_paymentReceipt) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpayments_paymentReceipt) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpayments_paymentReceipt) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpayments_paymentReceipt, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpayments_paymentReceipt) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpayments_paymentReceipt) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TopPeer struct implement
type TopPeer struct {
	Constructor int32        `json:"constructor"`
	Data        TopPeer_Data `json:"data"`
}

func (st *TopPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TopPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TopPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TopPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TopPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TopPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TopPeer_Data struct implement
type TopPeer_Data struct {
	Peer   Peer    `json:"peer"`
	Rating float64 `json:"rating"`
}

func (st *TopPeer_Data) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TopPeer_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Rating, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TopPeer_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TopPeer_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TopPeer_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Rating, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TopPeer_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtopPeer struct implement
type TLtopPeer struct {
	Data TopPeer_Data `json:"data"`
}

func (st *TLtopPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtopPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtopPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtopPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtopPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtopPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Update struct implement
type Update struct {
	Constructor int32       `json:"constructor"`
	Data        Update_Data `json:"data"`
}

func (st *Update) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Update) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Update) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Update, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Update) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Update) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Update_Data struct implement
type Update_Data struct {
	Message               Message                 `json:"message"`
	Pts                   int32                   `json:"pts"`
	Pts_count             int32                   `json:"pts_count"`
	Id                    int32                   `json:"id"`
	Random_id             int64                   `json:"random_id"`
	Messages              []int32                 `json:"messages"`
	User_id               int32                   `json:"user_id"`
	Action                SendMessageAction       `json:"action"`
	Chat_id               int32                   `json:"chat_id"`
	Participants          ChatParticipants        `json:"participants"`
	Status                UserStatus              `json:"status"`
	First_name            string                  `json:"first_name"`
	Last_name             string                  `json:"last_name"`
	Username              string                  `json:"username"`
	Date                  int32                   `json:"date"`
	Photo                 UserProfilePhoto        `json:"photo"`
	Previous              Bool                    `json:"previous"`
	Message_18            EncryptedMessage        `json:"message_18"`
	Qts                   int32                   `json:"qts"`
	Chat                  EncryptedChat           `json:"chat"`
	Max_date              int32                   `json:"max_date"`
	Inviter_id            int32                   `json:"inviter_id"`
	Version               int32                   `json:"version"`
	Dc_options            []DcOption              `json:"dc_options"`
	Peer                  NotifyPeer              `json:"peer"`
	Notify_settings       PeerNotifySettings      `json:"notify_settings"`
	Popup                 bool                    `json:"popup"`
	Inbox_date            int32                   `json:"inbox_date"`
	Type                  string                  `json:"type"`
	Message_30            string                  `json:"message_30"`
	Media                 MessageMedia            `json:"media"`
	Entities              []MessageEntity         `json:"entities"`
	Key_key               PrivacyKey              `json:"key_key"`
	Rules                 []PrivacyRule           `json:"rules"`
	Phone                 string                  `json:"phone"`
	Folder_id             int32                   `json:"folder_id"`
	Peer_37               Peer                    `json:"peer_37"`
	Max_id                int32                   `json:"max_id"`
	Still_unread_count    int32                   `json:"still_unread_count"`
	Webpage               WebPage                 `json:"webpage"`
	Channel_id            int32                   `json:"channel_id"`
	Views                 int32                   `json:"views"`
	Is_admin              Bool                    `json:"is_admin"`
	Stickerset            Messages_StickerSet     `json:"stickerset"`
	Masks                 bool                    `json:"masks"`
	Order                 []int64                 `json:"order"`
	Query_id              int64                   `json:"query_id"`
	Query                 string                  `json:"query"`
	Geo                   GeoPoint                `json:"geo"`
	Offset                string                  `json:"offset"`
	Id_51                 string                  `json:"id_51"`
	Msg_id                InputBotInlineMessageID `json:"msg_id"`
	Msg_id_53             int32                   `json:"msg_id_53"`
	Chat_instance         int64                   `json:"chat_instance"`
	Data                  []uint8                 `json:"data"`
	Game_short_name       string                  `json:"game_short_name"`
	Draft                 DraftMessage            `json:"draft"`
	Pinned                bool                    `json:"pinned"`
	Peer_59               DialogPeer              `json:"peer_59"`
	Order_60              []DialogPeer            `json:"order_60"`
	Data_61               DataJSON                `json:"data_61"`
	Timeout               int32                   `json:"timeout"`
	Payload               []uint8                 `json:"payload"`
	Shipping_address      PostAddress             `json:"shipping_address"`
	Info                  PaymentRequestedInfo    `json:"info"`
	Shipping_option_id    string                  `json:"shipping_option_id"`
	Currency              string                  `json:"currency"`
	Total_amount          int64                   `json:"total_amount"`
	Phone_call            PhoneCall               `json:"phone_call"`
	Lang_code             string                  `json:"lang_code"`
	Difference            LangPackDifference      `json:"difference"`
	Available_min_id      int32                   `json:"available_min_id"`
	Unread                bool                    `json:"unread"`
	Poll_id               int64                   `json:"poll_id"`
	Poll                  Poll                    `json:"poll"`
	Results               PollResults             `json:"results"`
	Default_banned_rights ChatBannedRights        `json:"default_banned_rights"`
	Folder_peers          []FolderPeer            `json:"folder_peers"`
	Settings              PeerSettings            `json:"settings"`
	Peers                 []PeerLocated           `json:"peers"`
	Theme                 Theme                   `json:"theme"`
	Options               [][]uint8               `json:"options"`
	Filter                DialogFilter            `json:"filter"`
	Order_84              []int32                 `json:"order_84"`
	Phone_call_id         int64                   `json:"phone_call_id"`
	Prev_participant      ChannelParticipant      `json:"prev_participant"`
	New_participant       ChannelParticipant      `json:"new_participant"`
	Forwards              int32                   `json:"forwards"`
	Top_msg_id            int32                   `json:"top_msg_id"`
	Read_max_id           int32                   `json:"read_max_id"`
	Broadcast_id          int32                   `json:"broadcast_id"`
	Broadcast_post        int32                   `json:"broadcast_post"`
	Peer_id               Peer                    `json:"peer_id"`
	Blocked               Bool                    `json:"blocked"`
}

func (st *Update_Data) ResetDefault() {
	st.Message.ResetDefault()
	st.Action.ResetDefault()
	st.Participants.ResetDefault()
	st.Status.ResetDefault()
	st.Photo.ResetDefault()
	st.Previous.ResetDefault()
	st.Message_18.ResetDefault()
	st.Chat.ResetDefault()
	st.Peer.ResetDefault()
	st.Notify_settings.ResetDefault()
	st.Media.ResetDefault()
	st.Key_key.ResetDefault()
	st.Peer_37.ResetDefault()
	st.Webpage.ResetDefault()
	st.Is_admin.ResetDefault()
	st.Stickerset.ResetDefault()
	st.Geo.ResetDefault()
	st.Msg_id.ResetDefault()
	st.Draft.ResetDefault()
	st.Peer_59.ResetDefault()
	st.Data_61.ResetDefault()
	st.Shipping_address.ResetDefault()
	st.Info.ResetDefault()
	st.Phone_call.ResetDefault()
	st.Difference.ResetDefault()
	st.Poll.ResetDefault()
	st.Results.ResetDefault()
	st.Default_banned_rights.ResetDefault()
	st.Settings.ResetDefault()
	st.Theme.ResetDefault()
	st.Filter.ResetDefault()
	st.Prev_participant.ResetDefault()
	st.New_participant.ResetDefault()
	st.Peer_id.ResetDefault()
	st.Blocked.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Update_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Message.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Pts, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Pts_count, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Id, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Random_id, 4, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Messages = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Messages[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.User_id, 6, false)
	if err != nil {
		return err
	}

	err = st.Action.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Chat_id, 8, false)
	if err != nil {
		return err
	}

	err = st.Participants.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err = st.Status.ReadBlock(_is, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.First_name, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Last_name, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Username, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 14, false)
	if err != nil {
		return err
	}

	err = st.Photo.ReadBlock(_is, 15, false)
	if err != nil {
		return err
	}

	err = st.Previous.ReadBlock(_is, 16, false)
	if err != nil {
		return err
	}

	err = st.Message_18.ReadBlock(_is, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Qts, 18, false)
	if err != nil {
		return err
	}

	err = st.Chat.ReadBlock(_is, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_date, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Inviter_id, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Version, 22, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(23, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Dc_options = make([]DcOption, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Dc_options[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Peer.ReadBlock(_is, 24, false)
	if err != nil {
		return err
	}

	err = st.Notify_settings.ReadBlock(_is, 25, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Popup, 26, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Inbox_date, 27, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Type, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message_30, 29, false)
	if err != nil {
		return err
	}

	err = st.Media.ReadBlock(_is, 30, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(31, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Entities[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Key_key.ReadBlock(_is, 32, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(33, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Rules = make([]PrivacyRule, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Rules[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Phone, 34, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Folder_id, 35, false)
	if err != nil {
		return err
	}

	err = st.Peer_37.ReadBlock(_is, 36, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_id, 37, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Still_unread_count, 38, false)
	if err != nil {
		return err
	}

	err = st.Webpage.ReadBlock(_is, 39, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Channel_id, 40, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Views, 41, false)
	if err != nil {
		return err
	}

	err = st.Is_admin.ReadBlock(_is, 42, false)
	if err != nil {
		return err
	}

	err = st.Stickerset.ReadBlock(_is, 43, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Masks, 44, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(45, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Order = make([]int64, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = _is.Read_int64(&st.Order[i4], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int64(&st.Query_id, 46, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Query, 47, false)
	if err != nil {
		return err
	}

	err = st.Geo.ReadBlock(_is, 48, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Offset, 49, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Id_51, 50, false)
	if err != nil {
		return err
	}

	err = st.Msg_id.ReadBlock(_is, 51, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Msg_id_53, 52, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Chat_instance, 53, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(54, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Data = make([]uint8, length)
			for i5, e5 := int32(0), length; i5 < e5; i5++ {

				err = _is.Read_uint8(&st.Data[i5], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Data, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Game_short_name, 55, false)
	if err != nil {
		return err
	}

	err = st.Draft.ReadBlock(_is, 56, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Pinned, 57, false)
	if err != nil {
		return err
	}

	err = st.Peer_59.ReadBlock(_is, 58, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(59, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Order_60 = make([]DialogPeer, length)
			for i6, e6 := int32(0), length; i6 < e6; i6++ {

				err = st.Order_60[i6].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Data_61.ReadBlock(_is, 60, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Timeout, 61, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(62, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Payload = make([]uint8, length)
			for i7, e7 := int32(0), length; i7 < e7; i7++ {

				err = _is.Read_uint8(&st.Payload[i7], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Payload, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Shipping_address.ReadBlock(_is, 63, false)
	if err != nil {
		return err
	}

	err = st.Info.ReadBlock(_is, 64, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Shipping_option_id, 65, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Currency, 66, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Total_amount, 67, false)
	if err != nil {
		return err
	}

	err = st.Phone_call.ReadBlock(_is, 68, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Lang_code, 69, false)
	if err != nil {
		return err
	}

	err = st.Difference.ReadBlock(_is, 70, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Available_min_id, 71, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Unread, 72, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Poll_id, 73, false)
	if err != nil {
		return err
	}

	err = st.Poll.ReadBlock(_is, 74, false)
	if err != nil {
		return err
	}

	err = st.Results.ReadBlock(_is, 75, false)
	if err != nil {
		return err
	}

	err = st.Default_banned_rights.ReadBlock(_is, 76, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(77, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Folder_peers = make([]FolderPeer, length)
			for i8, e8 := int32(0), length; i8 < e8; i8++ {

				err = st.Folder_peers[i8].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Settings.ReadBlock(_is, 78, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(79, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Peers = make([]PeerLocated, length)
			for i9, e9 := int32(0), length; i9 < e9; i9++ {

				err = st.Peers[i9].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Theme.ReadBlock(_is, 80, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(81, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Options = make([][]uint8, length)
			for i10, e10 := int32(0), length; i10 < e10; i10++ {

				err, have, ty = _is.SkipToNoCheck(0, false)
				if err != nil {
					return err
				}

				if have {
					if ty == codec.LIST {
						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}

						st.Options[i10] = make([]uint8, length)
						for i11, e11 := int32(0), length; i11 < e11; i11++ {

							err = _is.Read_uint8(&st.Options[i10][i11], 0, false)
							if err != nil {
								return err
							}

						}
					} else if ty == codec.SIMPLE_LIST {

						err, _ = _is.SkipTo(codec.BYTE, 0, true)
						if err != nil {
							return err
						}

						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}

						err = _is.Read_slice_uint8(&st.Options[i10], length, true)
						if err != nil {
							return err
						}

					} else {
						err = fmt.Errorf("require vector, but not")
						if err != nil {
							return err
						}

					}
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Filter.ReadBlock(_is, 82, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(83, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Order_84 = make([]int32, length)
			for i12, e12 := int32(0), length; i12 < e12; i12++ {

				err = _is.Read_int32(&st.Order_84[i12], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int64(&st.Phone_call_id, 84, false)
	if err != nil {
		return err
	}

	err = st.Prev_participant.ReadBlock(_is, 85, false)
	if err != nil {
		return err
	}

	err = st.New_participant.ReadBlock(_is, 86, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Forwards, 87, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Top_msg_id, 88, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Read_max_id, 89, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Broadcast_id, 90, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Broadcast_post, 91, false)
	if err != nil {
		return err
	}

	err = st.Peer_id.ReadBlock(_is, 92, false)
	if err != nil {
		return err
	}

	err = st.Blocked.ReadBlock(_is, 93, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Update_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Update_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Update_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Message.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Pts, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Pts_count, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Id, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Random_id, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Messages)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Messages {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.User_id, 6)
	if err != nil {
		return err
	}

	err = st.Action.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Chat_id, 8)
	if err != nil {
		return err
	}

	err = st.Participants.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = st.Status.WriteBlock(_os, 10)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.First_name, 11)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Last_name, 12)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Username, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 14)
	if err != nil {
		return err
	}

	err = st.Photo.WriteBlock(_os, 15)
	if err != nil {
		return err
	}

	err = st.Previous.WriteBlock(_os, 16)
	if err != nil {
		return err
	}

	err = st.Message_18.WriteBlock(_os, 17)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Qts, 18)
	if err != nil {
		return err
	}

	err = st.Chat.WriteBlock(_os, 19)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_date, 20)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Inviter_id, 21)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Version, 22)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 23)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Dc_options)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Dc_options {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Peer.WriteBlock(_os, 24)
	if err != nil {
		return err
	}

	err = st.Notify_settings.WriteBlock(_os, 25)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Popup, 26)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Inbox_date, 27)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Type, 28)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message_30, 29)
	if err != nil {
		return err
	}

	err = st.Media.WriteBlock(_os, 30)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 31)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Key_key.WriteBlock(_os, 32)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 33)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Rules)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Rules {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Phone, 34)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Folder_id, 35)
	if err != nil {
		return err
	}

	err = st.Peer_37.WriteBlock(_os, 36)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_id, 37)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Still_unread_count, 38)
	if err != nil {
		return err
	}

	err = st.Webpage.WriteBlock(_os, 39)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Channel_id, 40)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Views, 41)
	if err != nil {
		return err
	}

	err = st.Is_admin.WriteBlock(_os, 42)
	if err != nil {
		return err
	}

	err = st.Stickerset.WriteBlock(_os, 43)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Masks, 44)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 45)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Order)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Order {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int64(st.Query_id, 46)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Query, 47)
	if err != nil {
		return err
	}

	err = st.Geo.WriteBlock(_os, 48)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Offset, 49)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Id_51, 50)
	if err != nil {
		return err
	}

	err = st.Msg_id.WriteBlock(_os, 51)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Msg_id_53, 52)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Chat_instance, 53)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 54)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Data)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Data {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Game_short_name, 55)
	if err != nil {
		return err
	}

	err = st.Draft.WriteBlock(_os, 56)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Pinned, 57)
	if err != nil {
		return err
	}

	err = st.Peer_59.WriteBlock(_os, 58)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 59)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Order_60)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Order_60 {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Data_61.WriteBlock(_os, 60)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Timeout, 61)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 62)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Payload)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Payload {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = st.Shipping_address.WriteBlock(_os, 63)
	if err != nil {
		return err
	}

	err = st.Info.WriteBlock(_os, 64)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Shipping_option_id, 65)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Currency, 66)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Total_amount, 67)
	if err != nil {
		return err
	}

	err = st.Phone_call.WriteBlock(_os, 68)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Lang_code, 69)
	if err != nil {
		return err
	}

	err = st.Difference.WriteBlock(_os, 70)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Available_min_id, 71)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Unread, 72)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Poll_id, 73)
	if err != nil {
		return err
	}

	err = st.Poll.WriteBlock(_os, 74)
	if err != nil {
		return err
	}

	err = st.Results.WriteBlock(_os, 75)
	if err != nil {
		return err
	}

	err = st.Default_banned_rights.WriteBlock(_os, 76)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 77)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Folder_peers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Folder_peers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Settings.WriteBlock(_os, 78)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 79)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Peers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Peers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Theme.WriteBlock(_os, 80)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 81)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Options)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Options {

		err = _os.WriteHead(codec.LIST, 0)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v)), 0)
		if err != nil {
			return err
		}

		for _, v := range v {

			err = _os.Write_uint8(v, 0)
			if err != nil {
				return err
			}

		}
	}

	err = st.Filter.WriteBlock(_os, 82)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 83)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Order_84)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Order_84 {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int64(st.Phone_call_id, 84)
	if err != nil {
		return err
	}

	err = st.Prev_participant.WriteBlock(_os, 85)
	if err != nil {
		return err
	}

	err = st.New_participant.WriteBlock(_os, 86)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Forwards, 87)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Top_msg_id, 88)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Read_max_id, 89)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Broadcast_id, 90)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Broadcast_post, 91)
	if err != nil {
		return err
	}

	err = st.Peer_id.WriteBlock(_os, 92)
	if err != nil {
		return err
	}

	err = st.Blocked.WriteBlock(_os, 93)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Update_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateNewMessage struct implement
type TLupdateNewMessage struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateNewMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateNewMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateNewMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateNewMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateNewMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateNewMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateMessageID struct implement
type TLupdateMessageID struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateMessageID) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateMessageID) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateMessageID) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateMessageID, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateMessageID) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateMessageID) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateDeleteMessages struct implement
type TLupdateDeleteMessages struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateDeleteMessages) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateDeleteMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateDeleteMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateDeleteMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateDeleteMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateDeleteMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateUserTyping struct implement
type TLupdateUserTyping struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateUserTyping) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateUserTyping) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateUserTyping) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateUserTyping, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateUserTyping) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateUserTyping) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateChatUserTyping struct implement
type TLupdateChatUserTyping struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateChatUserTyping) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateChatUserTyping) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateChatUserTyping) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateChatUserTyping, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateChatUserTyping) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateChatUserTyping) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateChatParticipants struct implement
type TLupdateChatParticipants struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateChatParticipants) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateChatParticipants) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateChatParticipants) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateChatParticipants, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateChatParticipants) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateChatParticipants) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateUserStatus struct implement
type TLupdateUserStatus struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateUserStatus) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateUserStatus) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateUserStatus) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateUserStatus, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateUserStatus) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateUserStatus) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateUserName struct implement
type TLupdateUserName struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateUserName) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateUserName) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateUserName) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateUserName, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateUserName) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateUserName) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateUserPhoto struct implement
type TLupdateUserPhoto struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateUserPhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateUserPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateUserPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateUserPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateUserPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateUserPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateNewEncryptedMessage struct implement
type TLupdateNewEncryptedMessage struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateNewEncryptedMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateNewEncryptedMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateNewEncryptedMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateNewEncryptedMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateNewEncryptedMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateNewEncryptedMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateEncryptedChatTyping struct implement
type TLupdateEncryptedChatTyping struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateEncryptedChatTyping) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateEncryptedChatTyping) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateEncryptedChatTyping) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateEncryptedChatTyping, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateEncryptedChatTyping) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateEncryptedChatTyping) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateEncryption struct implement
type TLupdateEncryption struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateEncryption) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateEncryption) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateEncryption) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateEncryption, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateEncryption) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateEncryption) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateEncryptedMessagesRead struct implement
type TLupdateEncryptedMessagesRead struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateEncryptedMessagesRead) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateEncryptedMessagesRead) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateEncryptedMessagesRead) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateEncryptedMessagesRead, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateEncryptedMessagesRead) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateEncryptedMessagesRead) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateChatParticipantAdd struct implement
type TLupdateChatParticipantAdd struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateChatParticipantAdd) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateChatParticipantAdd) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateChatParticipantAdd) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateChatParticipantAdd, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateChatParticipantAdd) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateChatParticipantAdd) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateChatParticipantDelete struct implement
type TLupdateChatParticipantDelete struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateChatParticipantDelete) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateChatParticipantDelete) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateChatParticipantDelete) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateChatParticipantDelete, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateChatParticipantDelete) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateChatParticipantDelete) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateDcOptions struct implement
type TLupdateDcOptions struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateDcOptions) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateDcOptions) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateDcOptions) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateDcOptions, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateDcOptions) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateDcOptions) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateNotifySettings struct implement
type TLupdateNotifySettings struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateNotifySettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateNotifySettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateNotifySettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateNotifySettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateNotifySettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateNotifySettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateServiceNotification struct implement
type TLupdateServiceNotification struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateServiceNotification) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateServiceNotification) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateServiceNotification) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateServiceNotification, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateServiceNotification) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateServiceNotification) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdatePrivacy struct implement
type TLupdatePrivacy struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdatePrivacy) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdatePrivacy) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdatePrivacy) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdatePrivacy, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdatePrivacy) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdatePrivacy) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateUserPhone struct implement
type TLupdateUserPhone struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateUserPhone) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateUserPhone) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateUserPhone) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateUserPhone, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateUserPhone) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateUserPhone) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateReadHistoryInbox struct implement
type TLupdateReadHistoryInbox struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateReadHistoryInbox) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateReadHistoryInbox) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateReadHistoryInbox) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateReadHistoryInbox, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateReadHistoryInbox) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateReadHistoryInbox) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateReadHistoryOutbox struct implement
type TLupdateReadHistoryOutbox struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateReadHistoryOutbox) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateReadHistoryOutbox) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateReadHistoryOutbox) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateReadHistoryOutbox, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateReadHistoryOutbox) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateReadHistoryOutbox) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateWebPage struct implement
type TLupdateWebPage struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateWebPage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateWebPage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateWebPage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateWebPage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateWebPage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateWebPage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateReadMessagesContents struct implement
type TLupdateReadMessagesContents struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateReadMessagesContents) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateReadMessagesContents) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateReadMessagesContents) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateReadMessagesContents, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateReadMessagesContents) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateReadMessagesContents) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateChannelTooLong struct implement
type TLupdateChannelTooLong struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateChannelTooLong) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateChannelTooLong) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateChannelTooLong) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateChannelTooLong, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateChannelTooLong) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateChannelTooLong) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateChannel struct implement
type TLupdateChannel struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateChannel) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateChannel) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateChannel) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateChannel, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateChannel) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateChannel) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateNewChannelMessage struct implement
type TLupdateNewChannelMessage struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateNewChannelMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateNewChannelMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateNewChannelMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateNewChannelMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateNewChannelMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateNewChannelMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateReadChannelInbox struct implement
type TLupdateReadChannelInbox struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateReadChannelInbox) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateReadChannelInbox) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateReadChannelInbox) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateReadChannelInbox, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateReadChannelInbox) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateReadChannelInbox) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateDeleteChannelMessages struct implement
type TLupdateDeleteChannelMessages struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateDeleteChannelMessages) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateDeleteChannelMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateDeleteChannelMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateDeleteChannelMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateDeleteChannelMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateDeleteChannelMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateChannelMessageViews struct implement
type TLupdateChannelMessageViews struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateChannelMessageViews) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateChannelMessageViews) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateChannelMessageViews) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateChannelMessageViews, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateChannelMessageViews) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateChannelMessageViews) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateChatParticipantAdmin struct implement
type TLupdateChatParticipantAdmin struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateChatParticipantAdmin) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateChatParticipantAdmin) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateChatParticipantAdmin) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateChatParticipantAdmin, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateChatParticipantAdmin) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateChatParticipantAdmin) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateNewStickerSet struct implement
type TLupdateNewStickerSet struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateNewStickerSet) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateNewStickerSet) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateNewStickerSet) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateNewStickerSet, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateNewStickerSet) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateNewStickerSet) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateStickerSetsOrder struct implement
type TLupdateStickerSetsOrder struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateStickerSetsOrder) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateStickerSetsOrder) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateStickerSetsOrder) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateStickerSetsOrder, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateStickerSetsOrder) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateStickerSetsOrder) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateStickerSets struct implement
type TLupdateStickerSets struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateStickerSets) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateStickerSets) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateStickerSets) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateStickerSets, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateStickerSets) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateStickerSets) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateSavedGifs struct implement
type TLupdateSavedGifs struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateSavedGifs) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateSavedGifs) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateSavedGifs) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateSavedGifs, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateSavedGifs) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateSavedGifs) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateBotInlineQuery struct implement
type TLupdateBotInlineQuery struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateBotInlineQuery) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateBotInlineQuery) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateBotInlineQuery) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateBotInlineQuery, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateBotInlineQuery) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateBotInlineQuery) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateBotInlineSend struct implement
type TLupdateBotInlineSend struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateBotInlineSend) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateBotInlineSend) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateBotInlineSend) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateBotInlineSend, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateBotInlineSend) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateBotInlineSend) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateEditChannelMessage struct implement
type TLupdateEditChannelMessage struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateEditChannelMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateEditChannelMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateEditChannelMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateEditChannelMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateEditChannelMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateEditChannelMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateBotCallbackQuery struct implement
type TLupdateBotCallbackQuery struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateBotCallbackQuery) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateBotCallbackQuery) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateBotCallbackQuery) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateBotCallbackQuery, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateBotCallbackQuery) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateBotCallbackQuery) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateEditMessage struct implement
type TLupdateEditMessage struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateEditMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateEditMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateEditMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateEditMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateEditMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateEditMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateInlineBotCallbackQuery struct implement
type TLupdateInlineBotCallbackQuery struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateInlineBotCallbackQuery) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateInlineBotCallbackQuery) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateInlineBotCallbackQuery) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateInlineBotCallbackQuery, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateInlineBotCallbackQuery) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateInlineBotCallbackQuery) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateReadChannelOutbox struct implement
type TLupdateReadChannelOutbox struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateReadChannelOutbox) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateReadChannelOutbox) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateReadChannelOutbox) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateReadChannelOutbox, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateReadChannelOutbox) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateReadChannelOutbox) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateDraftMessage struct implement
type TLupdateDraftMessage struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateDraftMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateDraftMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateDraftMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateDraftMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateDraftMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateDraftMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateReadFeaturedStickers struct implement
type TLupdateReadFeaturedStickers struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateReadFeaturedStickers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateReadFeaturedStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateReadFeaturedStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateReadFeaturedStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateReadFeaturedStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateReadFeaturedStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateRecentStickers struct implement
type TLupdateRecentStickers struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateRecentStickers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateRecentStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateRecentStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateRecentStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateRecentStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateRecentStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateConfig struct implement
type TLupdateConfig struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateConfig) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateConfig) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateConfig) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateConfig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateConfig) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateConfig) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdatePtsChanged struct implement
type TLupdatePtsChanged struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdatePtsChanged) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdatePtsChanged) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdatePtsChanged) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdatePtsChanged, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdatePtsChanged) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdatePtsChanged) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateChannelWebPage struct implement
type TLupdateChannelWebPage struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateChannelWebPage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateChannelWebPage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateChannelWebPage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateChannelWebPage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateChannelWebPage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateChannelWebPage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateDialogPinned struct implement
type TLupdateDialogPinned struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateDialogPinned) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateDialogPinned) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateDialogPinned) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateDialogPinned, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateDialogPinned) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateDialogPinned) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdatePinnedDialogs struct implement
type TLupdatePinnedDialogs struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdatePinnedDialogs) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdatePinnedDialogs) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdatePinnedDialogs) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdatePinnedDialogs, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdatePinnedDialogs) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdatePinnedDialogs) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateBotWebhookJSON struct implement
type TLupdateBotWebhookJSON struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateBotWebhookJSON) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateBotWebhookJSON) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateBotWebhookJSON) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateBotWebhookJSON, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateBotWebhookJSON) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateBotWebhookJSON) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateBotWebhookJSONQuery struct implement
type TLupdateBotWebhookJSONQuery struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateBotWebhookJSONQuery) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateBotWebhookJSONQuery) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateBotWebhookJSONQuery) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateBotWebhookJSONQuery, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateBotWebhookJSONQuery) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateBotWebhookJSONQuery) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateBotShippingQuery struct implement
type TLupdateBotShippingQuery struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateBotShippingQuery) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateBotShippingQuery) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateBotShippingQuery) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateBotShippingQuery, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateBotShippingQuery) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateBotShippingQuery) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateBotPrecheckoutQuery struct implement
type TLupdateBotPrecheckoutQuery struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateBotPrecheckoutQuery) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateBotPrecheckoutQuery) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateBotPrecheckoutQuery) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateBotPrecheckoutQuery, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateBotPrecheckoutQuery) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateBotPrecheckoutQuery) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdatePhoneCall struct implement
type TLupdatePhoneCall struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdatePhoneCall) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdatePhoneCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdatePhoneCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdatePhoneCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdatePhoneCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdatePhoneCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateLangPackTooLong struct implement
type TLupdateLangPackTooLong struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateLangPackTooLong) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateLangPackTooLong) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateLangPackTooLong) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateLangPackTooLong, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateLangPackTooLong) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateLangPackTooLong) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateLangPack struct implement
type TLupdateLangPack struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateLangPack) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateLangPack) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateLangPack) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateLangPack, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateLangPack) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateLangPack) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateFavedStickers struct implement
type TLupdateFavedStickers struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateFavedStickers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateFavedStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateFavedStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateFavedStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateFavedStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateFavedStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateChannelReadMessagesContents struct implement
type TLupdateChannelReadMessagesContents struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateChannelReadMessagesContents) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateChannelReadMessagesContents) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateChannelReadMessagesContents) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateChannelReadMessagesContents, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateChannelReadMessagesContents) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateChannelReadMessagesContents) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateContactsReset struct implement
type TLupdateContactsReset struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateContactsReset) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateContactsReset) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateContactsReset) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateContactsReset, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateContactsReset) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateContactsReset) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateChannelAvailableMessages struct implement
type TLupdateChannelAvailableMessages struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateChannelAvailableMessages) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateChannelAvailableMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateChannelAvailableMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateChannelAvailableMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateChannelAvailableMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateChannelAvailableMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateDialogUnreadMark struct implement
type TLupdateDialogUnreadMark struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateDialogUnreadMark) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateDialogUnreadMark) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateDialogUnreadMark) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateDialogUnreadMark, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateDialogUnreadMark) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateDialogUnreadMark) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateMessagePoll struct implement
type TLupdateMessagePoll struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateMessagePoll) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateMessagePoll) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateMessagePoll) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateMessagePoll, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateMessagePoll) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateMessagePoll) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateChatDefaultBannedRights struct implement
type TLupdateChatDefaultBannedRights struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateChatDefaultBannedRights) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateChatDefaultBannedRights) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateChatDefaultBannedRights) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateChatDefaultBannedRights, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateChatDefaultBannedRights) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateChatDefaultBannedRights) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateFolderPeers struct implement
type TLupdateFolderPeers struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateFolderPeers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateFolderPeers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateFolderPeers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateFolderPeers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateFolderPeers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateFolderPeers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdatePeerSettings struct implement
type TLupdatePeerSettings struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdatePeerSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdatePeerSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdatePeerSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdatePeerSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdatePeerSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdatePeerSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdatePeerLocated struct implement
type TLupdatePeerLocated struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdatePeerLocated) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdatePeerLocated) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdatePeerLocated) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdatePeerLocated, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdatePeerLocated) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdatePeerLocated) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateNewScheduledMessage struct implement
type TLupdateNewScheduledMessage struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateNewScheduledMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateNewScheduledMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateNewScheduledMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateNewScheduledMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateNewScheduledMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateNewScheduledMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateDeleteScheduledMessages struct implement
type TLupdateDeleteScheduledMessages struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateDeleteScheduledMessages) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateDeleteScheduledMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateDeleteScheduledMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateDeleteScheduledMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateDeleteScheduledMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateDeleteScheduledMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateTheme struct implement
type TLupdateTheme struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateTheme) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateTheme) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateTheme) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateTheme, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateTheme) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateTheme) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateGeoLiveViewed struct implement
type TLupdateGeoLiveViewed struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateGeoLiveViewed) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateGeoLiveViewed) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateGeoLiveViewed) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateGeoLiveViewed, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateGeoLiveViewed) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateGeoLiveViewed) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateLoginToken struct implement
type TLupdateLoginToken struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateLoginToken) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateLoginToken) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateLoginToken) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateLoginToken, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateLoginToken) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateLoginToken) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateMessagePollVote struct implement
type TLupdateMessagePollVote struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateMessagePollVote) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateMessagePollVote) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateMessagePollVote) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateMessagePollVote, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateMessagePollVote) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateMessagePollVote) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateDialogFilter struct implement
type TLupdateDialogFilter struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateDialogFilter) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateDialogFilter) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateDialogFilter) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateDialogFilter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateDialogFilter) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateDialogFilter) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateDialogFilterOrder struct implement
type TLupdateDialogFilterOrder struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateDialogFilterOrder) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateDialogFilterOrder) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateDialogFilterOrder) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateDialogFilterOrder, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateDialogFilterOrder) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateDialogFilterOrder) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateDialogFilters struct implement
type TLupdateDialogFilters struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateDialogFilters) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateDialogFilters) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateDialogFilters) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateDialogFilters, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateDialogFilters) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateDialogFilters) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdatePhoneCallSignalingData struct implement
type TLupdatePhoneCallSignalingData struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdatePhoneCallSignalingData) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdatePhoneCallSignalingData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdatePhoneCallSignalingData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdatePhoneCallSignalingData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdatePhoneCallSignalingData) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdatePhoneCallSignalingData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateChannelParticipant struct implement
type TLupdateChannelParticipant struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateChannelParticipant) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateChannelParticipant) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateChannelParticipant) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateChannelParticipant, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateChannelParticipant) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateChannelParticipant) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateChannelMessageForwards struct implement
type TLupdateChannelMessageForwards struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateChannelMessageForwards) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateChannelMessageForwards) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateChannelMessageForwards) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateChannelMessageForwards, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateChannelMessageForwards) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateChannelMessageForwards) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateReadChannelDiscussionInbox struct implement
type TLupdateReadChannelDiscussionInbox struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateReadChannelDiscussionInbox) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateReadChannelDiscussionInbox) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateReadChannelDiscussionInbox) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateReadChannelDiscussionInbox, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateReadChannelDiscussionInbox) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateReadChannelDiscussionInbox) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateReadChannelDiscussionOutbox struct implement
type TLupdateReadChannelDiscussionOutbox struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateReadChannelDiscussionOutbox) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateReadChannelDiscussionOutbox) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateReadChannelDiscussionOutbox) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateReadChannelDiscussionOutbox, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateReadChannelDiscussionOutbox) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateReadChannelDiscussionOutbox) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdatePeerBlocked struct implement
type TLupdatePeerBlocked struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdatePeerBlocked) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdatePeerBlocked) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdatePeerBlocked) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdatePeerBlocked, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdatePeerBlocked) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdatePeerBlocked) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateChannelUserTyping struct implement
type TLupdateChannelUserTyping struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdateChannelUserTyping) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateChannelUserTyping) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateChannelUserTyping) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateChannelUserTyping, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateChannelUserTyping) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateChannelUserTyping) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdatePinnedMessages struct implement
type TLupdatePinnedMessages struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdatePinnedMessages) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdatePinnedMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdatePinnedMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdatePinnedMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdatePinnedMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdatePinnedMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdatePinnedChannelMessages struct implement
type TLupdatePinnedChannelMessages struct {
	Data Update_Data `json:"data"`
}

func (st *TLupdatePinnedChannelMessages) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdatePinnedChannelMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdatePinnedChannelMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdatePinnedChannelMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdatePinnedChannelMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdatePinnedChannelMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// BotInlineMessage struct implement
type BotInlineMessage struct {
	Constructor int32                 `json:"constructor"`
	Data        BotInlineMessage_Data `json:"data"`
}

func (st *BotInlineMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *BotInlineMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *BotInlineMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BotInlineMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *BotInlineMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *BotInlineMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// BotInlineMessage_Data struct implement
type BotInlineMessage_Data struct {
	Message                       string          `json:"message"`
	Entities                      []MessageEntity `json:"entities"`
	Reply_markup                  ReplyMarkup     `json:"reply_markup"`
	No_webpage                    bool            `json:"no_webpage"`
	Geo                           GeoPoint        `json:"geo"`
	Heading                       int32           `json:"heading"`
	Period                        int32           `json:"period"`
	Proximity_notification_radius int32           `json:"proximity_notification_radius"`
	Title                         string          `json:"title"`
	Address                       string          `json:"address"`
	Provider                      string          `json:"provider"`
	Venue_id                      string          `json:"venue_id"`
	Venue_type                    string          `json:"venue_type"`
	Phone_number                  string          `json:"phone_number"`
	First_name                    string          `json:"first_name"`
	Last_name                     string          `json:"last_name"`
	Vcard                         string          `json:"vcard"`
}

func (st *BotInlineMessage_Data) ResetDefault() {
	st.Reply_markup.ResetDefault()
	st.Geo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *BotInlineMessage_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Message, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Reply_markup.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.No_webpage, 3, false)
	if err != nil {
		return err
	}

	err = st.Geo.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Heading, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Period, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Proximity_notification_radius, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Address, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Provider, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Venue_id, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Venue_type, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone_number, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.First_name, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Last_name, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Vcard, 16, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *BotInlineMessage_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BotInlineMessage_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *BotInlineMessage_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Message, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Reply_markup.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.No_webpage, 3)
	if err != nil {
		return err
	}

	err = st.Geo.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Heading, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Period, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Proximity_notification_radius, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 8)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Address, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Provider, 10)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Venue_id, 11)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Venue_type, 12)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone_number, 13)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.First_name, 14)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Last_name, 15)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Vcard, 16)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *BotInlineMessage_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbotInlineMessageMediaAuto struct implement
type TLbotInlineMessageMediaAuto struct {
	Data BotInlineMessage_Data `json:"data"`
}

func (st *TLbotInlineMessageMediaAuto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbotInlineMessageMediaAuto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbotInlineMessageMediaAuto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbotInlineMessageMediaAuto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbotInlineMessageMediaAuto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbotInlineMessageMediaAuto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbotInlineMessageText struct implement
type TLbotInlineMessageText struct {
	Data BotInlineMessage_Data `json:"data"`
}

func (st *TLbotInlineMessageText) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbotInlineMessageText) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbotInlineMessageText) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbotInlineMessageText, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbotInlineMessageText) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbotInlineMessageText) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbotInlineMessageMediaGeo struct implement
type TLbotInlineMessageMediaGeo struct {
	Data BotInlineMessage_Data `json:"data"`
}

func (st *TLbotInlineMessageMediaGeo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbotInlineMessageMediaGeo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbotInlineMessageMediaGeo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbotInlineMessageMediaGeo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbotInlineMessageMediaGeo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbotInlineMessageMediaGeo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbotInlineMessageMediaVenue struct implement
type TLbotInlineMessageMediaVenue struct {
	Data BotInlineMessage_Data `json:"data"`
}

func (st *TLbotInlineMessageMediaVenue) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbotInlineMessageMediaVenue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbotInlineMessageMediaVenue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbotInlineMessageMediaVenue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbotInlineMessageMediaVenue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbotInlineMessageMediaVenue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbotInlineMessageMediaContact struct implement
type TLbotInlineMessageMediaContact struct {
	Data BotInlineMessage_Data `json:"data"`
}

func (st *TLbotInlineMessageMediaContact) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbotInlineMessageMediaContact) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbotInlineMessageMediaContact) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbotInlineMessageMediaContact, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbotInlineMessageMediaContact) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbotInlineMessageMediaContact) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputNotifyPeer struct implement
type InputNotifyPeer struct {
	Constructor int32                `json:"constructor"`
	Data        InputNotifyPeer_Data `json:"data"`
}

func (st *InputNotifyPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputNotifyPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputNotifyPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputNotifyPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputNotifyPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputNotifyPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputNotifyPeer_Data struct implement
type InputNotifyPeer_Data struct {
	Peer InputPeer `json:"peer"`
}

func (st *InputNotifyPeer_Data) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputNotifyPeer_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputNotifyPeer_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputNotifyPeer_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputNotifyPeer_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputNotifyPeer_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputNotifyPeer struct implement
type TLinputNotifyPeer struct {
	Data InputNotifyPeer_Data `json:"data"`
}

func (st *TLinputNotifyPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputNotifyPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputNotifyPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputNotifyPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputNotifyPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputNotifyPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputNotifyUsers struct implement
type TLinputNotifyUsers struct {
	Data InputNotifyPeer_Data `json:"data"`
}

func (st *TLinputNotifyUsers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputNotifyUsers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputNotifyUsers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputNotifyUsers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputNotifyUsers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputNotifyUsers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputNotifyChats struct implement
type TLinputNotifyChats struct {
	Data InputNotifyPeer_Data `json:"data"`
}

func (st *TLinputNotifyChats) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputNotifyChats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputNotifyChats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputNotifyChats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputNotifyChats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputNotifyChats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputNotifyBroadcasts struct implement
type TLinputNotifyBroadcasts struct {
	Data InputNotifyPeer_Data `json:"data"`
}

func (st *TLinputNotifyBroadcasts) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputNotifyBroadcasts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputNotifyBroadcasts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputNotifyBroadcasts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputNotifyBroadcasts) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputNotifyBroadcasts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// EncryptedMessage struct implement
type EncryptedMessage struct {
	Constructor int32                 `json:"constructor"`
	Data        EncryptedMessage_Data `json:"data"`
}

func (st *EncryptedMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *EncryptedMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *EncryptedMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EncryptedMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *EncryptedMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *EncryptedMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// EncryptedMessage_Data struct implement
type EncryptedMessage_Data struct {
	Random_id int64         `json:"random_id"`
	Chat_id   int32         `json:"chat_id"`
	Date      int32         `json:"date"`
	Bytes     []uint8       `json:"bytes"`
	File      EncryptedFile `json:"file"`
}

func (st *EncryptedMessage_Data) ResetDefault() {
	st.File.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *EncryptedMessage_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Random_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Chat_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Bytes = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Bytes[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Bytes, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.File.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *EncryptedMessage_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EncryptedMessage_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *EncryptedMessage_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Random_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Chat_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Bytes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Bytes {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = st.File.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *EncryptedMessage_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLencryptedMessage struct implement
type TLencryptedMessage struct {
	Data EncryptedMessage_Data `json:"data"`
}

func (st *TLencryptedMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLencryptedMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLencryptedMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLencryptedMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLencryptedMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLencryptedMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLencryptedMessageService struct implement
type TLencryptedMessageService struct {
	Data EncryptedMessage_Data `json:"data"`
}

func (st *TLencryptedMessageService) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLencryptedMessageService) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLencryptedMessageService) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLencryptedMessageService, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLencryptedMessageService) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLencryptedMessageService) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputDocument struct implement
type InputDocument struct {
	Constructor int32              `json:"constructor"`
	Data        InputDocument_Data `json:"data"`
}

func (st *InputDocument) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputDocument) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputDocument) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputDocument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputDocument) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputDocument) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputDocument_Data struct implement
type InputDocument_Data struct {
	Id             int64   `json:"id"`
	Access_hash    int64   `json:"access_hash"`
	File_reference []uint8 `json:"file_reference"`
}

func (st *InputDocument_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputDocument_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.File_reference = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.File_reference[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.File_reference, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputDocument_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputDocument_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputDocument_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.File_reference)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.File_reference {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputDocument_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputDocumentEmpty struct implement
type TLinputDocumentEmpty struct {
	Data InputDocument_Data `json:"data"`
}

func (st *TLinputDocumentEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputDocumentEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputDocumentEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputDocumentEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputDocumentEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputDocumentEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputDocument struct implement
type TLinputDocument struct {
	Data InputDocument_Data `json:"data"`
}

func (st *TLinputDocument) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputDocument) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputDocument) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputDocument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputDocument) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputDocument) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageViews struct implement
type MessageViews struct {
	Constructor int32             `json:"constructor"`
	Data        MessageViews_Data `json:"data"`
}

func (st *MessageViews) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageViews) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageViews) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageViews, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageViews) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageViews) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageViews_Data struct implement
type MessageViews_Data struct {
	Views    int32          `json:"views"`
	Forwards int32          `json:"forwards"`
	Replies  MessageReplies `json:"replies"`
}

func (st *MessageViews_Data) ResetDefault() {
	st.Replies.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageViews_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Views, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Forwards, 1, false)
	if err != nil {
		return err
	}

	err = st.Replies.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageViews_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageViews_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageViews_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Views, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Forwards, 1)
	if err != nil {
		return err
	}

	err = st.Replies.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageViews_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageViews struct implement
type TLmessageViews struct {
	Data MessageViews_Data `json:"data"`
}

func (st *TLmessageViews) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageViews) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageViews) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageViews, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageViews) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageViews) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// WebAuthorization struct implement
type WebAuthorization struct {
	Constructor int32                 `json:"constructor"`
	Data        WebAuthorization_Data `json:"data"`
}

func (st *WebAuthorization) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *WebAuthorization) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *WebAuthorization) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require WebAuthorization, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *WebAuthorization) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *WebAuthorization) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// WebAuthorization_Data struct implement
type WebAuthorization_Data struct {
	Hash         int64  `json:"hash"`
	Bot_id       int32  `json:"bot_id"`
	Domain       string `json:"domain"`
	Browser      string `json:"browser"`
	Platform     string `json:"platform"`
	Date_created int32  `json:"date_created"`
	Date_active  int32  `json:"date_active"`
	Ip           string `json:"ip"`
	Region       string `json:"region"`
}

func (st *WebAuthorization_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *WebAuthorization_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Bot_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Domain, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Browser, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Platform, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date_created, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date_active, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Ip, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Region, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *WebAuthorization_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require WebAuthorization_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *WebAuthorization_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Hash, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Bot_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Domain, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Browser, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Platform, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date_created, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date_active, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Ip, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Region, 8)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *WebAuthorization_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLwebAuthorization struct implement
type TLwebAuthorization struct {
	Data WebAuthorization_Data `json:"data"`
}

func (st *TLwebAuthorization) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLwebAuthorization) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLwebAuthorization) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLwebAuthorization, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLwebAuthorization) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLwebAuthorization) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputContact struct implement
type InputContact struct {
	Constructor int32             `json:"constructor"`
	Data        InputContact_Data `json:"data"`
}

func (st *InputContact) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputContact) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputContact) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputContact, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputContact) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputContact) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputContact_Data struct implement
type InputContact_Data struct {
	Client_id  int64  `json:"client_id"`
	Phone      string `json:"phone"`
	First_name string `json:"first_name"`
	Last_name  string `json:"last_name"`
}

func (st *InputContact_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputContact_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Client_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.First_name, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Last_name, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputContact_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputContact_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputContact_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Client_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.First_name, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Last_name, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputContact_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPhoneContact struct implement
type TLinputPhoneContact struct {
	Data InputContact_Data `json:"data"`
}

func (st *TLinputPhoneContact) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPhoneContact) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPhoneContact) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPhoneContact, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPhoneContact) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPhoneContact) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputPhoneCall struct implement
type InputPhoneCall struct {
	Constructor int32               `json:"constructor"`
	Data        InputPhoneCall_Data `json:"data"`
}

func (st *InputPhoneCall) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputPhoneCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputPhoneCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputPhoneCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputPhoneCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputPhoneCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputPhoneCall_Data struct implement
type InputPhoneCall_Data struct {
	Id          int64 `json:"id"`
	Access_hash int64 `json:"access_hash"`
}

func (st *InputPhoneCall_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputPhoneCall_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputPhoneCall_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputPhoneCall_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputPhoneCall_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputPhoneCall_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPhoneCall struct implement
type TLinputPhoneCall struct {
	Data InputPhoneCall_Data `json:"data"`
}

func (st *TLinputPhoneCall) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPhoneCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPhoneCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPhoneCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPhoneCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPhoneCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_MessageViews struct implement
type Messages_MessageViews struct {
	Constructor int32                      `json:"constructor"`
	Data        Messages_MessageViews_Data `json:"data"`
}

func (st *Messages_MessageViews) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_MessageViews) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_MessageViews) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_MessageViews, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_MessageViews) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_MessageViews) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_MessageViews_Data struct implement
type Messages_MessageViews_Data struct {
	Views []MessageViews `json:"views"`
	Chats []Chat         `json:"chats"`
	Users []User         `json:"users"`
}

func (st *Messages_MessageViews_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_MessageViews_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Views = make([]MessageViews, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Views[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Chats[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Users[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_MessageViews_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_MessageViews_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_MessageViews_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Views)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Views {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_MessageViews_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_messageViews struct implement
type TLmessages_messageViews struct {
	Data Messages_MessageViews_Data `json:"data"`
}

func (st *TLmessages_messageViews) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_messageViews) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_messageViews) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_messageViews, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_messageViews) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_messageViews) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_FeaturedStickers struct implement
type Messages_FeaturedStickers struct {
	Constructor int32                          `json:"constructor"`
	Data        Messages_FeaturedStickers_Data `json:"data"`
}

func (st *Messages_FeaturedStickers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_FeaturedStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_FeaturedStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_FeaturedStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_FeaturedStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_FeaturedStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_FeaturedStickers_Data struct implement
type Messages_FeaturedStickers_Data struct {
	Count  int32               `json:"count"`
	Hash   int32               `json:"hash"`
	Sets   []StickerSetCovered `json:"sets"`
	Unread []int64             `json:"unread"`
}

func (st *Messages_FeaturedStickers_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_FeaturedStickers_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Count, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Sets = make([]StickerSetCovered, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Sets[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Unread = make([]int64, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int64(&st.Unread[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_FeaturedStickers_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_FeaturedStickers_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_FeaturedStickers_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Count, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Sets)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Sets {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Unread)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Unread {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_FeaturedStickers_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_featuredStickersNotModified struct implement
type TLmessages_featuredStickersNotModified struct {
	Data Messages_FeaturedStickers_Data `json:"data"`
}

func (st *TLmessages_featuredStickersNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_featuredStickersNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_featuredStickersNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_featuredStickersNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_featuredStickersNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_featuredStickersNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_featuredStickers struct implement
type TLmessages_featuredStickers struct {
	Data Messages_FeaturedStickers_Data `json:"data"`
}

func (st *TLmessages_featuredStickers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_featuredStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_featuredStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_featuredStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_featuredStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_featuredStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// UserFull struct implement
type UserFull struct {
	Constructor int32         `json:"constructor"`
	Data        UserFull_Data `json:"data"`
}

func (st *UserFull) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *UserFull) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *UserFull) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserFull, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *UserFull) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *UserFull) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// UserFull_Data struct implement
type UserFull_Data struct {
	Blocked               bool               `json:"blocked"`
	Phone_calls_available bool               `json:"phone_calls_available"`
	Phone_calls_private   bool               `json:"phone_calls_private"`
	Can_pin_message       bool               `json:"can_pin_message"`
	Has_scheduled         bool               `json:"has_scheduled"`
	Video_calls_available bool               `json:"video_calls_available"`
	User                  User               `json:"user"`
	About                 string             `json:"about"`
	Settings              PeerSettings       `json:"settings"`
	Profile_photo         Photo              `json:"profile_photo"`
	Notify_settings       PeerNotifySettings `json:"notify_settings"`
	Bot_info              BotInfo            `json:"bot_info"`
	Pinned_msg_id         int32              `json:"pinned_msg_id"`
	Common_chats_count    int32              `json:"common_chats_count"`
	Folder_id             int32              `json:"folder_id"`
}

func (st *UserFull_Data) ResetDefault() {
	st.User.ResetDefault()
	st.Settings.ResetDefault()
	st.Profile_photo.ResetDefault()
	st.Notify_settings.ResetDefault()
	st.Bot_info.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *UserFull_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Blocked, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Phone_calls_available, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Phone_calls_private, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Can_pin_message, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Has_scheduled, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Video_calls_available, 5, false)
	if err != nil {
		return err
	}

	err = st.User.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.About, 7, false)
	if err != nil {
		return err
	}

	err = st.Settings.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err = st.Profile_photo.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err = st.Notify_settings.ReadBlock(_is, 10, false)
	if err != nil {
		return err
	}

	err = st.Bot_info.ReadBlock(_is, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Pinned_msg_id, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Common_chats_count, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Folder_id, 14, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *UserFull_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserFull_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *UserFull_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Blocked, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Phone_calls_available, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Phone_calls_private, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Can_pin_message, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Has_scheduled, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Video_calls_available, 5)
	if err != nil {
		return err
	}

	err = st.User.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.About, 7)
	if err != nil {
		return err
	}

	err = st.Settings.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = st.Profile_photo.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = st.Notify_settings.WriteBlock(_os, 10)
	if err != nil {
		return err
	}

	err = st.Bot_info.WriteBlock(_os, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Pinned_msg_id, 12)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Common_chats_count, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Folder_id, 14)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *UserFull_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLuserFull struct implement
type TLuserFull struct {
	Data UserFull_Data `json:"data"`
}

func (st *TLuserFull) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLuserFull) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLuserFull) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLuserFull, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLuserFull) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLuserFull) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_PrivacyRules struct implement
type Account_PrivacyRules struct {
	Constructor int32                     `json:"constructor"`
	Data        Account_PrivacyRules_Data `json:"data"`
}

func (st *Account_PrivacyRules) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_PrivacyRules) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_PrivacyRules) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_PrivacyRules, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_PrivacyRules) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_PrivacyRules) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_PrivacyRules_Data struct implement
type Account_PrivacyRules_Data struct {
	Rules []PrivacyRule `json:"rules"`
	Chats []Chat        `json:"chats"`
	Users []User        `json:"users"`
}

func (st *Account_PrivacyRules_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_PrivacyRules_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Rules = make([]PrivacyRule, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Rules[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Chats[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Users[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_PrivacyRules_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_PrivacyRules_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_PrivacyRules_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Rules)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Rules {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_PrivacyRules_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_privacyRules struct implement
type TLaccount_privacyRules struct {
	Data Account_PrivacyRules_Data `json:"data"`
}

func (st *TLaccount_privacyRules) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_privacyRules) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_privacyRules) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_privacyRules, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_privacyRules) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_privacyRules) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageUserVote struct implement
type MessageUserVote struct {
	Constructor int32                `json:"constructor"`
	Data        MessageUserVote_Data `json:"data"`
}

func (st *MessageUserVote) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageUserVote) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageUserVote) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageUserVote, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageUserVote) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageUserVote) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageUserVote_Data struct implement
type MessageUserVote_Data struct {
	User_id int32     `json:"user_id"`
	Option  []uint8   `json:"option"`
	Date    int32     `json:"date"`
	Options [][]uint8 `json:"options"`
}

func (st *MessageUserVote_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageUserVote_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Option = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Option[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Option, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Date, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Options = make([][]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err, have, ty = _is.SkipToNoCheck(0, false)
				if err != nil {
					return err
				}

				if have {
					if ty == codec.LIST {
						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}

						st.Options[i1] = make([]uint8, length)
						for i2, e2 := int32(0), length; i2 < e2; i2++ {

							err = _is.Read_uint8(&st.Options[i1][i2], 0, false)
							if err != nil {
								return err
							}

						}
					} else if ty == codec.SIMPLE_LIST {

						err, _ = _is.SkipTo(codec.BYTE, 0, true)
						if err != nil {
							return err
						}

						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}

						err = _is.Read_slice_uint8(&st.Options[i1], length, true)
						if err != nil {
							return err
						}

					} else {
						err = fmt.Errorf("require vector, but not")
						if err != nil {
							return err
						}

					}
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageUserVote_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageUserVote_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageUserVote_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.User_id, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Option)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Option {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Date, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Options)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Options {

		err = _os.WriteHead(codec.LIST, 0)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v)), 0)
		if err != nil {
			return err
		}

		for _, v := range v {

			err = _os.Write_uint8(v, 0)
			if err != nil {
				return err
			}

		}
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageUserVote_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageUserVote struct implement
type TLmessageUserVote struct {
	Data MessageUserVote_Data `json:"data"`
}

func (st *TLmessageUserVote) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageUserVote) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageUserVote) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageUserVote, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageUserVote) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageUserVote) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageUserVoteInputOption struct implement
type TLmessageUserVoteInputOption struct {
	Data MessageUserVote_Data `json:"data"`
}

func (st *TLmessageUserVoteInputOption) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageUserVoteInputOption) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageUserVoteInputOption) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageUserVoteInputOption, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageUserVoteInputOption) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageUserVoteInputOption) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageUserVoteMultiple struct implement
type TLmessageUserVoteMultiple struct {
	Data MessageUserVote_Data `json:"data"`
}

func (st *TLmessageUserVoteMultiple) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageUserVoteMultiple) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageUserVoteMultiple) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageUserVoteMultiple, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageUserVoteMultiple) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageUserVoteMultiple) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputEncryptedFile struct implement
type InputEncryptedFile struct {
	Constructor int32                   `json:"constructor"`
	Data        InputEncryptedFile_Data `json:"data"`
}

func (st *InputEncryptedFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputEncryptedFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputEncryptedFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputEncryptedFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputEncryptedFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputEncryptedFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputEncryptedFile_Data struct implement
type InputEncryptedFile_Data struct {
	Id              int64  `json:"id"`
	Parts           int32  `json:"parts"`
	Md5_checksum    string `json:"md5_checksum"`
	Key_fingerprint int32  `json:"key_fingerprint"`
	Access_hash     int64  `json:"access_hash"`
}

func (st *InputEncryptedFile_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputEncryptedFile_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Parts, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Md5_checksum, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Key_fingerprint, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputEncryptedFile_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputEncryptedFile_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputEncryptedFile_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Parts, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Md5_checksum, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Key_fingerprint, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputEncryptedFile_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputEncryptedFileEmpty struct implement
type TLinputEncryptedFileEmpty struct {
	Data InputEncryptedFile_Data `json:"data"`
}

func (st *TLinputEncryptedFileEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputEncryptedFileEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputEncryptedFileEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputEncryptedFileEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputEncryptedFileEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputEncryptedFileEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputEncryptedFileUploaded struct implement
type TLinputEncryptedFileUploaded struct {
	Data InputEncryptedFile_Data `json:"data"`
}

func (st *TLinputEncryptedFileUploaded) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputEncryptedFileUploaded) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputEncryptedFileUploaded) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputEncryptedFileUploaded, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputEncryptedFileUploaded) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputEncryptedFileUploaded) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputEncryptedFile struct implement
type TLinputEncryptedFile struct {
	Data InputEncryptedFile_Data `json:"data"`
}

func (st *TLinputEncryptedFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputEncryptedFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputEncryptedFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputEncryptedFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputEncryptedFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputEncryptedFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputEncryptedFileBigUploaded struct implement
type TLinputEncryptedFileBigUploaded struct {
	Data InputEncryptedFile_Data `json:"data"`
}

func (st *TLinputEncryptedFileBigUploaded) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputEncryptedFileBigUploaded) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputEncryptedFileBigUploaded) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputEncryptedFileBigUploaded, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputEncryptedFileBigUploaded) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputEncryptedFileBigUploaded) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Payments_SavedInfo struct implement
type Payments_SavedInfo struct {
	Constructor int32                   `json:"constructor"`
	Data        Payments_SavedInfo_Data `json:"data"`
}

func (st *Payments_SavedInfo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Payments_SavedInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Payments_SavedInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Payments_SavedInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Payments_SavedInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Payments_SavedInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Payments_SavedInfo_Data struct implement
type Payments_SavedInfo_Data struct {
	Has_saved_credentials bool                 `json:"has_saved_credentials"`
	Saved_info            PaymentRequestedInfo `json:"saved_info"`
}

func (st *Payments_SavedInfo_Data) ResetDefault() {
	st.Saved_info.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Payments_SavedInfo_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Has_saved_credentials, 0, false)
	if err != nil {
		return err
	}

	err = st.Saved_info.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Payments_SavedInfo_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Payments_SavedInfo_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Payments_SavedInfo_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Has_saved_credentials, 0)
	if err != nil {
		return err
	}

	err = st.Saved_info.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Payments_SavedInfo_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpayments_savedInfo struct implement
type TLpayments_savedInfo struct {
	Data Payments_SavedInfo_Data `json:"data"`
}

func (st *TLpayments_savedInfo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpayments_savedInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpayments_savedInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpayments_savedInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpayments_savedInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpayments_savedInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PageBlock struct implement
type PageBlock struct {
	Constructor int32          `json:"constructor"`
	Data        PageBlock_Data `json:"data"`
}

func (st *PageBlock) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PageBlock) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PageBlock) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PageBlock, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PageBlock) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PageBlock) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PageBlock_Data struct implement
type PageBlock_Data struct {
	Text            RichText              `json:"text"`
	Author          RichText              `json:"author"`
	Published_date  int32                 `json:"published_date"`
	Language        string                `json:"language"`
	Name            string                `json:"name"`
	Items           []PageListItem        `json:"items"`
	Caption         RichText              `json:"caption"`
	Photo_id        int64                 `json:"photo_id"`
	Caption_9       PageCaption           `json:"caption_9"`
	Url             string                `json:"url"`
	Webpage_id      int64                 `json:"webpage_id"`
	Autoplay        bool                  `json:"autoplay"`
	Loop            bool                  `json:"loop"`
	Video_id        int64                 `json:"video_id"`
	Cover           PageBlock             `json:"cover"`
	Full_width      bool                  `json:"full_width"`
	Allow_scrolling bool                  `json:"allow_scrolling"`
	Html            string                `json:"html"`
	Poster_photo_id int64                 `json:"poster_photo_id"`
	W               int32                 `json:"w"`
	H               int32                 `json:"h"`
	Author_photo_id int64                 `json:"author_photo_id"`
	Author_23       string                `json:"author_23"`
	Date            int32                 `json:"date"`
	Blocks          []PageBlock           `json:"blocks"`
	Items_26        []PageBlock           `json:"items_26"`
	Channel         Chat                  `json:"channel"`
	Audio_id        int64                 `json:"audio_id"`
	Bordered        bool                  `json:"bordered"`
	Striped         bool                  `json:"striped"`
	Title           RichText              `json:"title"`
	Rows            []PageTableRow        `json:"rows"`
	Items_33        []PageListOrderedItem `json:"items_33"`
	Open            bool                  `json:"open"`
	Articles        []PageRelatedArticle  `json:"articles"`
	Geo             GeoPoint              `json:"geo"`
	Zoom            int32                 `json:"zoom"`
}

func (st *PageBlock_Data) ResetDefault() {
	st.Text.ResetDefault()
	st.Author.ResetDefault()
	st.Caption.ResetDefault()
	st.Caption_9.ResetDefault()
	st.Cover.ResetDefault()
	st.Channel.ResetDefault()
	st.Title.ResetDefault()
	st.Geo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PageBlock_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Text.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Author.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Published_date, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Language, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Name, 4, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Items = make([]PageListItem, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Items[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Caption.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Photo_id, 7, false)
	if err != nil {
		return err
	}

	err = st.Caption_9.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Url, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Webpage_id, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Autoplay, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Loop, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Video_id, 13, false)
	if err != nil {
		return err
	}

	err = st.Cover.ReadBlock(_is, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Full_width, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Allow_scrolling, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Html, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Poster_photo_id, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.W, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.H, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Author_photo_id, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Author_23, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 23, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(24, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Blocks = make([]PageBlock, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Blocks[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(25, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Items_26 = make([]PageBlock, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Items_26[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Channel.ReadBlock(_is, 26, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Audio_id, 27, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Bordered, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Striped, 29, false)
	if err != nil {
		return err
	}

	err = st.Title.ReadBlock(_is, 30, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(31, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Rows = make([]PageTableRow, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Rows[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(32, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Items_33 = make([]PageListOrderedItem, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = st.Items_33[i4].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_bool(&st.Open, 33, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(34, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Articles = make([]PageRelatedArticle, length)
			for i5, e5 := int32(0), length; i5 < e5; i5++ {

				err = st.Articles[i5].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Geo.ReadBlock(_is, 35, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Zoom, 36, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PageBlock_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PageBlock_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PageBlock_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Text.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Author.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Published_date, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Language, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Name, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Items)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Items {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Caption.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Photo_id, 7)
	if err != nil {
		return err
	}

	err = st.Caption_9.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Url, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Webpage_id, 10)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Autoplay, 11)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Loop, 12)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Video_id, 13)
	if err != nil {
		return err
	}

	err = st.Cover.WriteBlock(_os, 14)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Full_width, 15)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Allow_scrolling, 16)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Html, 17)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Poster_photo_id, 18)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.W, 19)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.H, 20)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Author_photo_id, 21)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Author_23, 22)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 23)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 24)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Blocks)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Blocks {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 25)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Items_26)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Items_26 {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Channel.WriteBlock(_os, 26)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Audio_id, 27)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Bordered, 28)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Striped, 29)
	if err != nil {
		return err
	}

	err = st.Title.WriteBlock(_os, 30)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 31)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Rows)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Rows {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 32)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Items_33)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Items_33 {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_bool(st.Open, 33)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 34)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Articles)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Articles {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Geo.WriteBlock(_os, 35)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Zoom, 36)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PageBlock_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockUnsupported struct implement
type TLpageBlockUnsupported struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockUnsupported) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockUnsupported) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockUnsupported) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockUnsupported, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockUnsupported) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockUnsupported) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockTitle struct implement
type TLpageBlockTitle struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockTitle) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockTitle) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockTitle) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockTitle, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockTitle) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockTitle) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockSubtitle struct implement
type TLpageBlockSubtitle struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockSubtitle) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockSubtitle) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockSubtitle) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockSubtitle, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockSubtitle) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockSubtitle) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockAuthorDate struct implement
type TLpageBlockAuthorDate struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockAuthorDate) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockAuthorDate) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockAuthorDate) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockAuthorDate, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockAuthorDate) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockAuthorDate) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockHeader struct implement
type TLpageBlockHeader struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockHeader) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockHeader) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockHeader) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockHeader, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockHeader) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockHeader) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockSubheader struct implement
type TLpageBlockSubheader struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockSubheader) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockSubheader) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockSubheader) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockSubheader, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockSubheader) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockSubheader) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockParagraph struct implement
type TLpageBlockParagraph struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockParagraph) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockParagraph) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockParagraph) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockParagraph, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockParagraph) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockParagraph) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockPreformatted struct implement
type TLpageBlockPreformatted struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockPreformatted) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockPreformatted) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockPreformatted) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockPreformatted, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockPreformatted) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockPreformatted) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockFooter struct implement
type TLpageBlockFooter struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockFooter) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockFooter) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockFooter) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockFooter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockFooter) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockFooter) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockDivider struct implement
type TLpageBlockDivider struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockDivider) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockDivider) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockDivider) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockDivider, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockDivider) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockDivider) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockAnchor struct implement
type TLpageBlockAnchor struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockAnchor) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockAnchor) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockAnchor) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockAnchor, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockAnchor) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockAnchor) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockList struct implement
type TLpageBlockList struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockList) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockList) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockList) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockList) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockList) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockBlockquote struct implement
type TLpageBlockBlockquote struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockBlockquote) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockBlockquote) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockBlockquote) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockBlockquote, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockBlockquote) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockBlockquote) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockPullquote struct implement
type TLpageBlockPullquote struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockPullquote) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockPullquote) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockPullquote) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockPullquote, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockPullquote) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockPullquote) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockPhoto struct implement
type TLpageBlockPhoto struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockPhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockVideo struct implement
type TLpageBlockVideo struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockVideo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockVideo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockVideo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockVideo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockVideo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockVideo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockCover struct implement
type TLpageBlockCover struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockCover) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockCover) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockCover) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockCover, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockCover) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockCover) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockEmbed struct implement
type TLpageBlockEmbed struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockEmbed) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockEmbed) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockEmbed) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockEmbed, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockEmbed) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockEmbed) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockEmbedPost struct implement
type TLpageBlockEmbedPost struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockEmbedPost) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockEmbedPost) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockEmbedPost) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockEmbedPost, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockEmbedPost) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockEmbedPost) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockCollage struct implement
type TLpageBlockCollage struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockCollage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockCollage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockCollage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockCollage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockCollage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockCollage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockSlideshow struct implement
type TLpageBlockSlideshow struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockSlideshow) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockSlideshow) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockSlideshow) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockSlideshow, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockSlideshow) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockSlideshow) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockChannel struct implement
type TLpageBlockChannel struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockChannel) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockChannel) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockChannel) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockChannel, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockChannel) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockChannel) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockAudio struct implement
type TLpageBlockAudio struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockAudio) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockAudio) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockAudio) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockAudio, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockAudio) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockAudio) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockKicker struct implement
type TLpageBlockKicker struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockKicker) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockKicker) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockKicker) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockKicker, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockKicker) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockKicker) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockTable struct implement
type TLpageBlockTable struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockTable) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockTable) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockTable) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockTable, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockTable) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockTable) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockOrderedList struct implement
type TLpageBlockOrderedList struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockOrderedList) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockOrderedList) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockOrderedList) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockOrderedList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockOrderedList) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockOrderedList) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockDetails struct implement
type TLpageBlockDetails struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockDetails) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockDetails) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockDetails) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockDetails, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockDetails) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockDetails) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockRelatedArticles struct implement
type TLpageBlockRelatedArticles struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockRelatedArticles) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockRelatedArticles) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockRelatedArticles) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockRelatedArticles, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockRelatedArticles) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockRelatedArticles) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageBlockMap struct implement
type TLpageBlockMap struct {
	Data PageBlock_Data `json:"data"`
}

func (st *TLpageBlockMap) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageBlockMap) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageBlockMap) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageBlockMap, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageBlockMap) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageBlockMap) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageAction struct implement
type MessageAction struct {
	Constructor int32              `json:"constructor"`
	Data        MessageAction_Data `json:"data"`
}

func (st *MessageAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageAction_Data struct implement
type MessageAction_Data struct {
	Title              string                     `json:"title"`
	Users              []int32                    `json:"users"`
	Photo              Photo                      `json:"photo"`
	User_id            int32                      `json:"user_id"`
	Inviter_id         int32                      `json:"inviter_id"`
	Channel_id         int32                      `json:"channel_id"`
	Chat_id            int32                      `json:"chat_id"`
	Game_id            int64                      `json:"game_id"`
	Score              int32                      `json:"score"`
	Currency           string                     `json:"currency"`
	Total_amount       int64                      `json:"total_amount"`
	Payload            []uint8                    `json:"payload"`
	Info               PaymentRequestedInfo       `json:"info"`
	Shipping_option_id string                     `json:"shipping_option_id"`
	Charge             PaymentCharge              `json:"charge"`
	Video              bool                       `json:"video"`
	Call_id            int64                      `json:"call_id"`
	Reason             PhoneCallDiscardReason     `json:"reason"`
	Duration           int32                      `json:"duration"`
	Message            string                     `json:"message"`
	Domain             string                     `json:"domain"`
	Values             []SecureValue              `json:"values"`
	Credentials        SecureCredentialsEncrypted `json:"credentials"`
	Types              []SecureValueType          `json:"types"`
	From_id            Peer                       `json:"from_id"`
	To_id              Peer                       `json:"to_id"`
	Distance           int32                      `json:"distance"`
}

func (st *MessageAction_Data) ResetDefault() {
	st.Photo.ResetDefault()
	st.Info.ResetDefault()
	st.Charge.ResetDefault()
	st.Reason.ResetDefault()
	st.Credentials.ResetDefault()
	st.From_id.ResetDefault()
	st.To_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageAction_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Title, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Users[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Photo.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.User_id, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Inviter_id, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Channel_id, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Chat_id, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Game_id, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Score, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Currency, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Total_amount, 10, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(11, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Payload = make([]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_uint8(&st.Payload[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Payload, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Info.ReadBlock(_is, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Shipping_option_id, 13, false)
	if err != nil {
		return err
	}

	err = st.Charge.ReadBlock(_is, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Video, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Call_id, 16, false)
	if err != nil {
		return err
	}

	err = st.Reason.ReadBlock(_is, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Duration, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Domain, 20, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(21, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Values = make([]SecureValue, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Values[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Credentials.ReadBlock(_is, 22, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(23, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Types = make([]SecureValueType, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Types[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.From_id.ReadBlock(_is, 24, false)
	if err != nil {
		return err
	}

	err = st.To_id.ReadBlock(_is, 25, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Distance, 26, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageAction_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageAction_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageAction_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Title, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	err = st.Photo.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.User_id, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Inviter_id, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Channel_id, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Chat_id, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Game_id, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Score, 8)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Currency, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Total_amount, 10)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Payload)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Payload {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = st.Info.WriteBlock(_os, 12)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Shipping_option_id, 13)
	if err != nil {
		return err
	}

	err = st.Charge.WriteBlock(_os, 14)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Video, 15)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Call_id, 16)
	if err != nil {
		return err
	}

	err = st.Reason.WriteBlock(_os, 17)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Duration, 18)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 19)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Domain, 20)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 21)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Values)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Values {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Credentials.WriteBlock(_os, 22)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 23)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Types)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Types {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.From_id.WriteBlock(_os, 24)
	if err != nil {
		return err
	}

	err = st.To_id.WriteBlock(_os, 25)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Distance, 26)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageAction_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionEmpty struct implement
type TLmessageActionEmpty struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionChatCreate struct implement
type TLmessageActionChatCreate struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionChatCreate) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionChatCreate) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionChatCreate) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionChatCreate, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionChatCreate) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionChatCreate) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionChatEditTitle struct implement
type TLmessageActionChatEditTitle struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionChatEditTitle) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionChatEditTitle) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionChatEditTitle) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionChatEditTitle, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionChatEditTitle) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionChatEditTitle) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionChatEditPhoto struct implement
type TLmessageActionChatEditPhoto struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionChatEditPhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionChatEditPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionChatEditPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionChatEditPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionChatEditPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionChatEditPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionChatDeletePhoto struct implement
type TLmessageActionChatDeletePhoto struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionChatDeletePhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionChatDeletePhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionChatDeletePhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionChatDeletePhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionChatDeletePhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionChatDeletePhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionChatAddUser struct implement
type TLmessageActionChatAddUser struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionChatAddUser) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionChatAddUser) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionChatAddUser) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionChatAddUser, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionChatAddUser) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionChatAddUser) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionChatDeleteUser struct implement
type TLmessageActionChatDeleteUser struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionChatDeleteUser) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionChatDeleteUser) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionChatDeleteUser) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionChatDeleteUser, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionChatDeleteUser) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionChatDeleteUser) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionChatJoinedByLink struct implement
type TLmessageActionChatJoinedByLink struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionChatJoinedByLink) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionChatJoinedByLink) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionChatJoinedByLink) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionChatJoinedByLink, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionChatJoinedByLink) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionChatJoinedByLink) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionChannelCreate struct implement
type TLmessageActionChannelCreate struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionChannelCreate) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionChannelCreate) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionChannelCreate) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionChannelCreate, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionChannelCreate) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionChannelCreate) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionChatMigrateTo struct implement
type TLmessageActionChatMigrateTo struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionChatMigrateTo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionChatMigrateTo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionChatMigrateTo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionChatMigrateTo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionChatMigrateTo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionChatMigrateTo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionChannelMigrateFrom struct implement
type TLmessageActionChannelMigrateFrom struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionChannelMigrateFrom) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionChannelMigrateFrom) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionChannelMigrateFrom) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionChannelMigrateFrom, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionChannelMigrateFrom) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionChannelMigrateFrom) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionPinMessage struct implement
type TLmessageActionPinMessage struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionPinMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionPinMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionPinMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionPinMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionPinMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionPinMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionHistoryClear struct implement
type TLmessageActionHistoryClear struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionHistoryClear) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionHistoryClear) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionHistoryClear) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionHistoryClear, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionHistoryClear) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionHistoryClear) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionGameScore struct implement
type TLmessageActionGameScore struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionGameScore) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionGameScore) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionGameScore) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionGameScore, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionGameScore) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionGameScore) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionPaymentSentMe struct implement
type TLmessageActionPaymentSentMe struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionPaymentSentMe) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionPaymentSentMe) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionPaymentSentMe) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionPaymentSentMe, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionPaymentSentMe) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionPaymentSentMe) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionPaymentSent struct implement
type TLmessageActionPaymentSent struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionPaymentSent) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionPaymentSent) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionPaymentSent) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionPaymentSent, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionPaymentSent) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionPaymentSent) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionPhoneCall struct implement
type TLmessageActionPhoneCall struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionPhoneCall) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionPhoneCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionPhoneCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionPhoneCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionPhoneCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionPhoneCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionScreenshotTaken struct implement
type TLmessageActionScreenshotTaken struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionScreenshotTaken) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionScreenshotTaken) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionScreenshotTaken) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionScreenshotTaken, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionScreenshotTaken) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionScreenshotTaken) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionCustomAction struct implement
type TLmessageActionCustomAction struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionCustomAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionCustomAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionCustomAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionCustomAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionCustomAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionCustomAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionBotAllowed struct implement
type TLmessageActionBotAllowed struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionBotAllowed) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionBotAllowed) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionBotAllowed) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionBotAllowed, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionBotAllowed) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionBotAllowed) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionSecureValuesSentMe struct implement
type TLmessageActionSecureValuesSentMe struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionSecureValuesSentMe) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionSecureValuesSentMe) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionSecureValuesSentMe) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionSecureValuesSentMe, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionSecureValuesSentMe) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionSecureValuesSentMe) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionSecureValuesSent struct implement
type TLmessageActionSecureValuesSent struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionSecureValuesSent) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionSecureValuesSent) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionSecureValuesSent) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionSecureValuesSent, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionSecureValuesSent) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionSecureValuesSent) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionContactSignUp struct implement
type TLmessageActionContactSignUp struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionContactSignUp) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionContactSignUp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionContactSignUp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionContactSignUp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionContactSignUp) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionContactSignUp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageActionGeoProximityReached struct implement
type TLmessageActionGeoProximityReached struct {
	Data MessageAction_Data `json:"data"`
}

func (st *TLmessageActionGeoProximityReached) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageActionGeoProximityReached) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageActionGeoProximityReached) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageActionGeoProximityReached, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageActionGeoProximityReached) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageActionGeoProximityReached) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SavedContact struct implement
type SavedContact struct {
	Constructor int32             `json:"constructor"`
	Data        SavedContact_Data `json:"data"`
}

func (st *SavedContact) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SavedContact) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SavedContact) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SavedContact, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SavedContact) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SavedContact) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SavedContact_Data struct implement
type SavedContact_Data struct {
	Phone      string `json:"phone"`
	First_name string `json:"first_name"`
	Last_name  string `json:"last_name"`
	Date       int32  `json:"date"`
}

func (st *SavedContact_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *SavedContact_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Phone, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.First_name, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Last_name, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SavedContact_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SavedContact_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SavedContact_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Phone, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.First_name, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Last_name, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SavedContact_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsavedPhoneContact struct implement
type TLsavedPhoneContact struct {
	Data SavedContact_Data `json:"data"`
}

func (st *TLsavedPhoneContact) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsavedPhoneContact) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsavedPhoneContact) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsavedPhoneContact, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsavedPhoneContact) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsavedPhoneContact) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputCheckPasswordSRP struct implement
type InputCheckPasswordSRP struct {
	Constructor int32                      `json:"constructor"`
	Data        InputCheckPasswordSRP_Data `json:"data"`
}

func (st *InputCheckPasswordSRP) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputCheckPasswordSRP) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputCheckPasswordSRP) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputCheckPasswordSRP, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputCheckPasswordSRP) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputCheckPasswordSRP) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputCheckPasswordSRP_Data struct implement
type InputCheckPasswordSRP_Data struct {
	Srp_id int64   `json:"srp_id"`
	A      []uint8 `json:"A"`
	M1     []uint8 `json:"M1"`
}

func (st *InputCheckPasswordSRP_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputCheckPasswordSRP_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Srp_id, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.A = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.A[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.A, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.M1 = make([]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_uint8(&st.M1[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.M1, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputCheckPasswordSRP_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputCheckPasswordSRP_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputCheckPasswordSRP_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Srp_id, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.A)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.A {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.M1)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.M1 {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputCheckPasswordSRP_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputCheckPasswordEmpty struct implement
type TLinputCheckPasswordEmpty struct {
	Data InputCheckPasswordSRP_Data `json:"data"`
}

func (st *TLinputCheckPasswordEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputCheckPasswordEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputCheckPasswordEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputCheckPasswordEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputCheckPasswordEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputCheckPasswordEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputCheckPasswordSRP struct implement
type TLinputCheckPasswordSRP struct {
	Data InputCheckPasswordSRP_Data `json:"data"`
}

func (st *TLinputCheckPasswordSRP) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputCheckPasswordSRP) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputCheckPasswordSRP) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputCheckPasswordSRP, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputCheckPasswordSRP) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputCheckPasswordSRP) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputPeer struct implement
type InputPeer struct {
	Constructor int32          `json:"constructor"`
	Data        InputPeer_Data `json:"data"`
}

func (st *InputPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputPeer_Data struct implement
type InputPeer_Data struct {
	Chat_id     int32     `json:"chat_id"`
	User_id     int32     `json:"user_id"`
	Access_hash int64     `json:"access_hash"`
	Channel_id  int32     `json:"channel_id"`
	Peer        InputPeer `json:"peer"`
	Msg_id      int32     `json:"msg_id"`
}

func (st *InputPeer_Data) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputPeer_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Chat_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.User_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Channel_id, 3, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Msg_id, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputPeer_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputPeer_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputPeer_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Chat_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.User_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Channel_id, 3)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Msg_id, 5)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputPeer_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPeerEmpty struct implement
type TLinputPeerEmpty struct {
	Data InputPeer_Data `json:"data"`
}

func (st *TLinputPeerEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPeerEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPeerEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPeerEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPeerEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPeerEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPeerSelf struct implement
type TLinputPeerSelf struct {
	Data InputPeer_Data `json:"data"`
}

func (st *TLinputPeerSelf) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPeerSelf) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPeerSelf) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPeerSelf, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPeerSelf) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPeerSelf) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPeerChat struct implement
type TLinputPeerChat struct {
	Data InputPeer_Data `json:"data"`
}

func (st *TLinputPeerChat) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPeerChat) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPeerChat) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPeerChat, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPeerChat) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPeerChat) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPeerUser struct implement
type TLinputPeerUser struct {
	Data InputPeer_Data `json:"data"`
}

func (st *TLinputPeerUser) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPeerUser) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPeerUser) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPeerUser, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPeerUser) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPeerUser) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPeerChannel struct implement
type TLinputPeerChannel struct {
	Data InputPeer_Data `json:"data"`
}

func (st *TLinputPeerChannel) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPeerChannel) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPeerChannel) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPeerChannel, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPeerChannel) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPeerChannel) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPeerUserFromMessage struct implement
type TLinputPeerUserFromMessage struct {
	Data InputPeer_Data `json:"data"`
}

func (st *TLinputPeerUserFromMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPeerUserFromMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPeerUserFromMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPeerUserFromMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPeerUserFromMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPeerUserFromMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPeerChannelFromMessage struct implement
type TLinputPeerChannelFromMessage struct {
	Data InputPeer_Data `json:"data"`
}

func (st *TLinputPeerChannelFromMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPeerChannelFromMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPeerChannelFromMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPeerChannelFromMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPeerChannelFromMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPeerChannelFromMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Peer struct implement
type Peer struct {
	Constructor int32     `json:"constructor"`
	Data        Peer_Data `json:"data"`
}

func (st *Peer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Peer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Peer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Peer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Peer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Peer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Peer_Data struct implement
type Peer_Data struct {
	User_id    int32 `json:"user_id"`
	Chat_id    int32 `json:"chat_id"`
	Channel_id int32 `json:"channel_id"`
}

func (st *Peer_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Peer_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Chat_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Channel_id, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Peer_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Peer_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Peer_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.User_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Chat_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Channel_id, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Peer_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpeerUser struct implement
type TLpeerUser struct {
	Data Peer_Data `json:"data"`
}

func (st *TLpeerUser) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpeerUser) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpeerUser) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpeerUser, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpeerUser) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpeerUser) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpeerChat struct implement
type TLpeerChat struct {
	Data Peer_Data `json:"data"`
}

func (st *TLpeerChat) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpeerChat) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpeerChat) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpeerChat, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpeerChat) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpeerChat) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpeerChannel struct implement
type TLpeerChannel struct {
	Data Peer_Data `json:"data"`
}

func (st *TLpeerChannel) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpeerChannel) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpeerChannel) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpeerChannel, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpeerChannel) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpeerChannel) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Auth_SentCodeType struct implement
type Auth_SentCodeType struct {
	Constructor int32                  `json:"constructor"`
	Data        Auth_SentCodeType_Data `json:"data"`
}

func (st *Auth_SentCodeType) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Auth_SentCodeType) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Auth_SentCodeType) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Auth_SentCodeType, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Auth_SentCodeType) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Auth_SentCodeType) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Auth_SentCodeType_Data struct implement
type Auth_SentCodeType_Data struct {
	Length  int32  `json:"length"`
	Pattern string `json:"pattern"`
}

func (st *Auth_SentCodeType_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Auth_SentCodeType_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Length, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Pattern, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Auth_SentCodeType_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Auth_SentCodeType_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Auth_SentCodeType_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Length, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Pattern, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Auth_SentCodeType_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_sentCodeTypeApp struct implement
type TLauth_sentCodeTypeApp struct {
	Data Auth_SentCodeType_Data `json:"data"`
}

func (st *TLauth_sentCodeTypeApp) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_sentCodeTypeApp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_sentCodeTypeApp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_sentCodeTypeApp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_sentCodeTypeApp) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_sentCodeTypeApp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_sentCodeTypeSms struct implement
type TLauth_sentCodeTypeSms struct {
	Data Auth_SentCodeType_Data `json:"data"`
}

func (st *TLauth_sentCodeTypeSms) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_sentCodeTypeSms) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_sentCodeTypeSms) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_sentCodeTypeSms, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_sentCodeTypeSms) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_sentCodeTypeSms) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_sentCodeTypeCall struct implement
type TLauth_sentCodeTypeCall struct {
	Data Auth_SentCodeType_Data `json:"data"`
}

func (st *TLauth_sentCodeTypeCall) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_sentCodeTypeCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_sentCodeTypeCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_sentCodeTypeCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_sentCodeTypeCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_sentCodeTypeCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_sentCodeTypeFlashCall struct implement
type TLauth_sentCodeTypeFlashCall struct {
	Data Auth_SentCodeType_Data `json:"data"`
}

func (st *TLauth_sentCodeTypeFlashCall) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_sentCodeTypeFlashCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_sentCodeTypeFlashCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_sentCodeTypeFlashCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_sentCodeTypeFlashCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_sentCodeTypeFlashCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StatsURL struct implement
type StatsURL struct {
	Constructor int32         `json:"constructor"`
	Data        StatsURL_Data `json:"data"`
}

func (st *StatsURL) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *StatsURL) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StatsURL) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StatsURL, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StatsURL) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StatsURL) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StatsURL_Data struct implement
type StatsURL_Data struct {
	Url string `json:"url"`
}

func (st *StatsURL_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *StatsURL_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Url, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StatsURL_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StatsURL_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StatsURL_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Url, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StatsURL_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstatsURL struct implement
type TLstatsURL struct {
	Data StatsURL_Data `json:"data"`
}

func (st *TLstatsURL) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstatsURL) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstatsURL) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstatsURL, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstatsURL) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstatsURL) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Channels_ChannelParticipants struct implement
type Channels_ChannelParticipants struct {
	Constructor int32                             `json:"constructor"`
	Data        Channels_ChannelParticipants_Data `json:"data"`
}

func (st *Channels_ChannelParticipants) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Channels_ChannelParticipants) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Channels_ChannelParticipants) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Channels_ChannelParticipants, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Channels_ChannelParticipants) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Channels_ChannelParticipants) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Channels_ChannelParticipants_Data struct implement
type Channels_ChannelParticipants_Data struct {
	Count        int32                `json:"count"`
	Participants []ChannelParticipant `json:"participants"`
	Users        []User               `json:"users"`
}

func (st *Channels_ChannelParticipants_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Channels_ChannelParticipants_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Count, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Participants = make([]ChannelParticipant, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Participants[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Users[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Channels_ChannelParticipants_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Channels_ChannelParticipants_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Channels_ChannelParticipants_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Count, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Participants)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Participants {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Channels_ChannelParticipants_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_channelParticipants struct implement
type TLchannels_channelParticipants struct {
	Data Channels_ChannelParticipants_Data `json:"data"`
}

func (st *TLchannels_channelParticipants) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_channelParticipants) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_channelParticipants) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_channelParticipants, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_channelParticipants) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_channelParticipants) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_channelParticipantsNotModified struct implement
type TLchannels_channelParticipantsNotModified struct {
	Data Channels_ChannelParticipants_Data `json:"data"`
}

func (st *TLchannels_channelParticipantsNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_channelParticipantsNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_channelParticipantsNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_channelParticipantsNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_channelParticipantsNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_channelParticipantsNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Phone_PhoneCall struct implement
type Phone_PhoneCall struct {
	Constructor int32                `json:"constructor"`
	Data        Phone_PhoneCall_Data `json:"data"`
}

func (st *Phone_PhoneCall) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Phone_PhoneCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Phone_PhoneCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Phone_PhoneCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Phone_PhoneCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Phone_PhoneCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Phone_PhoneCall_Data struct implement
type Phone_PhoneCall_Data struct {
	Phone_call PhoneCall `json:"phone_call"`
	Users      []User    `json:"users"`
}

func (st *Phone_PhoneCall_Data) ResetDefault() {
	st.Phone_call.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Phone_PhoneCall_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Phone_call.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Users[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Phone_PhoneCall_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Phone_PhoneCall_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Phone_PhoneCall_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Phone_call.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Phone_PhoneCall_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphone_phoneCall struct implement
type TLphone_phoneCall struct {
	Data Phone_PhoneCall_Data `json:"data"`
}

func (st *TLphone_phoneCall) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphone_phoneCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphone_phoneCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphone_phoneCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphone_phoneCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphone_phoneCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PaymentSavedCredentials struct implement
type PaymentSavedCredentials struct {
	Constructor int32                        `json:"constructor"`
	Data        PaymentSavedCredentials_Data `json:"data"`
}

func (st *PaymentSavedCredentials) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PaymentSavedCredentials) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PaymentSavedCredentials) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PaymentSavedCredentials, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PaymentSavedCredentials) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PaymentSavedCredentials) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PaymentSavedCredentials_Data struct implement
type PaymentSavedCredentials_Data struct {
	Id    string `json:"id"`
	Title string `json:"title"`
}

func (st *PaymentSavedCredentials_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *PaymentSavedCredentials_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PaymentSavedCredentials_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PaymentSavedCredentials_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PaymentSavedCredentials_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PaymentSavedCredentials_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpaymentSavedCredentialsCard struct implement
type TLpaymentSavedCredentialsCard struct {
	Data PaymentSavedCredentials_Data `json:"data"`
}

func (st *TLpaymentSavedCredentialsCard) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpaymentSavedCredentialsCard) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpaymentSavedCredentialsCard) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpaymentSavedCredentialsCard, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpaymentSavedCredentialsCard) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpaymentSavedCredentialsCard) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// EmojiKeyword struct implement
type EmojiKeyword struct {
	Constructor int32             `json:"constructor"`
	Data        EmojiKeyword_Data `json:"data"`
}

func (st *EmojiKeyword) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *EmojiKeyword) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *EmojiKeyword) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EmojiKeyword, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *EmojiKeyword) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *EmojiKeyword) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// EmojiKeyword_Data struct implement
type EmojiKeyword_Data struct {
	Keyword   string   `json:"keyword"`
	Emoticons []string `json:"emoticons"`
}

func (st *EmojiKeyword_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *EmojiKeyword_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Keyword, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Emoticons = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_string(&st.Emoticons[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *EmojiKeyword_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EmojiKeyword_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *EmojiKeyword_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Keyword, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Emoticons)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Emoticons {

		err = _os.Write_string(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *EmojiKeyword_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLemojiKeyword struct implement
type TLemojiKeyword struct {
	Data EmojiKeyword_Data `json:"data"`
}

func (st *TLemojiKeyword) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLemojiKeyword) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLemojiKeyword) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLemojiKeyword, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLemojiKeyword) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLemojiKeyword) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLemojiKeywordDeleted struct implement
type TLemojiKeywordDeleted struct {
	Data EmojiKeyword_Data `json:"data"`
}

func (st *TLemojiKeywordDeleted) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLemojiKeywordDeleted) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLemojiKeywordDeleted) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLemojiKeywordDeleted, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLemojiKeywordDeleted) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLemojiKeywordDeleted) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Contacts_ImportedContacts struct implement
type Contacts_ImportedContacts struct {
	Constructor int32                          `json:"constructor"`
	Data        Contacts_ImportedContacts_Data `json:"data"`
}

func (st *Contacts_ImportedContacts) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Contacts_ImportedContacts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Contacts_ImportedContacts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Contacts_ImportedContacts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Contacts_ImportedContacts) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Contacts_ImportedContacts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Contacts_ImportedContacts_Data struct implement
type Contacts_ImportedContacts_Data struct {
	Imported        []ImportedContact `json:"imported"`
	Popular_invites []PopularContact  `json:"popular_invites"`
	Retry_contacts  []int64           `json:"retry_contacts"`
	Users           []User            `json:"users"`
}

func (st *Contacts_ImportedContacts_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Contacts_ImportedContacts_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Imported = make([]ImportedContact, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Imported[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Popular_invites = make([]PopularContact, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Popular_invites[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Retry_contacts = make([]int64, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = _is.Read_int64(&st.Retry_contacts[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Users[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Contacts_ImportedContacts_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Contacts_ImportedContacts_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Contacts_ImportedContacts_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Imported)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Imported {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Popular_invites)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Popular_invites {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Retry_contacts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Retry_contacts {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Contacts_ImportedContacts_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_importedContacts struct implement
type TLcontacts_importedContacts struct {
	Data Contacts_ImportedContacts_Data `json:"data"`
}

func (st *TLcontacts_importedContacts) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_importedContacts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_importedContacts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_importedContacts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_importedContacts) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_importedContacts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ReplyMarkup struct implement
type ReplyMarkup struct {
	Constructor int32            `json:"constructor"`
	Data        ReplyMarkup_Data `json:"data"`
}

func (st *ReplyMarkup) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ReplyMarkup) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ReplyMarkup) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ReplyMarkup, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ReplyMarkup) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ReplyMarkup) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ReplyMarkup_Data struct implement
type ReplyMarkup_Data struct {
	Selective  bool                `json:"selective"`
	Single_use bool                `json:"single_use"`
	Resize     bool                `json:"resize"`
	Rows       []KeyboardButtonRow `json:"rows"`
}

func (st *ReplyMarkup_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *ReplyMarkup_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Selective, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Single_use, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Resize, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Rows = make([]KeyboardButtonRow, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Rows[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ReplyMarkup_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ReplyMarkup_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ReplyMarkup_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Selective, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Single_use, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Resize, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Rows)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Rows {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ReplyMarkup_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLreplyKeyboardHide struct implement
type TLreplyKeyboardHide struct {
	Data ReplyMarkup_Data `json:"data"`
}

func (st *TLreplyKeyboardHide) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLreplyKeyboardHide) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLreplyKeyboardHide) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLreplyKeyboardHide, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLreplyKeyboardHide) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLreplyKeyboardHide) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLreplyKeyboardForceReply struct implement
type TLreplyKeyboardForceReply struct {
	Data ReplyMarkup_Data `json:"data"`
}

func (st *TLreplyKeyboardForceReply) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLreplyKeyboardForceReply) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLreplyKeyboardForceReply) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLreplyKeyboardForceReply, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLreplyKeyboardForceReply) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLreplyKeyboardForceReply) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLreplyKeyboardMarkup struct implement
type TLreplyKeyboardMarkup struct {
	Data ReplyMarkup_Data `json:"data"`
}

func (st *TLreplyKeyboardMarkup) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLreplyKeyboardMarkup) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLreplyKeyboardMarkup) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLreplyKeyboardMarkup, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLreplyKeyboardMarkup) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLreplyKeyboardMarkup) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLreplyInlineMarkup struct implement
type TLreplyInlineMarkup struct {
	Data ReplyMarkup_Data `json:"data"`
}

func (st *TLreplyInlineMarkup) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLreplyInlineMarkup) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLreplyInlineMarkup) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLreplyInlineMarkup, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLreplyInlineMarkup) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLreplyInlineMarkup) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// VideoSize struct implement
type VideoSize struct {
	Constructor int32          `json:"constructor"`
	Data        VideoSize_Data `json:"data"`
}

func (st *VideoSize) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *VideoSize) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *VideoSize) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require VideoSize, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *VideoSize) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *VideoSize) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// VideoSize_Data struct implement
type VideoSize_Data struct {
	Type           string       `json:"type"`
	Location       FileLocation `json:"location"`
	W              int32        `json:"w"`
	H              int32        `json:"h"`
	Size           int32        `json:"size"`
	Video_start_ts float64      `json:"video_start_ts"`
}

func (st *VideoSize_Data) ResetDefault() {
	st.Location.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *VideoSize_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Type, 0, false)
	if err != nil {
		return err
	}

	err = st.Location.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.W, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.H, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Size, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Video_start_ts, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *VideoSize_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require VideoSize_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *VideoSize_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Type, 0)
	if err != nil {
		return err
	}

	err = st.Location.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.W, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.H, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Size, 4)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Video_start_ts, 5)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *VideoSize_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLvideoSize struct implement
type TLvideoSize struct {
	Data VideoSize_Data `json:"data"`
}

func (st *TLvideoSize) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLvideoSize) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLvideoSize) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLvideoSize, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLvideoSize) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLvideoSize) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Folder struct implement
type Folder struct {
	Constructor int32       `json:"constructor"`
	Data        Folder_Data `json:"data"`
}

func (st *Folder) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Folder) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Folder) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Folder, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Folder) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Folder) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Folder_Data struct implement
type Folder_Data struct {
	Autofill_new_broadcasts     bool      `json:"autofill_new_broadcasts"`
	Autofill_public_groups      bool      `json:"autofill_public_groups"`
	Autofill_new_correspondents bool      `json:"autofill_new_correspondents"`
	Id                          int32     `json:"id"`
	Title                       string    `json:"title"`
	Photo                       ChatPhoto `json:"photo"`
}

func (st *Folder_Data) ResetDefault() {
	st.Photo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Folder_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Autofill_new_broadcasts, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Autofill_public_groups, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Autofill_new_correspondents, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Id, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 4, false)
	if err != nil {
		return err
	}

	err = st.Photo.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Folder_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Folder_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Folder_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Autofill_new_broadcasts, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Autofill_public_groups, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Autofill_new_correspondents, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Id, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 4)
	if err != nil {
		return err
	}

	err = st.Photo.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Folder_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLfolder struct implement
type TLfolder struct {
	Data Folder_Data `json:"data"`
}

func (st *TLfolder) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLfolder) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLfolder) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLfolder, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLfolder) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLfolder) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PageTableRow struct implement
type PageTableRow struct {
	Constructor int32             `json:"constructor"`
	Data        PageTableRow_Data `json:"data"`
}

func (st *PageTableRow) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PageTableRow) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PageTableRow) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PageTableRow, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PageTableRow) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PageTableRow) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PageTableRow_Data struct implement
type PageTableRow_Data struct {
	Cells []PageTableCell `json:"cells"`
}

func (st *PageTableRow_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *PageTableRow_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Cells = make([]PageTableCell, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Cells[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PageTableRow_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PageTableRow_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PageTableRow_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Cells)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Cells {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PageTableRow_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageTableRow struct implement
type TLpageTableRow struct {
	Data PageTableRow_Data `json:"data"`
}

func (st *TLpageTableRow) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageTableRow) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageTableRow) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageTableRow, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageTableRow) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageTableRow) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputGame struct implement
type InputGame struct {
	Constructor int32          `json:"constructor"`
	Data        InputGame_Data `json:"data"`
}

func (st *InputGame) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputGame) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputGame) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputGame, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputGame) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputGame) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputGame_Data struct implement
type InputGame_Data struct {
	Id          int64     `json:"id"`
	Access_hash int64     `json:"access_hash"`
	Bot_id      InputUser `json:"bot_id"`
	Short_name  string    `json:"short_name"`
}

func (st *InputGame_Data) ResetDefault() {
	st.Bot_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputGame_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	err = st.Bot_id.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Short_name, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputGame_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputGame_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputGame_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	err = st.Bot_id.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Short_name, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputGame_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputGameID struct implement
type TLinputGameID struct {
	Data InputGame_Data `json:"data"`
}

func (st *TLinputGameID) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputGameID) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputGameID) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputGameID, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputGameID) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputGameID) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputGameShortName struct implement
type TLinputGameShortName struct {
	Data InputGame_Data `json:"data"`
}

func (st *TLinputGameShortName) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputGameShortName) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputGameShortName) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputGameShortName, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputGameShortName) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputGameShortName) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_PeerDialogs struct implement
type Messages_PeerDialogs struct {
	Constructor int32                     `json:"constructor"`
	Data        Messages_PeerDialogs_Data `json:"data"`
}

func (st *Messages_PeerDialogs) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_PeerDialogs) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_PeerDialogs) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_PeerDialogs, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_PeerDialogs) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_PeerDialogs) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_PeerDialogs_Data struct implement
type Messages_PeerDialogs_Data struct {
	Dialogs  []Dialog      `json:"dialogs"`
	Messages []Message     `json:"messages"`
	Chats    []Chat        `json:"chats"`
	Users    []User        `json:"users"`
	State    Updates_State `json:"state"`
}

func (st *Messages_PeerDialogs_Data) ResetDefault() {
	st.State.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_PeerDialogs_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Dialogs = make([]Dialog, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Dialogs[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Messages = make([]Message, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Messages[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Chats[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Users[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.State.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_PeerDialogs_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_PeerDialogs_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_PeerDialogs_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Dialogs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Dialogs {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Messages)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Messages {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.State.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_PeerDialogs_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_peerDialogs struct implement
type TLmessages_peerDialogs struct {
	Data Messages_PeerDialogs_Data `json:"data"`
}

func (st *TLmessages_peerDialogs) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_peerDialogs) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_peerDialogs) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_peerDialogs, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_peerDialogs) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_peerDialogs) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChatParticipant struct implement
type ChatParticipant struct {
	Constructor int32                `json:"constructor"`
	Data        ChatParticipant_Data `json:"data"`
}

func (st *ChatParticipant) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChatParticipant) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChatParticipant) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChatParticipant, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChatParticipant) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChatParticipant) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChatParticipant_Data struct implement
type ChatParticipant_Data struct {
	User_id    int32 `json:"user_id"`
	Inviter_id int32 `json:"inviter_id"`
	Date       int32 `json:"date"`
}

func (st *ChatParticipant_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *ChatParticipant_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Inviter_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChatParticipant_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChatParticipant_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChatParticipant_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.User_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Inviter_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChatParticipant_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatParticipant struct implement
type TLchatParticipant struct {
	Data ChatParticipant_Data `json:"data"`
}

func (st *TLchatParticipant) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatParticipant) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatParticipant) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatParticipant, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatParticipant) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatParticipant) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatParticipantCreator struct implement
type TLchatParticipantCreator struct {
	Data ChatParticipant_Data `json:"data"`
}

func (st *TLchatParticipantCreator) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatParticipantCreator) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatParticipantCreator) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatParticipantCreator, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatParticipantCreator) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatParticipantCreator) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatParticipantAdmin struct implement
type TLchatParticipantAdmin struct {
	Data ChatParticipant_Data `json:"data"`
}

func (st *TLchatParticipantAdmin) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatParticipantAdmin) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatParticipantAdmin) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatParticipantAdmin, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatParticipantAdmin) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatParticipantAdmin) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputChannel struct implement
type InputChannel struct {
	Constructor int32             `json:"constructor"`
	Data        InputChannel_Data `json:"data"`
}

func (st *InputChannel) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputChannel) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputChannel) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputChannel, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputChannel) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputChannel) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputChannel_Data struct implement
type InputChannel_Data struct {
	Channel_id  int32     `json:"channel_id"`
	Access_hash int64     `json:"access_hash"`
	Peer        InputPeer `json:"peer"`
	Msg_id      int32     `json:"msg_id"`
}

func (st *InputChannel_Data) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputChannel_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Channel_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Msg_id, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputChannel_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputChannel_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputChannel_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Channel_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Msg_id, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputChannel_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputChannelEmpty struct implement
type TLinputChannelEmpty struct {
	Data InputChannel_Data `json:"data"`
}

func (st *TLinputChannelEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputChannelEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputChannelEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputChannelEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputChannelEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputChannelEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputChannel struct implement
type TLinputChannel struct {
	Data InputChannel_Data `json:"data"`
}

func (st *TLinputChannel) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputChannel) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputChannel) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputChannel, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputChannel) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputChannel) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputChannelFromMessage struct implement
type TLinputChannelFromMessage struct {
	Data InputChannel_Data `json:"data"`
}

func (st *TLinputChannelFromMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputChannelFromMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputChannelFromMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputChannelFromMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputChannelFromMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputChannelFromMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureValueHash struct implement
type SecureValueHash struct {
	Constructor int32                `json:"constructor"`
	Data        SecureValueHash_Data `json:"data"`
}

func (st *SecureValueHash) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureValueHash) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureValueHash) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureValueHash, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureValueHash) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureValueHash) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureValueHash_Data struct implement
type SecureValueHash_Data struct {
	Type SecureValueType `json:"type"`
	Hash []uint8         `json:"hash"`
}

func (st *SecureValueHash_Data) ResetDefault() {
	st.Type.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureValueHash_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Type.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Hash = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Hash[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Hash, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureValueHash_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureValueHash_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureValueHash_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Type.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Hash)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Hash {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureValueHash_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueHash struct implement
type TLsecureValueHash struct {
	Data SecureValueHash_Data `json:"data"`
}

func (st *TLsecureValueHash) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueHash) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueHash) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueHash, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueHash) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueHash) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Poll struct implement
type Poll struct {
	Constructor int32     `json:"constructor"`
	Data        Poll_Data `json:"data"`
}

func (st *Poll) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Poll) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Poll) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Poll, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Poll) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Poll) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Poll_Data struct implement
type Poll_Data struct {
	Id              int64        `json:"id"`
	Closed          bool         `json:"closed"`
	Public_voters   bool         `json:"public_voters"`
	Multiple_choice bool         `json:"multiple_choice"`
	Quiz            bool         `json:"quiz"`
	Question        string       `json:"question"`
	Answers         []PollAnswer `json:"answers"`
	Close_period    int32        `json:"close_period"`
	Close_date      int32        `json:"close_date"`
}

func (st *Poll_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Poll_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Closed, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Public_voters, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Multiple_choice, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Quiz, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Question, 5, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Answers = make([]PollAnswer, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Answers[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Close_period, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Close_date, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Poll_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Poll_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Poll_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Closed, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Public_voters, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Multiple_choice, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Quiz, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Question, 5)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Answers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Answers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Close_period, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Close_date, 8)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Poll_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpoll struct implement
type TLpoll struct {
	Data Poll_Data `json:"data"`
}

func (st *TLpoll) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpoll) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpoll) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpoll, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpoll) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpoll) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_CountriesList struct implement
type Help_CountriesList struct {
	Constructor int32                   `json:"constructor"`
	Data        Help_CountriesList_Data `json:"data"`
}

func (st *Help_CountriesList) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_CountriesList) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_CountriesList) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_CountriesList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_CountriesList) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_CountriesList) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_CountriesList_Data struct implement
type Help_CountriesList_Data struct {
	Countries []Help_Country `json:"countries"`
	Hash      int32          `json:"hash"`
}

func (st *Help_CountriesList_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_CountriesList_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Countries = make([]Help_Country, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Countries[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Hash, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_CountriesList_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_CountriesList_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_CountriesList_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Countries)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Countries {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Hash, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_CountriesList_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_countriesListNotModified struct implement
type TLhelp_countriesListNotModified struct {
	Data Help_CountriesList_Data `json:"data"`
}

func (st *TLhelp_countriesListNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_countriesListNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_countriesListNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_countriesListNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_countriesListNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_countriesListNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_countriesList struct implement
type TLhelp_countriesList struct {
	Data Help_CountriesList_Data `json:"data"`
}

func (st *TLhelp_countriesList) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_countriesList) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_countriesList) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_countriesList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_countriesList) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_countriesList) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_StickerSet struct implement
type Messages_StickerSet struct {
	Constructor int32                    `json:"constructor"`
	Data        Messages_StickerSet_Data `json:"data"`
}

func (st *Messages_StickerSet) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_StickerSet) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_StickerSet) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_StickerSet, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_StickerSet) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_StickerSet) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_StickerSet_Data struct implement
type Messages_StickerSet_Data struct {
	Set       StickerSet    `json:"set"`
	Packs     []StickerPack `json:"packs"`
	Documents []Document    `json:"documents"`
}

func (st *Messages_StickerSet_Data) ResetDefault() {
	st.Set.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_StickerSet_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Set.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Packs = make([]StickerPack, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Packs[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Documents = make([]Document, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Documents[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_StickerSet_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_StickerSet_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_StickerSet_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Set.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Packs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Packs {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Documents)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Documents {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_StickerSet_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_stickerSet struct implement
type TLmessages_stickerSet struct {
	Data Messages_StickerSet_Data `json:"data"`
}

func (st *TLmessages_stickerSet) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_stickerSet) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_stickerSet) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_stickerSet, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_stickerSet) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_stickerSet) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_Dialogs struct implement
type Messages_Dialogs struct {
	Constructor int32                 `json:"constructor"`
	Data        Messages_Dialogs_Data `json:"data"`
}

func (st *Messages_Dialogs) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_Dialogs) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_Dialogs) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_Dialogs, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_Dialogs) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_Dialogs) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_Dialogs_Data struct implement
type Messages_Dialogs_Data struct {
	Dialogs  []Dialog  `json:"dialogs"`
	Messages []Message `json:"messages"`
	Chats    []Chat    `json:"chats"`
	Users    []User    `json:"users"`
	Count    int32     `json:"count"`
}

func (st *Messages_Dialogs_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_Dialogs_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Dialogs = make([]Dialog, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Dialogs[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Messages = make([]Message, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Messages[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Chats[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Users[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Count, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_Dialogs_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_Dialogs_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_Dialogs_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Dialogs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Dialogs {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Messages)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Messages {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Count, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_Dialogs_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_dialogs struct implement
type TLmessages_dialogs struct {
	Data Messages_Dialogs_Data `json:"data"`
}

func (st *TLmessages_dialogs) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_dialogs) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_dialogs) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_dialogs, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_dialogs) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_dialogs) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_dialogsSlice struct implement
type TLmessages_dialogsSlice struct {
	Data Messages_Dialogs_Data `json:"data"`
}

func (st *TLmessages_dialogsSlice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_dialogsSlice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_dialogsSlice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_dialogsSlice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_dialogsSlice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_dialogsSlice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_dialogsNotModified struct implement
type TLmessages_dialogsNotModified struct {
	Data Messages_Dialogs_Data `json:"data"`
}

func (st *TLmessages_dialogsNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_dialogsNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_dialogsNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_dialogsNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_dialogsNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_dialogsNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputTheme struct implement
type InputTheme struct {
	Constructor int32           `json:"constructor"`
	Data        InputTheme_Data `json:"data"`
}

func (st *InputTheme) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputTheme) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputTheme) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputTheme, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputTheme) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputTheme) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputTheme_Data struct implement
type InputTheme_Data struct {
	Id          int64  `json:"id"`
	Access_hash int64  `json:"access_hash"`
	Slug        string `json:"slug"`
}

func (st *InputTheme_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputTheme_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Slug, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputTheme_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputTheme_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputTheme_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Slug, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputTheme_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputTheme struct implement
type TLinputTheme struct {
	Data InputTheme_Data `json:"data"`
}

func (st *TLinputTheme) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputTheme) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputTheme) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputTheme, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputTheme) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputTheme) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputThemeSlug struct implement
type TLinputThemeSlug struct {
	Data InputTheme_Data `json:"data"`
}

func (st *TLinputThemeSlug) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputThemeSlug) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputThemeSlug) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputThemeSlug, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputThemeSlug) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputThemeSlug) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputPrivacyRule struct implement
type InputPrivacyRule struct {
	Constructor int32                 `json:"constructor"`
	Data        InputPrivacyRule_Data `json:"data"`
}

func (st *InputPrivacyRule) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputPrivacyRule) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputPrivacyRule) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputPrivacyRule, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputPrivacyRule) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputPrivacyRule) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputPrivacyRule_Data struct implement
type InputPrivacyRule_Data struct {
	Users []InputUser `json:"users"`
	Chats []int32     `json:"chats"`
}

func (st *InputPrivacyRule_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputPrivacyRule_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]InputUser, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Users[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]int32, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int32(&st.Chats[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputPrivacyRule_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputPrivacyRule_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputPrivacyRule_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputPrivacyRule_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPrivacyValueAllowContacts struct implement
type TLinputPrivacyValueAllowContacts struct {
	Data InputPrivacyRule_Data `json:"data"`
}

func (st *TLinputPrivacyValueAllowContacts) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPrivacyValueAllowContacts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPrivacyValueAllowContacts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPrivacyValueAllowContacts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPrivacyValueAllowContacts) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPrivacyValueAllowContacts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPrivacyValueAllowAll struct implement
type TLinputPrivacyValueAllowAll struct {
	Data InputPrivacyRule_Data `json:"data"`
}

func (st *TLinputPrivacyValueAllowAll) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPrivacyValueAllowAll) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPrivacyValueAllowAll) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPrivacyValueAllowAll, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPrivacyValueAllowAll) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPrivacyValueAllowAll) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPrivacyValueAllowUsers struct implement
type TLinputPrivacyValueAllowUsers struct {
	Data InputPrivacyRule_Data `json:"data"`
}

func (st *TLinputPrivacyValueAllowUsers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPrivacyValueAllowUsers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPrivacyValueAllowUsers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPrivacyValueAllowUsers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPrivacyValueAllowUsers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPrivacyValueAllowUsers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPrivacyValueDisallowContacts struct implement
type TLinputPrivacyValueDisallowContacts struct {
	Data InputPrivacyRule_Data `json:"data"`
}

func (st *TLinputPrivacyValueDisallowContacts) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPrivacyValueDisallowContacts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPrivacyValueDisallowContacts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPrivacyValueDisallowContacts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPrivacyValueDisallowContacts) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPrivacyValueDisallowContacts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPrivacyValueDisallowAll struct implement
type TLinputPrivacyValueDisallowAll struct {
	Data InputPrivacyRule_Data `json:"data"`
}

func (st *TLinputPrivacyValueDisallowAll) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPrivacyValueDisallowAll) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPrivacyValueDisallowAll) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPrivacyValueDisallowAll, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPrivacyValueDisallowAll) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPrivacyValueDisallowAll) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPrivacyValueDisallowUsers struct implement
type TLinputPrivacyValueDisallowUsers struct {
	Data InputPrivacyRule_Data `json:"data"`
}

func (st *TLinputPrivacyValueDisallowUsers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPrivacyValueDisallowUsers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPrivacyValueDisallowUsers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPrivacyValueDisallowUsers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPrivacyValueDisallowUsers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPrivacyValueDisallowUsers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPrivacyValueAllowChatParticipants struct implement
type TLinputPrivacyValueAllowChatParticipants struct {
	Data InputPrivacyRule_Data `json:"data"`
}

func (st *TLinputPrivacyValueAllowChatParticipants) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPrivacyValueAllowChatParticipants) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPrivacyValueAllowChatParticipants) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPrivacyValueAllowChatParticipants, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPrivacyValueAllowChatParticipants) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPrivacyValueAllowChatParticipants) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPrivacyValueDisallowChatParticipants struct implement
type TLinputPrivacyValueDisallowChatParticipants struct {
	Data InputPrivacyRule_Data `json:"data"`
}

func (st *TLinputPrivacyValueDisallowChatParticipants) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPrivacyValueDisallowChatParticipants) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPrivacyValueDisallowChatParticipants) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPrivacyValueDisallowChatParticipants, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPrivacyValueDisallowChatParticipants) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPrivacyValueDisallowChatParticipants) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// UrlAuthResult struct implement
type UrlAuthResult struct {
	Constructor int32              `json:"constructor"`
	Data        UrlAuthResult_Data `json:"data"`
}

func (st *UrlAuthResult) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *UrlAuthResult) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *UrlAuthResult) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UrlAuthResult, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *UrlAuthResult) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *UrlAuthResult) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// UrlAuthResult_Data struct implement
type UrlAuthResult_Data struct {
	Request_write_access bool   `json:"request_write_access"`
	Bot                  User   `json:"bot"`
	Domain               string `json:"domain"`
	Url                  string `json:"url"`
}

func (st *UrlAuthResult_Data) ResetDefault() {
	st.Bot.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *UrlAuthResult_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Request_write_access, 0, false)
	if err != nil {
		return err
	}

	err = st.Bot.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Domain, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Url, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *UrlAuthResult_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UrlAuthResult_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *UrlAuthResult_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Request_write_access, 0)
	if err != nil {
		return err
	}

	err = st.Bot.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Domain, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Url, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *UrlAuthResult_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLurlAuthResultRequest struct implement
type TLurlAuthResultRequest struct {
	Data UrlAuthResult_Data `json:"data"`
}

func (st *TLurlAuthResultRequest) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLurlAuthResultRequest) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLurlAuthResultRequest) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLurlAuthResultRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLurlAuthResultRequest) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLurlAuthResultRequest) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLurlAuthResultAccepted struct implement
type TLurlAuthResultAccepted struct {
	Data UrlAuthResult_Data `json:"data"`
}

func (st *TLurlAuthResultAccepted) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLurlAuthResultAccepted) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLurlAuthResultAccepted) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLurlAuthResultAccepted, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLurlAuthResultAccepted) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLurlAuthResultAccepted) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLurlAuthResultDefault struct implement
type TLurlAuthResultDefault struct {
	Data UrlAuthResult_Data `json:"data"`
}

func (st *TLurlAuthResultDefault) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLurlAuthResultDefault) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLurlAuthResultDefault) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLurlAuthResultDefault, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLurlAuthResultDefault) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLurlAuthResultDefault) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PhoneCall struct implement
type PhoneCall struct {
	Constructor int32          `json:"constructor"`
	Data        PhoneCall_Data `json:"data"`
}

func (st *PhoneCall) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PhoneCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PhoneCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PhoneCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PhoneCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PhoneCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PhoneCall_Data struct implement
type PhoneCall_Data struct {
	Id              int64                  `json:"id"`
	Video           bool                   `json:"video"`
	Access_hash     int64                  `json:"access_hash"`
	Date            int32                  `json:"date"`
	Admin_id        int32                  `json:"admin_id"`
	Participant_id  int32                  `json:"participant_id"`
	Protocol        PhoneCallProtocol      `json:"protocol"`
	Receive_date    int32                  `json:"receive_date"`
	G_a_hash        []uint8                `json:"g_a_hash"`
	G_b             []uint8                `json:"g_b"`
	P2p_allowed     bool                   `json:"p2p_allowed"`
	G_a_or_b        []uint8                `json:"g_a_or_b"`
	Key_fingerprint int64                  `json:"key_fingerprint"`
	Connections     []PhoneConnection      `json:"connections"`
	Start_date      int32                  `json:"start_date"`
	Need_rating     bool                   `json:"need_rating"`
	Need_debug      bool                   `json:"need_debug"`
	Reason          PhoneCallDiscardReason `json:"reason"`
	Duration        int32                  `json:"duration"`
}

func (st *PhoneCall_Data) ResetDefault() {
	st.Protocol.ResetDefault()
	st.Reason.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PhoneCall_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Video, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Admin_id, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Participant_id, 5, false)
	if err != nil {
		return err
	}

	err = st.Protocol.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Receive_date, 7, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.G_a_hash = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.G_a_hash[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.G_a_hash, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(9, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.G_b = make([]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_uint8(&st.G_b[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.G_b, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_bool(&st.P2p_allowed, 10, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(11, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.G_a_or_b = make([]uint8, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = _is.Read_uint8(&st.G_a_or_b[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.G_a_or_b, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int64(&st.Key_fingerprint, 12, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(13, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Connections = make([]PhoneConnection, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Connections[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Start_date, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Need_rating, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Need_debug, 16, false)
	if err != nil {
		return err
	}

	err = st.Reason.ReadBlock(_is, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Duration, 18, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PhoneCall_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PhoneCall_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PhoneCall_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Video, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Admin_id, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Participant_id, 5)
	if err != nil {
		return err
	}

	err = st.Protocol.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Receive_date, 7)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.G_a_hash)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.G_a_hash {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.G_b)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.G_b {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_bool(st.P2p_allowed, 10)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.G_a_or_b)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.G_a_or_b {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int64(st.Key_fingerprint, 12)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Connections)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Connections {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Start_date, 14)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Need_rating, 15)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Need_debug, 16)
	if err != nil {
		return err
	}

	err = st.Reason.WriteBlock(_os, 17)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Duration, 18)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PhoneCall_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphoneCallEmpty struct implement
type TLphoneCallEmpty struct {
	Data PhoneCall_Data `json:"data"`
}

func (st *TLphoneCallEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphoneCallEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphoneCallEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphoneCallEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphoneCallEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphoneCallEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphoneCallWaiting struct implement
type TLphoneCallWaiting struct {
	Data PhoneCall_Data `json:"data"`
}

func (st *TLphoneCallWaiting) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphoneCallWaiting) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphoneCallWaiting) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphoneCallWaiting, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphoneCallWaiting) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphoneCallWaiting) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphoneCallRequested struct implement
type TLphoneCallRequested struct {
	Data PhoneCall_Data `json:"data"`
}

func (st *TLphoneCallRequested) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphoneCallRequested) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphoneCallRequested) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphoneCallRequested, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphoneCallRequested) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphoneCallRequested) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphoneCallAccepted struct implement
type TLphoneCallAccepted struct {
	Data PhoneCall_Data `json:"data"`
}

func (st *TLphoneCallAccepted) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphoneCallAccepted) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphoneCallAccepted) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphoneCallAccepted, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphoneCallAccepted) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphoneCallAccepted) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphoneCall struct implement
type TLphoneCall struct {
	Data PhoneCall_Data `json:"data"`
}

func (st *TLphoneCall) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphoneCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphoneCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphoneCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphoneCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphoneCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphoneCallDiscarded struct implement
type TLphoneCallDiscarded struct {
	Data PhoneCall_Data `json:"data"`
}

func (st *TLphoneCallDiscarded) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphoneCallDiscarded) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphoneCallDiscarded) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphoneCallDiscarded, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphoneCallDiscarded) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphoneCallDiscarded) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_AffectedMessages struct implement
type Messages_AffectedMessages struct {
	Constructor int32                          `json:"constructor"`
	Data        Messages_AffectedMessages_Data `json:"data"`
}

func (st *Messages_AffectedMessages) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_AffectedMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_AffectedMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_AffectedMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_AffectedMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_AffectedMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_AffectedMessages_Data struct implement
type Messages_AffectedMessages_Data struct {
	Pts       int32 `json:"pts"`
	Pts_count int32 `json:"pts_count"`
}

func (st *Messages_AffectedMessages_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_AffectedMessages_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Pts, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Pts_count, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_AffectedMessages_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_AffectedMessages_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_AffectedMessages_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Pts, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Pts_count, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_AffectedMessages_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_affectedMessages struct implement
type TLmessages_affectedMessages struct {
	Data Messages_AffectedMessages_Data `json:"data"`
}

func (st *TLmessages_affectedMessages) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_affectedMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_affectedMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_affectedMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_affectedMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_affectedMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PageListOrderedItem struct implement
type PageListOrderedItem struct {
	Constructor int32                    `json:"constructor"`
	Data        PageListOrderedItem_Data `json:"data"`
}

func (st *PageListOrderedItem) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PageListOrderedItem) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PageListOrderedItem) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PageListOrderedItem, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PageListOrderedItem) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PageListOrderedItem) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PageListOrderedItem_Data struct implement
type PageListOrderedItem_Data struct {
	Num    string      `json:"num"`
	Text   RichText    `json:"text"`
	Blocks []PageBlock `json:"blocks"`
}

func (st *PageListOrderedItem_Data) ResetDefault() {
	st.Text.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PageListOrderedItem_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Num, 0, false)
	if err != nil {
		return err
	}

	err = st.Text.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Blocks = make([]PageBlock, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Blocks[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PageListOrderedItem_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PageListOrderedItem_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PageListOrderedItem_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Num, 0)
	if err != nil {
		return err
	}

	err = st.Text.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Blocks)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Blocks {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PageListOrderedItem_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageListOrderedItemText struct implement
type TLpageListOrderedItemText struct {
	Data PageListOrderedItem_Data `json:"data"`
}

func (st *TLpageListOrderedItemText) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageListOrderedItemText) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageListOrderedItemText) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageListOrderedItemText, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageListOrderedItemText) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageListOrderedItemText) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageListOrderedItemBlocks struct implement
type TLpageListOrderedItemBlocks struct {
	Data PageListOrderedItem_Data `json:"data"`
}

func (st *TLpageListOrderedItemBlocks) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageListOrderedItemBlocks) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageListOrderedItemBlocks) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageListOrderedItemBlocks, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageListOrderedItemBlocks) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageListOrderedItemBlocks) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_BotResults struct implement
type Messages_BotResults struct {
	Constructor int32                    `json:"constructor"`
	Data        Messages_BotResults_Data `json:"data"`
}

func (st *Messages_BotResults) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_BotResults) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_BotResults) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_BotResults, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_BotResults) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_BotResults) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_BotResults_Data struct implement
type Messages_BotResults_Data struct {
	Gallery     bool              `json:"gallery"`
	Query_id    int64             `json:"query_id"`
	Next_offset string            `json:"next_offset"`
	Switch_pm   InlineBotSwitchPM `json:"switch_pm"`
	Results     []BotInlineResult `json:"results"`
	Cache_time  int32             `json:"cache_time"`
	Users       []User            `json:"users"`
}

func (st *Messages_BotResults_Data) ResetDefault() {
	st.Switch_pm.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_BotResults_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Gallery, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Query_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Next_offset, 2, false)
	if err != nil {
		return err
	}

	err = st.Switch_pm.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Results = make([]BotInlineResult, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Results[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Cache_time, 5, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Users[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_BotResults_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_BotResults_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_BotResults_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Gallery, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Query_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Next_offset, 2)
	if err != nil {
		return err
	}

	err = st.Switch_pm.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Results)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Results {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Cache_time, 5)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_BotResults_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_botResults struct implement
type TLmessages_botResults struct {
	Data Messages_BotResults_Data `json:"data"`
}

func (st *TLmessages_botResults) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_botResults) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_botResults) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_botResults, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_botResults) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_botResults) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputEncryptedChat struct implement
type InputEncryptedChat struct {
	Constructor int32                   `json:"constructor"`
	Data        InputEncryptedChat_Data `json:"data"`
}

func (st *InputEncryptedChat) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputEncryptedChat) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputEncryptedChat) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputEncryptedChat, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputEncryptedChat) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputEncryptedChat) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputEncryptedChat_Data struct implement
type InputEncryptedChat_Data struct {
	Chat_id     int32 `json:"chat_id"`
	Access_hash int64 `json:"access_hash"`
}

func (st *InputEncryptedChat_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputEncryptedChat_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Chat_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputEncryptedChat_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputEncryptedChat_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputEncryptedChat_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Chat_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputEncryptedChat_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputEncryptedChat struct implement
type TLinputEncryptedChat struct {
	Data InputEncryptedChat_Data `json:"data"`
}

func (st *TLinputEncryptedChat) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputEncryptedChat) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputEncryptedChat) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputEncryptedChat, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputEncryptedChat) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputEncryptedChat) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_Messages struct implement
type Messages_Messages struct {
	Constructor int32                  `json:"constructor"`
	Data        Messages_Messages_Data `json:"data"`
}

func (st *Messages_Messages) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_Messages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_Messages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_Messages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_Messages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_Messages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_Messages_Data struct implement
type Messages_Messages_Data struct {
	Messages         []Message `json:"messages"`
	Chats            []Chat    `json:"chats"`
	Users            []User    `json:"users"`
	Inexact          bool      `json:"inexact"`
	Count            int32     `json:"count"`
	Next_rate        int32     `json:"next_rate"`
	Offset_id_offset int32     `json:"offset_id_offset"`
	Pts              int32     `json:"pts"`
}

func (st *Messages_Messages_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_Messages_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Messages = make([]Message, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Messages[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Chats[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Users[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_bool(&st.Inexact, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Count, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Next_rate, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset_id_offset, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Pts, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_Messages_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_Messages_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_Messages_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Messages)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Messages {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_bool(st.Inexact, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Count, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Next_rate, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset_id_offset, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Pts, 7)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_Messages_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_messages struct implement
type TLmessages_messages struct {
	Data Messages_Messages_Data `json:"data"`
}

func (st *TLmessages_messages) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_messages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_messages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_messages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_messages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_messages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_messagesSlice struct implement
type TLmessages_messagesSlice struct {
	Data Messages_Messages_Data `json:"data"`
}

func (st *TLmessages_messagesSlice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_messagesSlice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_messagesSlice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_messagesSlice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_messagesSlice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_messagesSlice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_channelMessages struct implement
type TLmessages_channelMessages struct {
	Data Messages_Messages_Data `json:"data"`
}

func (st *TLmessages_channelMessages) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_channelMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_channelMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_channelMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_channelMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_channelMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_messagesNotModified struct implement
type TLmessages_messagesNotModified struct {
	Data Messages_Messages_Data `json:"data"`
}

func (st *TLmessages_messagesNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_messagesNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_messagesNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_messagesNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_messagesNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_messagesNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// RestrictionReason struct implement
type RestrictionReason struct {
	Constructor int32                  `json:"constructor"`
	Data        RestrictionReason_Data `json:"data"`
}

func (st *RestrictionReason) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *RestrictionReason) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *RestrictionReason) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RestrictionReason, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *RestrictionReason) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *RestrictionReason) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// RestrictionReason_Data struct implement
type RestrictionReason_Data struct {
	Platform string `json:"platform"`
	Reason   string `json:"reason"`
	Text     string `json:"text"`
}

func (st *RestrictionReason_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *RestrictionReason_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Platform, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Reason, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Text, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *RestrictionReason_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RestrictionReason_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *RestrictionReason_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Platform, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Reason, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Text, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *RestrictionReason_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLrestrictionReason struct implement
type TLrestrictionReason struct {
	Data RestrictionReason_Data `json:"data"`
}

func (st *TLrestrictionReason) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLrestrictionReason) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLrestrictionReason) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLrestrictionReason, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLrestrictionReason) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLrestrictionReason) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ReportReason struct implement
type ReportReason struct {
	Constructor int32             `json:"constructor"`
	Data        ReportReason_Data `json:"data"`
}

func (st *ReportReason) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ReportReason) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ReportReason) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ReportReason, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ReportReason) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ReportReason) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ReportReason_Data struct implement
type ReportReason_Data struct {
	Text string `json:"text"`
}

func (st *ReportReason_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *ReportReason_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Text, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ReportReason_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ReportReason_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ReportReason_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Text, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ReportReason_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputReportReasonSpam struct implement
type TLinputReportReasonSpam struct {
	Data ReportReason_Data `json:"data"`
}

func (st *TLinputReportReasonSpam) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputReportReasonSpam) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputReportReasonSpam) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputReportReasonSpam, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputReportReasonSpam) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputReportReasonSpam) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputReportReasonViolence struct implement
type TLinputReportReasonViolence struct {
	Data ReportReason_Data `json:"data"`
}

func (st *TLinputReportReasonViolence) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputReportReasonViolence) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputReportReasonViolence) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputReportReasonViolence, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputReportReasonViolence) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputReportReasonViolence) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputReportReasonPornography struct implement
type TLinputReportReasonPornography struct {
	Data ReportReason_Data `json:"data"`
}

func (st *TLinputReportReasonPornography) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputReportReasonPornography) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputReportReasonPornography) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputReportReasonPornography, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputReportReasonPornography) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputReportReasonPornography) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputReportReasonChildAbuse struct implement
type TLinputReportReasonChildAbuse struct {
	Data ReportReason_Data `json:"data"`
}

func (st *TLinputReportReasonChildAbuse) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputReportReasonChildAbuse) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputReportReasonChildAbuse) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputReportReasonChildAbuse, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputReportReasonChildAbuse) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputReportReasonChildAbuse) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputReportReasonOther struct implement
type TLinputReportReasonOther struct {
	Data ReportReason_Data `json:"data"`
}

func (st *TLinputReportReasonOther) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputReportReasonOther) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputReportReasonOther) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputReportReasonOther, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputReportReasonOther) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputReportReasonOther) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputReportReasonCopyright struct implement
type TLinputReportReasonCopyright struct {
	Data ReportReason_Data `json:"data"`
}

func (st *TLinputReportReasonCopyright) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputReportReasonCopyright) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputReportReasonCopyright) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputReportReasonCopyright, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputReportReasonCopyright) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputReportReasonCopyright) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputReportReasonGeoIrrelevant struct implement
type TLinputReportReasonGeoIrrelevant struct {
	Data ReportReason_Data `json:"data"`
}

func (st *TLinputReportReasonGeoIrrelevant) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputReportReasonGeoIrrelevant) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputReportReasonGeoIrrelevant) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputReportReasonGeoIrrelevant, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputReportReasonGeoIrrelevant) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputReportReasonGeoIrrelevant) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Contacts_ResolvedPeer struct implement
type Contacts_ResolvedPeer struct {
	Constructor int32                      `json:"constructor"`
	Data        Contacts_ResolvedPeer_Data `json:"data"`
}

func (st *Contacts_ResolvedPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Contacts_ResolvedPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Contacts_ResolvedPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Contacts_ResolvedPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Contacts_ResolvedPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Contacts_ResolvedPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Contacts_ResolvedPeer_Data struct implement
type Contacts_ResolvedPeer_Data struct {
	Peer  Peer   `json:"peer"`
	Chats []Chat `json:"chats"`
	Users []User `json:"users"`
}

func (st *Contacts_ResolvedPeer_Data) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Contacts_ResolvedPeer_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Chats[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Users[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Contacts_ResolvedPeer_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Contacts_ResolvedPeer_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Contacts_ResolvedPeer_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Contacts_ResolvedPeer_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_resolvedPeer struct implement
type TLcontacts_resolvedPeer struct {
	Data Contacts_ResolvedPeer_Data `json:"data"`
}

func (st *TLcontacts_resolvedPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_resolvedPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_resolvedPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_resolvedPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_resolvedPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_resolvedPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// GeoPoint struct implement
type GeoPoint struct {
	Constructor int32         `json:"constructor"`
	Data        GeoPoint_Data `json:"data"`
}

func (st *GeoPoint) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *GeoPoint) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GeoPoint) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GeoPoint, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GeoPoint) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GeoPoint) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// GeoPoint_Data struct implement
type GeoPoint_Data struct {
	Long_key        float64 `json:"long_key"`
	Lat             float64 `json:"lat"`
	Access_hash     int64   `json:"access_hash"`
	Accuracy_radius int32   `json:"accuracy_radius"`
}

func (st *GeoPoint_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *GeoPoint_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_float64(&st.Long_key, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Lat, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Accuracy_radius, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GeoPoint_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GeoPoint_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GeoPoint_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_float64(st.Long_key, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Lat, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Accuracy_radius, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GeoPoint_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLgeoPointEmpty struct implement
type TLgeoPointEmpty struct {
	Data GeoPoint_Data `json:"data"`
}

func (st *TLgeoPointEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLgeoPointEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLgeoPointEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLgeoPointEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLgeoPointEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLgeoPointEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLgeoPoint struct implement
type TLgeoPoint struct {
	Data GeoPoint_Data `json:"data"`
}

func (st *TLgeoPoint) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLgeoPoint) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLgeoPoint) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLgeoPoint, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLgeoPoint) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLgeoPoint) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// WallPaper struct implement
type WallPaper struct {
	Constructor int32          `json:"constructor"`
	Data        WallPaper_Data `json:"data"`
}

func (st *WallPaper) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *WallPaper) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *WallPaper) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require WallPaper, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *WallPaper) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *WallPaper) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// WallPaper_Data struct implement
type WallPaper_Data struct {
	Id          int64             `json:"id"`
	Creator     bool              `json:"creator"`
	Default     bool              `json:"default"`
	Pattern     bool              `json:"pattern"`
	Dark        bool              `json:"dark"`
	Access_hash int64             `json:"access_hash"`
	Slug        string            `json:"slug"`
	Document    Document          `json:"document"`
	Settings    WallPaperSettings `json:"settings"`
}

func (st *WallPaper_Data) ResetDefault() {
	st.Document.ResetDefault()
	st.Settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *WallPaper_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Creator, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Default, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Pattern, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Dark, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Slug, 6, false)
	if err != nil {
		return err
	}

	err = st.Document.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	err = st.Settings.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *WallPaper_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require WallPaper_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *WallPaper_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Creator, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Default, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Pattern, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Dark, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Slug, 6)
	if err != nil {
		return err
	}

	err = st.Document.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	err = st.Settings.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *WallPaper_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLwallPaper struct implement
type TLwallPaper struct {
	Data WallPaper_Data `json:"data"`
}

func (st *TLwallPaper) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLwallPaper) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLwallPaper) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLwallPaper, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLwallPaper) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLwallPaper) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLwallPaperNoFile struct implement
type TLwallPaperNoFile struct {
	Data WallPaper_Data `json:"data"`
}

func (st *TLwallPaperNoFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLwallPaperNoFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLwallPaperNoFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLwallPaperNoFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLwallPaperNoFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLwallPaperNoFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TopPeerCategoryPeers struct implement
type TopPeerCategoryPeers struct {
	Constructor int32                     `json:"constructor"`
	Data        TopPeerCategoryPeers_Data `json:"data"`
}

func (st *TopPeerCategoryPeers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TopPeerCategoryPeers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TopPeerCategoryPeers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TopPeerCategoryPeers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TopPeerCategoryPeers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TopPeerCategoryPeers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TopPeerCategoryPeers_Data struct implement
type TopPeerCategoryPeers_Data struct {
	Category TopPeerCategory `json:"category"`
	Count    int32           `json:"count"`
	Peers    []TopPeer       `json:"peers"`
}

func (st *TopPeerCategoryPeers_Data) ResetDefault() {
	st.Category.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TopPeerCategoryPeers_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Category.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Count, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Peers = make([]TopPeer, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Peers[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TopPeerCategoryPeers_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TopPeerCategoryPeers_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TopPeerCategoryPeers_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Category.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Count, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Peers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Peers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TopPeerCategoryPeers_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtopPeerCategoryPeers struct implement
type TLtopPeerCategoryPeers struct {
	Data TopPeerCategoryPeers_Data `json:"data"`
}

func (st *TLtopPeerCategoryPeers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtopPeerCategoryPeers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtopPeerCategoryPeers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtopPeerCategoryPeers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtopPeerCategoryPeers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtopPeerCategoryPeers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputPeerNotifySettings struct implement
type InputPeerNotifySettings struct {
	Constructor int32                        `json:"constructor"`
	Data        InputPeerNotifySettings_Data `json:"data"`
}

func (st *InputPeerNotifySettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputPeerNotifySettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputPeerNotifySettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputPeerNotifySettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputPeerNotifySettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputPeerNotifySettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputPeerNotifySettings_Data struct implement
type InputPeerNotifySettings_Data struct {
	Show_previews Bool   `json:"show_previews"`
	Silent        Bool   `json:"silent"`
	Mute_until    int32  `json:"mute_until"`
	Sound         string `json:"sound"`
}

func (st *InputPeerNotifySettings_Data) ResetDefault() {
	st.Show_previews.ResetDefault()
	st.Silent.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputPeerNotifySettings_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Show_previews.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Silent.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Mute_until, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Sound, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputPeerNotifySettings_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputPeerNotifySettings_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputPeerNotifySettings_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Show_previews.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Silent.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Mute_until, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Sound, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputPeerNotifySettings_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPeerNotifySettings struct implement
type TLinputPeerNotifySettings struct {
	Data InputPeerNotifySettings_Data `json:"data"`
}

func (st *TLinputPeerNotifySettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPeerNotifySettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPeerNotifySettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPeerNotifySettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPeerNotifySettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPeerNotifySettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputMedia struct implement
type InputMedia struct {
	Constructor int32           `json:"constructor"`
	Data        InputMedia_Data `json:"data"`
}

func (st *InputMedia) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputMedia) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputMedia) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputMedia, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputMedia) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputMedia) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputMedia_Data struct implement
type InputMedia_Data struct {
	File                          InputFile           `json:"file"`
	Stickers                      []InputDocument     `json:"stickers"`
	Ttl_seconds                   int32               `json:"ttl_seconds"`
	Id                            InputPhoto          `json:"id"`
	Geo_point                     InputGeoPoint       `json:"geo_point"`
	Phone_number                  string              `json:"phone_number"`
	First_name                    string              `json:"first_name"`
	Last_name                     string              `json:"last_name"`
	Vcard                         string              `json:"vcard"`
	Nosound_video                 bool                `json:"nosound_video"`
	Force_file                    bool                `json:"force_file"`
	Thumb                         InputFile           `json:"thumb"`
	Mime_type                     string              `json:"mime_type"`
	Attributes                    []DocumentAttribute `json:"attributes"`
	Id_15                         InputDocument       `json:"id_15"`
	Title                         string              `json:"title"`
	Address                       string              `json:"address"`
	Provider                      string              `json:"provider"`
	Venue_id                      string              `json:"venue_id"`
	Venue_type                    string              `json:"venue_type"`
	Url                           string              `json:"url"`
	Id_22                         InputGame           `json:"id_22"`
	Description                   string              `json:"description"`
	Photo                         InputWebDocument    `json:"photo"`
	Invoice                       Invoice             `json:"invoice"`
	Payload                       []uint8             `json:"payload"`
	Provider_data                 DataJSON            `json:"provider_data"`
	Start_param                   string              `json:"start_param"`
	Stopped                       bool                `json:"stopped"`
	Heading                       int32               `json:"heading"`
	Period                        int32               `json:"period"`
	Proximity_notification_radius int32               `json:"proximity_notification_radius"`
	Poll                          Poll                `json:"poll"`
	Correct_answers               [][]uint8           `json:"correct_answers"`
	Solution                      string              `json:"solution"`
	Solution_entities             []MessageEntity     `json:"solution_entities"`
	Emoticon                      string              `json:"emoticon"`
}

func (st *InputMedia_Data) ResetDefault() {
	st.File.ResetDefault()
	st.Id.ResetDefault()
	st.Geo_point.ResetDefault()
	st.Thumb.ResetDefault()
	st.Id_15.ResetDefault()
	st.Id_22.ResetDefault()
	st.Photo.ResetDefault()
	st.Invoice.ResetDefault()
	st.Provider_data.ResetDefault()
	st.Poll.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputMedia_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.File.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Stickers = make([]InputDocument, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Stickers[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Ttl_seconds, 2, false)
	if err != nil {
		return err
	}

	err = st.Id.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = st.Geo_point.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone_number, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.First_name, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Last_name, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Vcard, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Nosound_video, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Force_file, 10, false)
	if err != nil {
		return err
	}

	err = st.Thumb.ReadBlock(_is, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Mime_type, 12, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(13, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Attributes = make([]DocumentAttribute, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Attributes[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Id_15.ReadBlock(_is, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Address, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Provider, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Venue_id, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Venue_type, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Url, 20, false)
	if err != nil {
		return err
	}

	err = st.Id_22.ReadBlock(_is, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Description, 22, false)
	if err != nil {
		return err
	}

	err = st.Photo.ReadBlock(_is, 23, false)
	if err != nil {
		return err
	}

	err = st.Invoice.ReadBlock(_is, 24, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(25, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Payload = make([]uint8, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = _is.Read_uint8(&st.Payload[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Payload, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Provider_data.ReadBlock(_is, 26, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Start_param, 27, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Stopped, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Heading, 29, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Period, 30, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Proximity_notification_radius, 31, false)
	if err != nil {
		return err
	}

	err = st.Poll.ReadBlock(_is, 32, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(33, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Correct_answers = make([][]uint8, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err, have, ty = _is.SkipToNoCheck(0, false)
				if err != nil {
					return err
				}

				if have {
					if ty == codec.LIST {
						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}

						st.Correct_answers[i3] = make([]uint8, length)
						for i4, e4 := int32(0), length; i4 < e4; i4++ {

							err = _is.Read_uint8(&st.Correct_answers[i3][i4], 0, false)
							if err != nil {
								return err
							}

						}
					} else if ty == codec.SIMPLE_LIST {

						err, _ = _is.SkipTo(codec.BYTE, 0, true)
						if err != nil {
							return err
						}

						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}

						err = _is.Read_slice_uint8(&st.Correct_answers[i3], length, true)
						if err != nil {
							return err
						}

					} else {
						err = fmt.Errorf("require vector, but not")
						if err != nil {
							return err
						}

					}
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Solution, 34, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(35, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Solution_entities = make([]MessageEntity, length)
			for i5, e5 := int32(0), length; i5 < e5; i5++ {

				err = st.Solution_entities[i5].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Emoticon, 36, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputMedia_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputMedia_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputMedia_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.File.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Stickers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Stickers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Ttl_seconds, 2)
	if err != nil {
		return err
	}

	err = st.Id.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = st.Geo_point.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone_number, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.First_name, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Last_name, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Vcard, 8)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Nosound_video, 9)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Force_file, 10)
	if err != nil {
		return err
	}

	err = st.Thumb.WriteBlock(_os, 11)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Mime_type, 12)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Attributes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Attributes {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Id_15.WriteBlock(_os, 14)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 15)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Address, 16)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Provider, 17)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Venue_id, 18)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Venue_type, 19)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Url, 20)
	if err != nil {
		return err
	}

	err = st.Id_22.WriteBlock(_os, 21)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Description, 22)
	if err != nil {
		return err
	}

	err = st.Photo.WriteBlock(_os, 23)
	if err != nil {
		return err
	}

	err = st.Invoice.WriteBlock(_os, 24)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 25)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Payload)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Payload {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = st.Provider_data.WriteBlock(_os, 26)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Start_param, 27)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Stopped, 28)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Heading, 29)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Period, 30)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Proximity_notification_radius, 31)
	if err != nil {
		return err
	}

	err = st.Poll.WriteBlock(_os, 32)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 33)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Correct_answers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Correct_answers {

		err = _os.WriteHead(codec.LIST, 0)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v)), 0)
		if err != nil {
			return err
		}

		for _, v := range v {

			err = _os.Write_uint8(v, 0)
			if err != nil {
				return err
			}

		}
	}

	err = _os.Write_string(st.Solution, 34)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 35)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Solution_entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Solution_entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Emoticon, 36)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputMedia_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMediaEmpty struct implement
type TLinputMediaEmpty struct {
	Data InputMedia_Data `json:"data"`
}

func (st *TLinputMediaEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMediaEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMediaEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMediaEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMediaEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMediaEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMediaUploadedPhoto struct implement
type TLinputMediaUploadedPhoto struct {
	Data InputMedia_Data `json:"data"`
}

func (st *TLinputMediaUploadedPhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMediaUploadedPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMediaUploadedPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMediaUploadedPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMediaUploadedPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMediaUploadedPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMediaPhoto struct implement
type TLinputMediaPhoto struct {
	Data InputMedia_Data `json:"data"`
}

func (st *TLinputMediaPhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMediaPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMediaPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMediaPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMediaPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMediaPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMediaGeoPoint struct implement
type TLinputMediaGeoPoint struct {
	Data InputMedia_Data `json:"data"`
}

func (st *TLinputMediaGeoPoint) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMediaGeoPoint) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMediaGeoPoint) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMediaGeoPoint, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMediaGeoPoint) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMediaGeoPoint) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMediaContact struct implement
type TLinputMediaContact struct {
	Data InputMedia_Data `json:"data"`
}

func (st *TLinputMediaContact) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMediaContact) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMediaContact) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMediaContact, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMediaContact) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMediaContact) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMediaUploadedDocument struct implement
type TLinputMediaUploadedDocument struct {
	Data InputMedia_Data `json:"data"`
}

func (st *TLinputMediaUploadedDocument) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMediaUploadedDocument) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMediaUploadedDocument) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMediaUploadedDocument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMediaUploadedDocument) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMediaUploadedDocument) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMediaDocument struct implement
type TLinputMediaDocument struct {
	Data InputMedia_Data `json:"data"`
}

func (st *TLinputMediaDocument) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMediaDocument) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMediaDocument) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMediaDocument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMediaDocument) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMediaDocument) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMediaVenue struct implement
type TLinputMediaVenue struct {
	Data InputMedia_Data `json:"data"`
}

func (st *TLinputMediaVenue) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMediaVenue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMediaVenue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMediaVenue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMediaVenue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMediaVenue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMediaPhotoExternal struct implement
type TLinputMediaPhotoExternal struct {
	Data InputMedia_Data `json:"data"`
}

func (st *TLinputMediaPhotoExternal) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMediaPhotoExternal) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMediaPhotoExternal) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMediaPhotoExternal, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMediaPhotoExternal) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMediaPhotoExternal) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMediaDocumentExternal struct implement
type TLinputMediaDocumentExternal struct {
	Data InputMedia_Data `json:"data"`
}

func (st *TLinputMediaDocumentExternal) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMediaDocumentExternal) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMediaDocumentExternal) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMediaDocumentExternal, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMediaDocumentExternal) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMediaDocumentExternal) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMediaGame struct implement
type TLinputMediaGame struct {
	Data InputMedia_Data `json:"data"`
}

func (st *TLinputMediaGame) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMediaGame) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMediaGame) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMediaGame, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMediaGame) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMediaGame) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMediaInvoice struct implement
type TLinputMediaInvoice struct {
	Data InputMedia_Data `json:"data"`
}

func (st *TLinputMediaInvoice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMediaInvoice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMediaInvoice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMediaInvoice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMediaInvoice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMediaInvoice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMediaGeoLive struct implement
type TLinputMediaGeoLive struct {
	Data InputMedia_Data `json:"data"`
}

func (st *TLinputMediaGeoLive) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMediaGeoLive) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMediaGeoLive) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMediaGeoLive, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMediaGeoLive) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMediaGeoLive) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMediaPoll struct implement
type TLinputMediaPoll struct {
	Data InputMedia_Data `json:"data"`
}

func (st *TLinputMediaPoll) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMediaPoll) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMediaPoll) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMediaPoll, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMediaPoll) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMediaPoll) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputMediaDice struct implement
type TLinputMediaDice struct {
	Data InputMedia_Data `json:"data"`
}

func (st *TLinputMediaDice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputMediaDice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputMediaDice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputMediaDice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputMediaDice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputMediaDice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputWebFileLocation struct implement
type InputWebFileLocation struct {
	Constructor int32                     `json:"constructor"`
	Data        InputWebFileLocation_Data `json:"data"`
}

func (st *InputWebFileLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputWebFileLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputWebFileLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputWebFileLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputWebFileLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputWebFileLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputWebFileLocation_Data struct implement
type InputWebFileLocation_Data struct {
	Url         string        `json:"url"`
	Access_hash int64         `json:"access_hash"`
	Geo_point   InputGeoPoint `json:"geo_point"`
	W           int32         `json:"w"`
	H           int32         `json:"h"`
	Zoom        int32         `json:"zoom"`
	Scale       int32         `json:"scale"`
}

func (st *InputWebFileLocation_Data) ResetDefault() {
	st.Geo_point.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputWebFileLocation_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Url, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	err = st.Geo_point.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.W, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.H, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Zoom, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Scale, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputWebFileLocation_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputWebFileLocation_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputWebFileLocation_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Url, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	err = st.Geo_point.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.W, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.H, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Zoom, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Scale, 6)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputWebFileLocation_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputWebFileLocation struct implement
type TLinputWebFileLocation struct {
	Data InputWebFileLocation_Data `json:"data"`
}

func (st *TLinputWebFileLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputWebFileLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputWebFileLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputWebFileLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputWebFileLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputWebFileLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputWebFileGeoPointLocation struct implement
type TLinputWebFileGeoPointLocation struct {
	Data InputWebFileLocation_Data `json:"data"`
}

func (st *TLinputWebFileGeoPointLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputWebFileGeoPointLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputWebFileGeoPointLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputWebFileGeoPointLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputWebFileGeoPointLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputWebFileGeoPointLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Chat struct implement
type Chat struct {
	Constructor int32     `json:"constructor"`
	Data        Chat_Data `json:"data"`
}

func (st *Chat) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Chat) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Chat) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Chat, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Chat) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Chat) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Chat_Data struct implement
type Chat_Data struct {
	Id                    int32               `json:"id"`
	Creator               bool                `json:"creator"`
	Kicked                bool                `json:"kicked"`
	Left                  bool                `json:"left"`
	Deactivated           bool                `json:"deactivated"`
	Call_active           bool                `json:"call_active"`
	Call_not_empty        bool                `json:"call_not_empty"`
	Title                 string              `json:"title"`
	Photo                 ChatPhoto           `json:"photo"`
	Participants_count    int32               `json:"participants_count"`
	Date                  int32               `json:"date"`
	Version               int32               `json:"version"`
	Migrated_to           InputChannel        `json:"migrated_to"`
	Admin_rights          ChatAdminRights     `json:"admin_rights"`
	Default_banned_rights ChatBannedRights    `json:"default_banned_rights"`
	Broadcast             bool                `json:"broadcast"`
	Verified              bool                `json:"verified"`
	Megagroup             bool                `json:"megagroup"`
	Restricted            bool                `json:"restricted"`
	Signatures            bool                `json:"signatures"`
	Min                   bool                `json:"min"`
	Scam                  bool                `json:"scam"`
	Has_link              bool                `json:"has_link"`
	Has_geo               bool                `json:"has_geo"`
	Slowmode_enabled      bool                `json:"slowmode_enabled"`
	Access_hash           int64               `json:"access_hash"`
	Username              string              `json:"username"`
	Restriction_reason    []RestrictionReason `json:"restriction_reason"`
	Banned_rights         ChatBannedRights    `json:"banned_rights"`
	Until_date            int32               `json:"until_date"`
}

func (st *Chat_Data) ResetDefault() {
	st.Photo.ResetDefault()
	st.Migrated_to.ResetDefault()
	st.Admin_rights.ResetDefault()
	st.Default_banned_rights.ResetDefault()
	st.Banned_rights.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Chat_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Creator, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Kicked, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Left, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Deactivated, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Call_active, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Call_not_empty, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 7, false)
	if err != nil {
		return err
	}

	err = st.Photo.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Participants_count, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Version, 11, false)
	if err != nil {
		return err
	}

	err = st.Migrated_to.ReadBlock(_is, 12, false)
	if err != nil {
		return err
	}

	err = st.Admin_rights.ReadBlock(_is, 13, false)
	if err != nil {
		return err
	}

	err = st.Default_banned_rights.ReadBlock(_is, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Broadcast, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Verified, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Megagroup, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Restricted, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Signatures, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Min, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Scam, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Has_link, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Has_geo, 23, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Slowmode_enabled, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 25, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Username, 26, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(27, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Restriction_reason = make([]RestrictionReason, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Restriction_reason[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Banned_rights.ReadBlock(_is, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Until_date, 29, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Chat_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Chat_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Chat_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Creator, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Kicked, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Left, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Deactivated, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Call_active, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Call_not_empty, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 7)
	if err != nil {
		return err
	}

	err = st.Photo.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Participants_count, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 10)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Version, 11)
	if err != nil {
		return err
	}

	err = st.Migrated_to.WriteBlock(_os, 12)
	if err != nil {
		return err
	}

	err = st.Admin_rights.WriteBlock(_os, 13)
	if err != nil {
		return err
	}

	err = st.Default_banned_rights.WriteBlock(_os, 14)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Broadcast, 15)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Verified, 16)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Megagroup, 17)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Restricted, 18)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Signatures, 19)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Min, 20)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Scam, 21)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Has_link, 22)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Has_geo, 23)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Slowmode_enabled, 24)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 25)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Username, 26)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 27)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Restriction_reason)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Restriction_reason {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Banned_rights.WriteBlock(_os, 28)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Until_date, 29)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Chat_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatEmpty struct implement
type TLchatEmpty struct {
	Data Chat_Data `json:"data"`
}

func (st *TLchatEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchat struct implement
type TLchat struct {
	Data Chat_Data `json:"data"`
}

func (st *TLchat) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchat) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchat) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchat, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchat) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchat) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatForbidden struct implement
type TLchatForbidden struct {
	Data Chat_Data `json:"data"`
}

func (st *TLchatForbidden) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatForbidden) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatForbidden) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatForbidden, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatForbidden) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatForbidden) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannel struct implement
type TLchannel struct {
	Data Chat_Data `json:"data"`
}

func (st *TLchannel) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannel) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannel) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannel, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannel) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannel) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelForbidden struct implement
type TLchannelForbidden struct {
	Data Chat_Data `json:"data"`
}

func (st *TLchannelForbidden) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelForbidden) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelForbidden) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelForbidden, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelForbidden) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelForbidden) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Channels_ChannelParticipant struct implement
type Channels_ChannelParticipant struct {
	Constructor int32                            `json:"constructor"`
	Data        Channels_ChannelParticipant_Data `json:"data"`
}

func (st *Channels_ChannelParticipant) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Channels_ChannelParticipant) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Channels_ChannelParticipant) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Channels_ChannelParticipant, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Channels_ChannelParticipant) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Channels_ChannelParticipant) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Channels_ChannelParticipant_Data struct implement
type Channels_ChannelParticipant_Data struct {
	Participant ChannelParticipant `json:"participant"`
	Users       []User             `json:"users"`
}

func (st *Channels_ChannelParticipant_Data) ResetDefault() {
	st.Participant.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Channels_ChannelParticipant_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Participant.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Users[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Channels_ChannelParticipant_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Channels_ChannelParticipant_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Channels_ChannelParticipant_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Participant.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Channels_ChannelParticipant_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_channelParticipant struct implement
type TLchannels_channelParticipant struct {
	Data Channels_ChannelParticipant_Data `json:"data"`
}

func (st *TLchannels_channelParticipant) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_channelParticipant) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_channelParticipant) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_channelParticipant, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_channelParticipant) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_channelParticipant) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// EmojiLanguage struct implement
type EmojiLanguage struct {
	Constructor int32              `json:"constructor"`
	Data        EmojiLanguage_Data `json:"data"`
}

func (st *EmojiLanguage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *EmojiLanguage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *EmojiLanguage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EmojiLanguage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *EmojiLanguage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *EmojiLanguage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// EmojiLanguage_Data struct implement
type EmojiLanguage_Data struct {
	Lang_code string `json:"lang_code"`
}

func (st *EmojiLanguage_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *EmojiLanguage_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Lang_code, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *EmojiLanguage_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EmojiLanguage_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *EmojiLanguage_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Lang_code, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *EmojiLanguage_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLemojiLanguage struct implement
type TLemojiLanguage struct {
	Data EmojiLanguage_Data `json:"data"`
}

func (st *TLemojiLanguage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLemojiLanguage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLemojiLanguage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLemojiLanguage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLemojiLanguage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLemojiLanguage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Game struct implement
type Game struct {
	Constructor int32     `json:"constructor"`
	Data        Game_Data `json:"data"`
}

func (st *Game) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Game) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Game) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Game, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Game) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Game) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Game_Data struct implement
type Game_Data struct {
	Id          int64    `json:"id"`
	Access_hash int64    `json:"access_hash"`
	Short_name  string   `json:"short_name"`
	Title       string   `json:"title"`
	Description string   `json:"description"`
	Photo       Photo    `json:"photo"`
	Document    Document `json:"document"`
}

func (st *Game_Data) ResetDefault() {
	st.Photo.ResetDefault()
	st.Document.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Game_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Short_name, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Description, 4, false)
	if err != nil {
		return err
	}

	err = st.Photo.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = st.Document.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Game_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Game_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Game_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Short_name, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Description, 4)
	if err != nil {
		return err
	}

	err = st.Photo.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = st.Document.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Game_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLgame struct implement
type TLgame struct {
	Data Game_Data `json:"data"`
}

func (st *TLgame) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLgame) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLgame) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLgame, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLgame) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLgame) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Bool struct implement
type Bool struct {
	Constructor int32     `json:"constructor"`
	Data        Bool_Data `json:"data"`
}

func (st *Bool) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Bool) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Bool) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Bool, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Bool) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Bool) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Bool_Data struct implement
type Bool_Data struct {
}

func (st *Bool_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Bool_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Bool_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Bool_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Bool_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Bool_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLboolFalse struct implement
type TLboolFalse struct {
	Data Bool_Data `json:"data"`
}

func (st *TLboolFalse) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLboolFalse) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLboolFalse) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLboolFalse, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLboolFalse) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLboolFalse) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLboolTrue struct implement
type TLboolTrue struct {
	Data Bool_Data `json:"data"`
}

func (st *TLboolTrue) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLboolTrue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLboolTrue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLboolTrue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLboolTrue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLboolTrue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_TermsOfService struct implement
type Help_TermsOfService struct {
	Constructor int32                    `json:"constructor"`
	Data        Help_TermsOfService_Data `json:"data"`
}

func (st *Help_TermsOfService) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_TermsOfService) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_TermsOfService) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_TermsOfService, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_TermsOfService) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_TermsOfService) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_TermsOfService_Data struct implement
type Help_TermsOfService_Data struct {
	Popup           bool            `json:"popup"`
	Id              DataJSON        `json:"id"`
	Text            string          `json:"text"`
	Entities        []MessageEntity `json:"entities"`
	Min_age_confirm int32           `json:"min_age_confirm"`
}

func (st *Help_TermsOfService_Data) ResetDefault() {
	st.Id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_TermsOfService_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Popup, 0, false)
	if err != nil {
		return err
	}

	err = st.Id.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Text, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Min_age_confirm, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_TermsOfService_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_TermsOfService_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_TermsOfService_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Popup, 0)
	if err != nil {
		return err
	}

	err = st.Id.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Text, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Min_age_confirm, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_TermsOfService_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_termsOfService struct implement
type TLhelp_termsOfService struct {
	Data Help_TermsOfService_Data `json:"data"`
}

func (st *TLhelp_termsOfService) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_termsOfService) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_termsOfService) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_termsOfService, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_termsOfService) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_termsOfService) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Message struct implement
type Message struct {
	Constructor int32        `json:"constructor"`
	Data        Message_Data `json:"data"`
}

func (st *Message) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Message) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Message) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Message, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Message) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Message) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Message_Data struct implement
type Message_Data struct {
	Id                 int32               `json:"id"`
	Out_key            bool                `json:"out_key"`
	Mentioned          bool                `json:"mentioned"`
	Media_unread       bool                `json:"media_unread"`
	Silent             bool                `json:"silent"`
	Post               bool                `json:"post"`
	From_scheduled     bool                `json:"from_scheduled"`
	Legacy             bool                `json:"legacy"`
	Edit_hide          bool                `json:"edit_hide"`
	Pinned             bool                `json:"pinned"`
	From_id            Peer                `json:"from_id"`
	Peer_id            Peer                `json:"peer_id"`
	Fwd_from           MessageFwdHeader    `json:"fwd_from"`
	Via_bot_id         int32               `json:"via_bot_id"`
	Reply_to           MessageReplyHeader  `json:"reply_to"`
	Date               int32               `json:"date"`
	Message            string              `json:"message"`
	Media              MessageMedia        `json:"media"`
	Reply_markup       ReplyMarkup         `json:"reply_markup"`
	Entities           []MessageEntity     `json:"entities"`
	Views              int32               `json:"views"`
	Forwards           int32               `json:"forwards"`
	Replies            MessageReplies      `json:"replies"`
	Edit_date          int32               `json:"edit_date"`
	Post_author        string              `json:"post_author"`
	Grouped_id         int64               `json:"grouped_id"`
	Restriction_reason []RestrictionReason `json:"restriction_reason"`
	Action             MessageAction       `json:"action"`
}

func (st *Message_Data) ResetDefault() {
	st.From_id.ResetDefault()
	st.Peer_id.ResetDefault()
	st.Fwd_from.ResetDefault()
	st.Reply_to.ResetDefault()
	st.Media.ResetDefault()
	st.Reply_markup.ResetDefault()
	st.Replies.ResetDefault()
	st.Action.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Message_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Out_key, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Mentioned, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Media_unread, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Silent, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Post, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.From_scheduled, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Legacy, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Edit_hide, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Pinned, 9, false)
	if err != nil {
		return err
	}

	err = st.From_id.ReadBlock(_is, 10, false)
	if err != nil {
		return err
	}

	err = st.Peer_id.ReadBlock(_is, 11, false)
	if err != nil {
		return err
	}

	err = st.Fwd_from.ReadBlock(_is, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Via_bot_id, 13, false)
	if err != nil {
		return err
	}

	err = st.Reply_to.ReadBlock(_is, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 16, false)
	if err != nil {
		return err
	}

	err = st.Media.ReadBlock(_is, 17, false)
	if err != nil {
		return err
	}

	err = st.Reply_markup.ReadBlock(_is, 18, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(19, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Views, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Forwards, 21, false)
	if err != nil {
		return err
	}

	err = st.Replies.ReadBlock(_is, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Edit_date, 23, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Post_author, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Grouped_id, 25, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(26, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Restriction_reason = make([]RestrictionReason, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Restriction_reason[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Action.ReadBlock(_is, 27, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Message_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Message_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Message_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Out_key, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Mentioned, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Media_unread, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Silent, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Post, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.From_scheduled, 6)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Legacy, 7)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Edit_hide, 8)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Pinned, 9)
	if err != nil {
		return err
	}

	err = st.From_id.WriteBlock(_os, 10)
	if err != nil {
		return err
	}

	err = st.Peer_id.WriteBlock(_os, 11)
	if err != nil {
		return err
	}

	err = st.Fwd_from.WriteBlock(_os, 12)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Via_bot_id, 13)
	if err != nil {
		return err
	}

	err = st.Reply_to.WriteBlock(_os, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 15)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 16)
	if err != nil {
		return err
	}

	err = st.Media.WriteBlock(_os, 17)
	if err != nil {
		return err
	}

	err = st.Reply_markup.WriteBlock(_os, 18)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 19)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Views, 20)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Forwards, 21)
	if err != nil {
		return err
	}

	err = st.Replies.WriteBlock(_os, 22)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Edit_date, 23)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Post_author, 24)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Grouped_id, 25)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 26)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Restriction_reason)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Restriction_reason {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Action.WriteBlock(_os, 27)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Message_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageEmpty struct implement
type TLmessageEmpty struct {
	Data Message_Data `json:"data"`
}

func (st *TLmessageEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessage struct implement
type TLmessage struct {
	Data Message_Data `json:"data"`
}

func (st *TLmessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageService struct implement
type TLmessageService struct {
	Data Message_Data `json:"data"`
}

func (st *TLmessageService) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageService) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageService) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageService, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageService) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageService) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// DcOption struct implement
type DcOption struct {
	Constructor int32         `json:"constructor"`
	Data        DcOption_Data `json:"data"`
}

func (st *DcOption) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *DcOption) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DcOption) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DcOption, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DcOption) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DcOption) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// DcOption_Data struct implement
type DcOption_Data struct {
	Ipv6       bool    `json:"ipv6"`
	Media_only bool    `json:"media_only"`
	Tcpo_only  bool    `json:"tcpo_only"`
	Cdn        bool    `json:"cdn"`
	Static     bool    `json:"static"`
	Id         int32   `json:"id"`
	Ip_address string  `json:"ip_address"`
	Port       int32   `json:"port"`
	Secret     []uint8 `json:"secret"`
}

func (st *DcOption_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *DcOption_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Ipv6, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Media_only, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Tcpo_only, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Cdn, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Static, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Id, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Ip_address, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Port, 7, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Secret = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Secret[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Secret, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DcOption_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DcOption_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DcOption_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Ipv6, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Media_only, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Tcpo_only, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Cdn, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Static, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Id, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Ip_address, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Port, 7)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Secret)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Secret {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DcOption_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdcOption struct implement
type TLdcOption struct {
	Data DcOption_Data `json:"data"`
}

func (st *TLdcOption) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdcOption) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdcOption) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdcOption, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdcOption) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdcOption) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// EncryptedFile struct implement
type EncryptedFile struct {
	Constructor int32              `json:"constructor"`
	Data        EncryptedFile_Data `json:"data"`
}

func (st *EncryptedFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *EncryptedFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *EncryptedFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EncryptedFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *EncryptedFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *EncryptedFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// EncryptedFile_Data struct implement
type EncryptedFile_Data struct {
	Id              int64 `json:"id"`
	Access_hash     int64 `json:"access_hash"`
	Size            int32 `json:"size"`
	Dc_id           int32 `json:"dc_id"`
	Key_fingerprint int32 `json:"key_fingerprint"`
}

func (st *EncryptedFile_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *EncryptedFile_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Size, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Dc_id, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Key_fingerprint, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *EncryptedFile_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EncryptedFile_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *EncryptedFile_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Size, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Dc_id, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Key_fingerprint, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *EncryptedFile_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLencryptedFileEmpty struct implement
type TLencryptedFileEmpty struct {
	Data EncryptedFile_Data `json:"data"`
}

func (st *TLencryptedFileEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLencryptedFileEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLencryptedFileEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLencryptedFileEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLencryptedFileEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLencryptedFileEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLencryptedFile struct implement
type TLencryptedFile struct {
	Data EncryptedFile_Data `json:"data"`
}

func (st *TLencryptedFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLencryptedFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLencryptedFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLencryptedFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLencryptedFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLencryptedFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_RecentStickers struct implement
type Messages_RecentStickers struct {
	Constructor int32                        `json:"constructor"`
	Data        Messages_RecentStickers_Data `json:"data"`
}

func (st *Messages_RecentStickers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_RecentStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_RecentStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_RecentStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_RecentStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_RecentStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_RecentStickers_Data struct implement
type Messages_RecentStickers_Data struct {
	Hash     int32         `json:"hash"`
	Packs    []StickerPack `json:"packs"`
	Stickers []Document    `json:"stickers"`
	Dates    []int32       `json:"dates"`
}

func (st *Messages_RecentStickers_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_RecentStickers_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Packs = make([]StickerPack, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Packs[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Stickers = make([]Document, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Stickers[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Dates = make([]int32, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = _is.Read_int32(&st.Dates[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_RecentStickers_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_RecentStickers_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_RecentStickers_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Packs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Packs {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Stickers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Stickers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Dates)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Dates {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_RecentStickers_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_recentStickersNotModified struct implement
type TLmessages_recentStickersNotModified struct {
	Data Messages_RecentStickers_Data `json:"data"`
}

func (st *TLmessages_recentStickersNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_recentStickersNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_recentStickersNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_recentStickersNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_recentStickersNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_recentStickersNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_recentStickers struct implement
type TLmessages_recentStickers struct {
	Data Messages_RecentStickers_Data `json:"data"`
}

func (st *TLmessages_recentStickers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_recentStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_recentStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_recentStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_recentStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_recentStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ReceivedNotifyMessage struct implement
type ReceivedNotifyMessage struct {
	Constructor int32                      `json:"constructor"`
	Data        ReceivedNotifyMessage_Data `json:"data"`
}

func (st *ReceivedNotifyMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ReceivedNotifyMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ReceivedNotifyMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ReceivedNotifyMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ReceivedNotifyMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ReceivedNotifyMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ReceivedNotifyMessage_Data struct implement
type ReceivedNotifyMessage_Data struct {
	Id    int32 `json:"id"`
	Flags int32 `json:"flags"`
}

func (st *ReceivedNotifyMessage_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *ReceivedNotifyMessage_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Flags, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ReceivedNotifyMessage_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ReceivedNotifyMessage_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ReceivedNotifyMessage_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Flags, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ReceivedNotifyMessage_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLreceivedNotifyMessage struct implement
type TLreceivedNotifyMessage struct {
	Data ReceivedNotifyMessage_Data `json:"data"`
}

func (st *TLreceivedNotifyMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLreceivedNotifyMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLreceivedNotifyMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLreceivedNotifyMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLreceivedNotifyMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLreceivedNotifyMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_Country struct implement
type Help_Country struct {
	Constructor int32             `json:"constructor"`
	Data        Help_Country_Data `json:"data"`
}

func (st *Help_Country) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_Country) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_Country) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_Country, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_Country) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_Country) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_Country_Data struct implement
type Help_Country_Data struct {
	Hidden        bool               `json:"hidden"`
	Iso2          string             `json:"iso2"`
	Default_name  string             `json:"default_name"`
	Name          string             `json:"name"`
	Country_codes []Help_CountryCode `json:"country_codes"`
}

func (st *Help_Country_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_Country_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Hidden, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Iso2, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Default_name, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Name, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Country_codes = make([]Help_CountryCode, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Country_codes[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_Country_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_Country_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_Country_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Hidden, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Iso2, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Default_name, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Name, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Country_codes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Country_codes {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_Country_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_country struct implement
type TLhelp_country struct {
	Data Help_Country_Data `json:"data"`
}

func (st *TLhelp_country) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_country) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_country) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_country, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_country) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_country) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChatAdminRights struct implement
type ChatAdminRights struct {
	Constructor int32                `json:"constructor"`
	Data        ChatAdminRights_Data `json:"data"`
}

func (st *ChatAdminRights) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChatAdminRights) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChatAdminRights) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChatAdminRights, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChatAdminRights) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChatAdminRights) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChatAdminRights_Data struct implement
type ChatAdminRights_Data struct {
	Change_info     bool `json:"change_info"`
	Post_messages   bool `json:"post_messages"`
	Edit_messages   bool `json:"edit_messages"`
	Delete_messages bool `json:"delete_messages"`
	Ban_users       bool `json:"ban_users"`
	Invite_users    bool `json:"invite_users"`
	Pin_messages    bool `json:"pin_messages"`
	Add_admins      bool `json:"add_admins"`
	Anonymous       bool `json:"anonymous"`
	Manage_call     bool `json:"manage_call"`
}

func (st *ChatAdminRights_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *ChatAdminRights_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Change_info, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Post_messages, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Edit_messages, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Delete_messages, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Ban_users, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Invite_users, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Pin_messages, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Add_admins, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Anonymous, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Manage_call, 9, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChatAdminRights_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChatAdminRights_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChatAdminRights_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Change_info, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Post_messages, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Edit_messages, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Delete_messages, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Ban_users, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Invite_users, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Pin_messages, 6)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Add_admins, 7)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Anonymous, 8)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Manage_call, 9)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChatAdminRights_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatAdminRights struct implement
type TLchatAdminRights struct {
	Data ChatAdminRights_Data `json:"data"`
}

func (st *TLchatAdminRights) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatAdminRights) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatAdminRights) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatAdminRights, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatAdminRights) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatAdminRights) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// WebPage struct implement
type WebPage struct {
	Constructor int32        `json:"constructor"`
	Data        WebPage_Data `json:"data"`
}

func (st *WebPage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *WebPage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *WebPage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require WebPage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *WebPage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *WebPage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// WebPage_Data struct implement
type WebPage_Data struct {
	Id                int64              `json:"id"`
	Date              int32              `json:"date"`
	Url               string             `json:"url"`
	Display_url       string             `json:"display_url"`
	Hash              int32              `json:"hash"`
	Type              string             `json:"type"`
	Site_name         string             `json:"site_name"`
	Title             string             `json:"title"`
	Description       string             `json:"description"`
	Photo             Photo              `json:"photo"`
	Embed_url         string             `json:"embed_url"`
	Embed_type        string             `json:"embed_type"`
	Embed_width       int32              `json:"embed_width"`
	Embed_height      int32              `json:"embed_height"`
	Duration          int32              `json:"duration"`
	Author            string             `json:"author"`
	Document          Document           `json:"document"`
	Cached_page       Page               `json:"cached_page"`
	Attributes        []WebPageAttribute `json:"attributes"`
	Cached_page_views int32              `json:"cached_page_views"`
}

func (st *WebPage_Data) ResetDefault() {
	st.Photo.ResetDefault()
	st.Document.ResetDefault()
	st.Cached_page.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *WebPage_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Url, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Display_url, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Type, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Site_name, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Description, 8, false)
	if err != nil {
		return err
	}

	err = st.Photo.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Embed_url, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Embed_type, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Embed_width, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Embed_height, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Duration, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Author, 15, false)
	if err != nil {
		return err
	}

	err = st.Document.ReadBlock(_is, 16, false)
	if err != nil {
		return err
	}

	err = st.Cached_page.ReadBlock(_is, 17, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(18, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Attributes = make([]WebPageAttribute, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Attributes[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Cached_page_views, 19, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *WebPage_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require WebPage_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *WebPage_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Url, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Display_url, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Type, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Site_name, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Description, 8)
	if err != nil {
		return err
	}

	err = st.Photo.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Embed_url, 10)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Embed_type, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Embed_width, 12)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Embed_height, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Duration, 14)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Author, 15)
	if err != nil {
		return err
	}

	err = st.Document.WriteBlock(_os, 16)
	if err != nil {
		return err
	}

	err = st.Cached_page.WriteBlock(_os, 17)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 18)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Attributes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Attributes {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Cached_page_views, 19)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *WebPage_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLwebPageEmpty struct implement
type TLwebPageEmpty struct {
	Data WebPage_Data `json:"data"`
}

func (st *TLwebPageEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLwebPageEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLwebPageEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLwebPageEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLwebPageEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLwebPageEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLwebPagePending struct implement
type TLwebPagePending struct {
	Data WebPage_Data `json:"data"`
}

func (st *TLwebPagePending) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLwebPagePending) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLwebPagePending) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLwebPagePending, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLwebPagePending) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLwebPagePending) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLwebPage struct implement
type TLwebPage struct {
	Data WebPage_Data `json:"data"`
}

func (st *TLwebPage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLwebPage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLwebPage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLwebPage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLwebPage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLwebPage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLwebPageNotModified struct implement
type TLwebPageNotModified struct {
	Data WebPage_Data `json:"data"`
}

func (st *TLwebPageNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLwebPageNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLwebPageNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLwebPageNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLwebPageNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLwebPageNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// FileHash struct implement
type FileHash struct {
	Constructor int32         `json:"constructor"`
	Data        FileHash_Data `json:"data"`
}

func (st *FileHash) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *FileHash) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *FileHash) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require FileHash, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *FileHash) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *FileHash) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// FileHash_Data struct implement
type FileHash_Data struct {
	Offset int32   `json:"offset"`
	Limit  int32   `json:"limit"`
	Hash   []uint8 `json:"hash"`
}

func (st *FileHash_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *FileHash_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Offset, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Hash = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Hash[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Hash, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *FileHash_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require FileHash_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *FileHash_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Offset, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Hash)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Hash {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *FileHash_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLfileHash struct implement
type TLfileHash struct {
	Data FileHash_Data `json:"data"`
}

func (st *TLfileHash) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLfileHash) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLfileHash) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLfileHash, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLfileHash) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLfileHash) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// GlobalPrivacySettings struct implement
type GlobalPrivacySettings struct {
	Constructor int32                      `json:"constructor"`
	Data        GlobalPrivacySettings_Data `json:"data"`
}

func (st *GlobalPrivacySettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *GlobalPrivacySettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GlobalPrivacySettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GlobalPrivacySettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GlobalPrivacySettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GlobalPrivacySettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// GlobalPrivacySettings_Data struct implement
type GlobalPrivacySettings_Data struct {
	Archive_and_mute_new_noncontact_peers Bool `json:"archive_and_mute_new_noncontact_peers"`
}

func (st *GlobalPrivacySettings_Data) ResetDefault() {
	st.Archive_and_mute_new_noncontact_peers.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *GlobalPrivacySettings_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Archive_and_mute_new_noncontact_peers.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *GlobalPrivacySettings_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GlobalPrivacySettings_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *GlobalPrivacySettings_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Archive_and_mute_new_noncontact_peers.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *GlobalPrivacySettings_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLglobalPrivacySettings struct implement
type TLglobalPrivacySettings struct {
	Data GlobalPrivacySettings_Data `json:"data"`
}

func (st *TLglobalPrivacySettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLglobalPrivacySettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLglobalPrivacySettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLglobalPrivacySettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLglobalPrivacySettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLglobalPrivacySettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// DataJSON struct implement
type DataJSON struct {
	Constructor int32         `json:"constructor"`
	Data        DataJSON_Data `json:"data"`
}

func (st *DataJSON) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *DataJSON) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DataJSON) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DataJSON, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DataJSON) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DataJSON) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// DataJSON_Data struct implement
type DataJSON_Data struct {
	Data string `json:"data"`
}

func (st *DataJSON_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *DataJSON_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Data, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DataJSON_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DataJSON_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DataJSON_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Data, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DataJSON_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdataJSON struct implement
type TLdataJSON struct {
	Data DataJSON_Data `json:"data"`
}

func (st *TLdataJSON) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdataJSON) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdataJSON) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdataJSON, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdataJSON) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdataJSON) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecurePlainData struct implement
type SecurePlainData struct {
	Constructor int32                `json:"constructor"`
	Data        SecurePlainData_Data `json:"data"`
}

func (st *SecurePlainData) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SecurePlainData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecurePlainData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecurePlainData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecurePlainData) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecurePlainData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecurePlainData_Data struct implement
type SecurePlainData_Data struct {
	Phone string `json:"phone"`
	Email string `json:"email"`
}

func (st *SecurePlainData_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *SecurePlainData_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Phone, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Email, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecurePlainData_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecurePlainData_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecurePlainData_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Phone, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Email, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecurePlainData_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecurePlainPhone struct implement
type TLsecurePlainPhone struct {
	Data SecurePlainData_Data `json:"data"`
}

func (st *TLsecurePlainPhone) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecurePlainPhone) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecurePlainPhone) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecurePlainPhone, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecurePlainPhone) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecurePlainPhone) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecurePlainEmail struct implement
type TLsecurePlainEmail struct {
	Data SecurePlainData_Data `json:"data"`
}

func (st *TLsecurePlainEmail) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecurePlainEmail) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecurePlainEmail) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecurePlainEmail, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecurePlainEmail) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecurePlainEmail) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Null struct implement
type Null struct {
	Constructor int32     `json:"constructor"`
	Data        Null_Data `json:"data"`
}

func (st *Null) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Null) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Null) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Null, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Null) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Null) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Null_Data struct implement
type Null_Data struct {
}

func (st *Null_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Null_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Null_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Null_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Null_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Null_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLnull struct implement
type TLnull struct {
	Data Null_Data `json:"data"`
}

func (st *TLnull) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLnull) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLnull) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLnull, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLnull) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLnull) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StatsGraph struct implement
type StatsGraph struct {
	Constructor int32           `json:"constructor"`
	Data        StatsGraph_Data `json:"data"`
}

func (st *StatsGraph) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *StatsGraph) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StatsGraph) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StatsGraph, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StatsGraph) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StatsGraph) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StatsGraph_Data struct implement
type StatsGraph_Data struct {
	Token      string   `json:"token"`
	Error      string   `json:"error"`
	Json       DataJSON `json:"json"`
	Zoom_token string   `json:"zoom_token"`
}

func (st *StatsGraph_Data) ResetDefault() {
	st.Json.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *StatsGraph_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Token, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Error, 1, false)
	if err != nil {
		return err
	}

	err = st.Json.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Zoom_token, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StatsGraph_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StatsGraph_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StatsGraph_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Token, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Error, 1)
	if err != nil {
		return err
	}

	err = st.Json.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Zoom_token, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StatsGraph_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstatsGraphAsync struct implement
type TLstatsGraphAsync struct {
	Data StatsGraph_Data `json:"data"`
}

func (st *TLstatsGraphAsync) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstatsGraphAsync) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstatsGraphAsync) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstatsGraphAsync, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstatsGraphAsync) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstatsGraphAsync) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstatsGraphError struct implement
type TLstatsGraphError struct {
	Data StatsGraph_Data `json:"data"`
}

func (st *TLstatsGraphError) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstatsGraphError) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstatsGraphError) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstatsGraphError, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstatsGraphError) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstatsGraphError) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstatsGraph struct implement
type TLstatsGraph struct {
	Data StatsGraph_Data `json:"data"`
}

func (st *TLstatsGraph) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstatsGraph) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstatsGraph) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstatsGraph, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstatsGraph) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstatsGraph) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// EncryptedChat struct implement
type EncryptedChat struct {
	Constructor int32              `json:"constructor"`
	Data        EncryptedChat_Data `json:"data"`
}

func (st *EncryptedChat) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *EncryptedChat) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *EncryptedChat) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EncryptedChat, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *EncryptedChat) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *EncryptedChat) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// EncryptedChat_Data struct implement
type EncryptedChat_Data struct {
	Id              int32   `json:"id"`
	Access_hash     int64   `json:"access_hash"`
	Date            int32   `json:"date"`
	Admin_id        int32   `json:"admin_id"`
	Participant_id  int32   `json:"participant_id"`
	Folder_id       int32   `json:"folder_id"`
	G_a             []uint8 `json:"g_a"`
	G_a_or_b        []uint8 `json:"g_a_or_b"`
	Key_fingerprint int64   `json:"key_fingerprint"`
}

func (st *EncryptedChat_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *EncryptedChat_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Admin_id, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Participant_id, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Folder_id, 5, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.G_a = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.G_a[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.G_a, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.G_a_or_b = make([]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_uint8(&st.G_a_or_b[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.G_a_or_b, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int64(&st.Key_fingerprint, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *EncryptedChat_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EncryptedChat_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *EncryptedChat_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Admin_id, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Participant_id, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Folder_id, 5)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.G_a)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.G_a {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.G_a_or_b)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.G_a_or_b {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int64(st.Key_fingerprint, 8)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *EncryptedChat_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLencryptedChatEmpty struct implement
type TLencryptedChatEmpty struct {
	Data EncryptedChat_Data `json:"data"`
}

func (st *TLencryptedChatEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLencryptedChatEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLencryptedChatEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLencryptedChatEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLencryptedChatEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLencryptedChatEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLencryptedChatWaiting struct implement
type TLencryptedChatWaiting struct {
	Data EncryptedChat_Data `json:"data"`
}

func (st *TLencryptedChatWaiting) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLencryptedChatWaiting) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLencryptedChatWaiting) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLencryptedChatWaiting, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLencryptedChatWaiting) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLencryptedChatWaiting) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLencryptedChatRequested struct implement
type TLencryptedChatRequested struct {
	Data EncryptedChat_Data `json:"data"`
}

func (st *TLencryptedChatRequested) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLencryptedChatRequested) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLencryptedChatRequested) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLencryptedChatRequested, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLencryptedChatRequested) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLencryptedChatRequested) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLencryptedChat struct implement
type TLencryptedChat struct {
	Data EncryptedChat_Data `json:"data"`
}

func (st *TLencryptedChat) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLencryptedChat) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLencryptedChat) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLencryptedChat, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLencryptedChat) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLencryptedChat) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLencryptedChatDiscarded struct implement
type TLencryptedChatDiscarded struct {
	Data EncryptedChat_Data `json:"data"`
}

func (st *TLencryptedChatDiscarded) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLencryptedChatDiscarded) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLencryptedChatDiscarded) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLencryptedChatDiscarded, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLencryptedChatDiscarded) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLencryptedChatDiscarded) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Storage_FileType struct implement
type Storage_FileType struct {
	Constructor int32                 `json:"constructor"`
	Data        Storage_FileType_Data `json:"data"`
}

func (st *Storage_FileType) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Storage_FileType) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Storage_FileType) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Storage_FileType, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Storage_FileType) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Storage_FileType) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Storage_FileType_Data struct implement
type Storage_FileType_Data struct {
}

func (st *Storage_FileType_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Storage_FileType_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Storage_FileType_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Storage_FileType_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Storage_FileType_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Storage_FileType_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstorage_fileUnknown struct implement
type TLstorage_fileUnknown struct {
	Data Storage_FileType_Data `json:"data"`
}

func (st *TLstorage_fileUnknown) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstorage_fileUnknown) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstorage_fileUnknown) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstorage_fileUnknown, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstorage_fileUnknown) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstorage_fileUnknown) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstorage_filePartial struct implement
type TLstorage_filePartial struct {
	Data Storage_FileType_Data `json:"data"`
}

func (st *TLstorage_filePartial) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstorage_filePartial) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstorage_filePartial) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstorage_filePartial, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstorage_filePartial) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstorage_filePartial) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstorage_fileJpeg struct implement
type TLstorage_fileJpeg struct {
	Data Storage_FileType_Data `json:"data"`
}

func (st *TLstorage_fileJpeg) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstorage_fileJpeg) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstorage_fileJpeg) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstorage_fileJpeg, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstorage_fileJpeg) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstorage_fileJpeg) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstorage_fileGif struct implement
type TLstorage_fileGif struct {
	Data Storage_FileType_Data `json:"data"`
}

func (st *TLstorage_fileGif) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstorage_fileGif) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstorage_fileGif) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstorage_fileGif, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstorage_fileGif) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstorage_fileGif) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstorage_filePng struct implement
type TLstorage_filePng struct {
	Data Storage_FileType_Data `json:"data"`
}

func (st *TLstorage_filePng) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstorage_filePng) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstorage_filePng) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstorage_filePng, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstorage_filePng) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstorage_filePng) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstorage_filePdf struct implement
type TLstorage_filePdf struct {
	Data Storage_FileType_Data `json:"data"`
}

func (st *TLstorage_filePdf) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstorage_filePdf) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstorage_filePdf) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstorage_filePdf, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstorage_filePdf) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstorage_filePdf) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstorage_fileMp3 struct implement
type TLstorage_fileMp3 struct {
	Data Storage_FileType_Data `json:"data"`
}

func (st *TLstorage_fileMp3) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstorage_fileMp3) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstorage_fileMp3) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstorage_fileMp3, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstorage_fileMp3) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstorage_fileMp3) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstorage_fileMov struct implement
type TLstorage_fileMov struct {
	Data Storage_FileType_Data `json:"data"`
}

func (st *TLstorage_fileMov) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstorage_fileMov) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstorage_fileMov) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstorage_fileMov, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstorage_fileMov) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstorage_fileMov) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstorage_fileMp4 struct implement
type TLstorage_fileMp4 struct {
	Data Storage_FileType_Data `json:"data"`
}

func (st *TLstorage_fileMp4) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstorage_fileMp4) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstorage_fileMp4) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstorage_fileMp4, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstorage_fileMp4) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstorage_fileMp4) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstorage_fileWebp struct implement
type TLstorage_fileWebp struct {
	Data Storage_FileType_Data `json:"data"`
}

func (st *TLstorage_fileWebp) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstorage_fileWebp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstorage_fileWebp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstorage_fileWebp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstorage_fileWebp) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstorage_fileWebp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_Stickers struct implement
type Messages_Stickers struct {
	Constructor int32                  `json:"constructor"`
	Data        Messages_Stickers_Data `json:"data"`
}

func (st *Messages_Stickers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_Stickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_Stickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_Stickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_Stickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_Stickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_Stickers_Data struct implement
type Messages_Stickers_Data struct {
	Hash     int32      `json:"hash"`
	Stickers []Document `json:"stickers"`
}

func (st *Messages_Stickers_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_Stickers_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Stickers = make([]Document, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Stickers[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_Stickers_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_Stickers_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_Stickers_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Stickers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Stickers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_Stickers_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_stickersNotModified struct implement
type TLmessages_stickersNotModified struct {
	Data Messages_Stickers_Data `json:"data"`
}

func (st *TLmessages_stickersNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_stickersNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_stickersNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_stickersNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_stickersNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_stickersNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_stickers struct implement
type TLmessages_stickers struct {
	Data Messages_Stickers_Data `json:"data"`
}

func (st *TLmessages_stickers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_stickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_stickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_stickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_stickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_stickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PhoneCallProtocol struct implement
type PhoneCallProtocol struct {
	Constructor int32                  `json:"constructor"`
	Data        PhoneCallProtocol_Data `json:"data"`
}

func (st *PhoneCallProtocol) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PhoneCallProtocol) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PhoneCallProtocol) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PhoneCallProtocol, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PhoneCallProtocol) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PhoneCallProtocol) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PhoneCallProtocol_Data struct implement
type PhoneCallProtocol_Data struct {
	Udp_p2p          bool     `json:"udp_p2p"`
	Udp_reflector    bool     `json:"udp_reflector"`
	Min_layer        int32    `json:"min_layer"`
	Max_layer        int32    `json:"max_layer"`
	Library_versions []string `json:"library_versions"`
}

func (st *PhoneCallProtocol_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *PhoneCallProtocol_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Udp_p2p, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Udp_reflector, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Min_layer, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_layer, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Library_versions = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_string(&st.Library_versions[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PhoneCallProtocol_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PhoneCallProtocol_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PhoneCallProtocol_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Udp_p2p, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Udp_reflector, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Min_layer, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_layer, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Library_versions)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Library_versions {

		err = _os.Write_string(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PhoneCallProtocol_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphoneCallProtocol struct implement
type TLphoneCallProtocol struct {
	Data PhoneCallProtocol_Data `json:"data"`
}

func (st *TLphoneCallProtocol) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphoneCallProtocol) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphoneCallProtocol) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphoneCallProtocol, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphoneCallProtocol) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphoneCallProtocol) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PollAnswerVoters struct implement
type PollAnswerVoters struct {
	Constructor int32                 `json:"constructor"`
	Data        PollAnswerVoters_Data `json:"data"`
}

func (st *PollAnswerVoters) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PollAnswerVoters) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PollAnswerVoters) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PollAnswerVoters, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PollAnswerVoters) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PollAnswerVoters) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PollAnswerVoters_Data struct implement
type PollAnswerVoters_Data struct {
	Chosen  bool    `json:"chosen"`
	Correct bool    `json:"correct"`
	Option  []uint8 `json:"option"`
	Voters  int32   `json:"voters"`
}

func (st *PollAnswerVoters_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *PollAnswerVoters_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Chosen, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Correct, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Option = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Option[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Option, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Voters, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PollAnswerVoters_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PollAnswerVoters_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PollAnswerVoters_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Chosen, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Correct, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Option)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Option {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Voters, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PollAnswerVoters_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpollAnswerVoters struct implement
type TLpollAnswerVoters struct {
	Data PollAnswerVoters_Data `json:"data"`
}

func (st *TLpollAnswerVoters) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpollAnswerVoters) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpollAnswerVoters) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpollAnswerVoters, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpollAnswerVoters) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpollAnswerVoters) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Channels_AdminLogResults struct implement
type Channels_AdminLogResults struct {
	Constructor int32                         `json:"constructor"`
	Data        Channels_AdminLogResults_Data `json:"data"`
}

func (st *Channels_AdminLogResults) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Channels_AdminLogResults) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Channels_AdminLogResults) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Channels_AdminLogResults, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Channels_AdminLogResults) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Channels_AdminLogResults) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Channels_AdminLogResults_Data struct implement
type Channels_AdminLogResults_Data struct {
	Events []ChannelAdminLogEvent `json:"events"`
	Chats  []Chat                 `json:"chats"`
	Users  []User                 `json:"users"`
}

func (st *Channels_AdminLogResults_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Channels_AdminLogResults_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Events = make([]ChannelAdminLogEvent, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Events[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Chats[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Users[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Channels_AdminLogResults_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Channels_AdminLogResults_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Channels_AdminLogResults_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Events)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Events {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Channels_AdminLogResults_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_adminLogResults struct implement
type TLchannels_adminLogResults struct {
	Data Channels_AdminLogResults_Data `json:"data"`
}

func (st *TLchannels_adminLogResults) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_adminLogResults) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_adminLogResults) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_adminLogResults, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_adminLogResults) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_adminLogResults) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Stats_BroadcastStats struct implement
type Stats_BroadcastStats struct {
	Constructor int32                     `json:"constructor"`
	Data        Stats_BroadcastStats_Data `json:"data"`
}

func (st *Stats_BroadcastStats) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Stats_BroadcastStats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Stats_BroadcastStats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Stats_BroadcastStats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Stats_BroadcastStats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Stats_BroadcastStats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Stats_BroadcastStats_Data struct implement
type Stats_BroadcastStats_Data struct {
	Period                        StatsDateRangeDays           `json:"period"`
	Followers                     StatsAbsValueAndPrev         `json:"followers"`
	Views_per_post                StatsAbsValueAndPrev         `json:"views_per_post"`
	Shares_per_post               StatsAbsValueAndPrev         `json:"shares_per_post"`
	Enabled_notifications         StatsPercentValue            `json:"enabled_notifications"`
	Growth_graph                  StatsGraph                   `json:"growth_graph"`
	Followers_graph               StatsGraph                   `json:"followers_graph"`
	Mute_graph                    StatsGraph                   `json:"mute_graph"`
	Top_hours_graph               StatsGraph                   `json:"top_hours_graph"`
	Interactions_graph            StatsGraph                   `json:"interactions_graph"`
	Iv_interactions_graph         StatsGraph                   `json:"iv_interactions_graph"`
	Views_by_source_graph         StatsGraph                   `json:"views_by_source_graph"`
	New_followers_by_source_graph StatsGraph                   `json:"new_followers_by_source_graph"`
	Languages_graph               StatsGraph                   `json:"languages_graph"`
	Recent_message_interactions   []MessageInteractionCounters `json:"recent_message_interactions"`
}

func (st *Stats_BroadcastStats_Data) ResetDefault() {
	st.Period.ResetDefault()
	st.Followers.ResetDefault()
	st.Views_per_post.ResetDefault()
	st.Shares_per_post.ResetDefault()
	st.Enabled_notifications.ResetDefault()
	st.Growth_graph.ResetDefault()
	st.Followers_graph.ResetDefault()
	st.Mute_graph.ResetDefault()
	st.Top_hours_graph.ResetDefault()
	st.Interactions_graph.ResetDefault()
	st.Iv_interactions_graph.ResetDefault()
	st.Views_by_source_graph.ResetDefault()
	st.New_followers_by_source_graph.ResetDefault()
	st.Languages_graph.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Stats_BroadcastStats_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Period.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Followers.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.Views_per_post.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = st.Shares_per_post.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = st.Enabled_notifications.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = st.Growth_graph.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = st.Followers_graph.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	err = st.Mute_graph.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	err = st.Top_hours_graph.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err = st.Interactions_graph.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err = st.Iv_interactions_graph.ReadBlock(_is, 10, false)
	if err != nil {
		return err
	}

	err = st.Views_by_source_graph.ReadBlock(_is, 11, false)
	if err != nil {
		return err
	}

	err = st.New_followers_by_source_graph.ReadBlock(_is, 12, false)
	if err != nil {
		return err
	}

	err = st.Languages_graph.ReadBlock(_is, 13, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(14, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Recent_message_interactions = make([]MessageInteractionCounters, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Recent_message_interactions[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Stats_BroadcastStats_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Stats_BroadcastStats_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Stats_BroadcastStats_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Period.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Followers.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.Views_per_post.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = st.Shares_per_post.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = st.Enabled_notifications.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = st.Growth_graph.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = st.Followers_graph.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	err = st.Mute_graph.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	err = st.Top_hours_graph.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = st.Interactions_graph.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = st.Iv_interactions_graph.WriteBlock(_os, 10)
	if err != nil {
		return err
	}

	err = st.Views_by_source_graph.WriteBlock(_os, 11)
	if err != nil {
		return err
	}

	err = st.New_followers_by_source_graph.WriteBlock(_os, 12)
	if err != nil {
		return err
	}

	err = st.Languages_graph.WriteBlock(_os, 13)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Recent_message_interactions)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Recent_message_interactions {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Stats_BroadcastStats_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstats_broadcastStats struct implement
type TLstats_broadcastStats struct {
	Data Stats_BroadcastStats_Data `json:"data"`
}

func (st *TLstats_broadcastStats) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstats_broadcastStats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstats_broadcastStats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstats_broadcastStats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstats_broadcastStats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstats_broadcastStats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecurePasswordKdfAlgo struct implement
type SecurePasswordKdfAlgo struct {
	Constructor int32                      `json:"constructor"`
	Data        SecurePasswordKdfAlgo_Data `json:"data"`
}

func (st *SecurePasswordKdfAlgo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SecurePasswordKdfAlgo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecurePasswordKdfAlgo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecurePasswordKdfAlgo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecurePasswordKdfAlgo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecurePasswordKdfAlgo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecurePasswordKdfAlgo_Data struct implement
type SecurePasswordKdfAlgo_Data struct {
	Salt []uint8 `json:"salt"`
}

func (st *SecurePasswordKdfAlgo_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *SecurePasswordKdfAlgo_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Salt = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Salt[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Salt, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecurePasswordKdfAlgo_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecurePasswordKdfAlgo_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecurePasswordKdfAlgo_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Salt)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Salt {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecurePasswordKdfAlgo_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecurePasswordKdfAlgoUnknown struct implement
type TLsecurePasswordKdfAlgoUnknown struct {
	Data SecurePasswordKdfAlgo_Data `json:"data"`
}

func (st *TLsecurePasswordKdfAlgoUnknown) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecurePasswordKdfAlgoUnknown) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecurePasswordKdfAlgoUnknown) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecurePasswordKdfAlgoUnknown, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecurePasswordKdfAlgoUnknown) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecurePasswordKdfAlgoUnknown) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecurePasswordKdfAlgoPBKDF2HMACSHA512iter100000 struct implement
type TLsecurePasswordKdfAlgoPBKDF2HMACSHA512iter100000 struct {
	Data SecurePasswordKdfAlgo_Data `json:"data"`
}

func (st *TLsecurePasswordKdfAlgoPBKDF2HMACSHA512iter100000) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecurePasswordKdfAlgoPBKDF2HMACSHA512iter100000) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecurePasswordKdfAlgoPBKDF2HMACSHA512iter100000) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecurePasswordKdfAlgoPBKDF2HMACSHA512iter100000, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecurePasswordKdfAlgoPBKDF2HMACSHA512iter100000) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecurePasswordKdfAlgoPBKDF2HMACSHA512iter100000) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecurePasswordKdfAlgoSHA512 struct implement
type TLsecurePasswordKdfAlgoSHA512 struct {
	Data SecurePasswordKdfAlgo_Data `json:"data"`
}

func (st *TLsecurePasswordKdfAlgoSHA512) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecurePasswordKdfAlgoSHA512) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecurePasswordKdfAlgoSHA512) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecurePasswordKdfAlgoSHA512, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecurePasswordKdfAlgoSHA512) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecurePasswordKdfAlgoSHA512) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Auth_Authorization struct implement
type Auth_Authorization struct {
	Constructor int32                   `json:"constructor"`
	Data        Auth_Authorization_Data `json:"data"`
}

func (st *Auth_Authorization) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Auth_Authorization) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Auth_Authorization) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Auth_Authorization, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Auth_Authorization) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Auth_Authorization) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Auth_Authorization_Data struct implement
type Auth_Authorization_Data struct {
	Tmp_sessions     int32               `json:"tmp_sessions"`
	User             User                `json:"user"`
	Terms_of_service Help_TermsOfService `json:"terms_of_service"`
}

func (st *Auth_Authorization_Data) ResetDefault() {
	st.User.ResetDefault()
	st.Terms_of_service.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Auth_Authorization_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Tmp_sessions, 0, false)
	if err != nil {
		return err
	}

	err = st.User.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.Terms_of_service.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Auth_Authorization_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Auth_Authorization_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Auth_Authorization_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Tmp_sessions, 0)
	if err != nil {
		return err
	}

	err = st.User.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.Terms_of_service.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Auth_Authorization_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_authorization struct implement
type TLauth_authorization struct {
	Data Auth_Authorization_Data `json:"data"`
}

func (st *TLauth_authorization) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_authorization) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_authorization) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_authorization, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_authorization) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_authorization) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_authorizationSignUpRequired struct implement
type TLauth_authorizationSignUpRequired struct {
	Data Auth_Authorization_Data `json:"data"`
}

func (st *TLauth_authorizationSignUpRequired) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_authorizationSignUpRequired) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_authorizationSignUpRequired) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_authorizationSignUpRequired, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_authorizationSignUpRequired) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_authorizationSignUpRequired) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputFileLocation struct implement
type InputFileLocation struct {
	Constructor int32                  `json:"constructor"`
	Data        InputFileLocation_Data `json:"data"`
}

func (st *InputFileLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputFileLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputFileLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputFileLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputFileLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputFileLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputFileLocation_Data struct implement
type InputFileLocation_Data struct {
	Volume_id      int64           `json:"volume_id"`
	Local_id       int32           `json:"local_id"`
	Secret         int64           `json:"secret"`
	File_reference []uint8         `json:"file_reference"`
	Id             int64           `json:"id"`
	Access_hash    int64           `json:"access_hash"`
	Thumb_size     string          `json:"thumb_size"`
	Big            bool            `json:"big"`
	Peer           InputPeer       `json:"peer"`
	Stickerset     InputStickerSet `json:"stickerset"`
}

func (st *InputFileLocation_Data) ResetDefault() {
	st.Peer.ResetDefault()
	st.Stickerset.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputFileLocation_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Volume_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Local_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Secret, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.File_reference = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.File_reference[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.File_reference, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int64(&st.Id, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Thumb_size, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Big, 7, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err = st.Stickerset.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputFileLocation_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputFileLocation_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputFileLocation_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Volume_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Local_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Secret, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.File_reference)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.File_reference {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int64(st.Id, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Thumb_size, 6)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Big, 7)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = st.Stickerset.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputFileLocation_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputFileLocation struct implement
type TLinputFileLocation struct {
	Data InputFileLocation_Data `json:"data"`
}

func (st *TLinputFileLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputFileLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputFileLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputFileLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputFileLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputFileLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputEncryptedFileLocation struct implement
type TLinputEncryptedFileLocation struct {
	Data InputFileLocation_Data `json:"data"`
}

func (st *TLinputEncryptedFileLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputEncryptedFileLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputEncryptedFileLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputEncryptedFileLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputEncryptedFileLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputEncryptedFileLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputDocumentFileLocation struct implement
type TLinputDocumentFileLocation struct {
	Data InputFileLocation_Data `json:"data"`
}

func (st *TLinputDocumentFileLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputDocumentFileLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputDocumentFileLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputDocumentFileLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputDocumentFileLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputDocumentFileLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputSecureFileLocation struct implement
type TLinputSecureFileLocation struct {
	Data InputFileLocation_Data `json:"data"`
}

func (st *TLinputSecureFileLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputSecureFileLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputSecureFileLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputSecureFileLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputSecureFileLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputSecureFileLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputTakeoutFileLocation struct implement
type TLinputTakeoutFileLocation struct {
	Data InputFileLocation_Data `json:"data"`
}

func (st *TLinputTakeoutFileLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputTakeoutFileLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputTakeoutFileLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputTakeoutFileLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputTakeoutFileLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputTakeoutFileLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPhotoFileLocation struct implement
type TLinputPhotoFileLocation struct {
	Data InputFileLocation_Data `json:"data"`
}

func (st *TLinputPhotoFileLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPhotoFileLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPhotoFileLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPhotoFileLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPhotoFileLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPhotoFileLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPhotoLegacyFileLocation struct implement
type TLinputPhotoLegacyFileLocation struct {
	Data InputFileLocation_Data `json:"data"`
}

func (st *TLinputPhotoLegacyFileLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPhotoLegacyFileLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPhotoLegacyFileLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPhotoLegacyFileLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPhotoLegacyFileLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPhotoLegacyFileLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPeerPhotoFileLocation struct implement
type TLinputPeerPhotoFileLocation struct {
	Data InputFileLocation_Data `json:"data"`
}

func (st *TLinputPeerPhotoFileLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPeerPhotoFileLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPeerPhotoFileLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPeerPhotoFileLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPeerPhotoFileLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPeerPhotoFileLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputStickerSetThumb struct implement
type TLinputStickerSetThumb struct {
	Data InputFileLocation_Data `json:"data"`
}

func (st *TLinputStickerSetThumb) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputStickerSetThumb) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputStickerSetThumb) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputStickerSetThumb, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputStickerSetThumb) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputStickerSetThumb) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputStickeredMedia struct implement
type InputStickeredMedia struct {
	Constructor int32                    `json:"constructor"`
	Data        InputStickeredMedia_Data `json:"data"`
}

func (st *InputStickeredMedia) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputStickeredMedia) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputStickeredMedia) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputStickeredMedia, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputStickeredMedia) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputStickeredMedia) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputStickeredMedia_Data struct implement
type InputStickeredMedia_Data struct {
	Id   InputPhoto    `json:"id"`
	Id_2 InputDocument `json:"id_2"`
}

func (st *InputStickeredMedia_Data) ResetDefault() {
	st.Id.ResetDefault()
	st.Id_2.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputStickeredMedia_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Id_2.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputStickeredMedia_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputStickeredMedia_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputStickeredMedia_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Id_2.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputStickeredMedia_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputStickeredMediaPhoto struct implement
type TLinputStickeredMediaPhoto struct {
	Data InputStickeredMedia_Data `json:"data"`
}

func (st *TLinputStickeredMediaPhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputStickeredMediaPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputStickeredMediaPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputStickeredMediaPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputStickeredMediaPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputStickeredMediaPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputStickeredMediaDocument struct implement
type TLinputStickeredMediaDocument struct {
	Data InputStickeredMedia_Data `json:"data"`
}

func (st *TLinputStickeredMediaDocument) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputStickeredMediaDocument) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputStickeredMediaDocument) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputStickeredMediaDocument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputStickeredMediaDocument) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputStickeredMediaDocument) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ShippingOption struct implement
type ShippingOption struct {
	Constructor int32               `json:"constructor"`
	Data        ShippingOption_Data `json:"data"`
}

func (st *ShippingOption) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ShippingOption) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ShippingOption) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ShippingOption, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ShippingOption) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ShippingOption) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ShippingOption_Data struct implement
type ShippingOption_Data struct {
	Id     string         `json:"id"`
	Title  string         `json:"title"`
	Prices []LabeledPrice `json:"prices"`
}

func (st *ShippingOption_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *ShippingOption_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Prices = make([]LabeledPrice, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Prices[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ShippingOption_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ShippingOption_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ShippingOption_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Prices)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Prices {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ShippingOption_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLshippingOption struct implement
type TLshippingOption struct {
	Data ShippingOption_Data `json:"data"`
}

func (st *TLshippingOption) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLshippingOption) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLshippingOption) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLshippingOption, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLshippingOption) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLshippingOption) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageInteractionCounters struct implement
type MessageInteractionCounters struct {
	Constructor int32                           `json:"constructor"`
	Data        MessageInteractionCounters_Data `json:"data"`
}

func (st *MessageInteractionCounters) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageInteractionCounters) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageInteractionCounters) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageInteractionCounters, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageInteractionCounters) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageInteractionCounters) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageInteractionCounters_Data struct implement
type MessageInteractionCounters_Data struct {
	Msg_id   int32 `json:"msg_id"`
	Views    int32 `json:"views"`
	Forwards int32 `json:"forwards"`
}

func (st *MessageInteractionCounters_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageInteractionCounters_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Msg_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Views, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Forwards, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageInteractionCounters_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageInteractionCounters_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageInteractionCounters_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Msg_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Views, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Forwards, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageInteractionCounters_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageInteractionCounters struct implement
type TLmessageInteractionCounters struct {
	Data MessageInteractionCounters_Data `json:"data"`
}

func (st *TLmessageInteractionCounters) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageInteractionCounters) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageInteractionCounters) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageInteractionCounters, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageInteractionCounters) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageInteractionCounters) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// DocumentAttribute struct implement
type DocumentAttribute struct {
	Constructor int32                  `json:"constructor"`
	Data        DocumentAttribute_Data `json:"data"`
}

func (st *DocumentAttribute) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *DocumentAttribute) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DocumentAttribute) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DocumentAttribute, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DocumentAttribute) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DocumentAttribute) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// DocumentAttribute_Data struct implement
type DocumentAttribute_Data struct {
	W                  int32           `json:"w"`
	H                  int32           `json:"h"`
	Mask               bool            `json:"mask"`
	Alt                string          `json:"alt"`
	Stickerset         InputStickerSet `json:"stickerset"`
	Mask_coords        MaskCoords      `json:"mask_coords"`
	Round_message      bool            `json:"round_message"`
	Supports_streaming bool            `json:"supports_streaming"`
	Duration           int32           `json:"duration"`
	Voice              bool            `json:"voice"`
	Title              string          `json:"title"`
	Performer          string          `json:"performer"`
	Waveform           []uint8         `json:"waveform"`
	File_name          string          `json:"file_name"`
}

func (st *DocumentAttribute_Data) ResetDefault() {
	st.Stickerset.ResetDefault()
	st.Mask_coords.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *DocumentAttribute_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.W, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.H, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Mask, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Alt, 3, false)
	if err != nil {
		return err
	}

	err = st.Stickerset.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = st.Mask_coords.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Round_message, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Supports_streaming, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Duration, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Voice, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Performer, 11, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(12, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Waveform = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Waveform[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Waveform, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.File_name, 13, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DocumentAttribute_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DocumentAttribute_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DocumentAttribute_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.W, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.H, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Mask, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Alt, 3)
	if err != nil {
		return err
	}

	err = st.Stickerset.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = st.Mask_coords.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Round_message, 6)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Supports_streaming, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Duration, 8)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Voice, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 10)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Performer, 11)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 12)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Waveform)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Waveform {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.File_name, 13)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DocumentAttribute_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdocumentAttributeImageSize struct implement
type TLdocumentAttributeImageSize struct {
	Data DocumentAttribute_Data `json:"data"`
}

func (st *TLdocumentAttributeImageSize) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdocumentAttributeImageSize) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdocumentAttributeImageSize) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdocumentAttributeImageSize, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdocumentAttributeImageSize) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdocumentAttributeImageSize) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdocumentAttributeAnimated struct implement
type TLdocumentAttributeAnimated struct {
	Data DocumentAttribute_Data `json:"data"`
}

func (st *TLdocumentAttributeAnimated) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdocumentAttributeAnimated) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdocumentAttributeAnimated) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdocumentAttributeAnimated, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdocumentAttributeAnimated) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdocumentAttributeAnimated) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdocumentAttributeSticker struct implement
type TLdocumentAttributeSticker struct {
	Data DocumentAttribute_Data `json:"data"`
}

func (st *TLdocumentAttributeSticker) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdocumentAttributeSticker) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdocumentAttributeSticker) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdocumentAttributeSticker, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdocumentAttributeSticker) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdocumentAttributeSticker) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdocumentAttributeVideo struct implement
type TLdocumentAttributeVideo struct {
	Data DocumentAttribute_Data `json:"data"`
}

func (st *TLdocumentAttributeVideo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdocumentAttributeVideo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdocumentAttributeVideo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdocumentAttributeVideo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdocumentAttributeVideo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdocumentAttributeVideo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdocumentAttributeAudio struct implement
type TLdocumentAttributeAudio struct {
	Data DocumentAttribute_Data `json:"data"`
}

func (st *TLdocumentAttributeAudio) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdocumentAttributeAudio) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdocumentAttributeAudio) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdocumentAttributeAudio, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdocumentAttributeAudio) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdocumentAttributeAudio) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdocumentAttributeFilename struct implement
type TLdocumentAttributeFilename struct {
	Data DocumentAttribute_Data `json:"data"`
}

func (st *TLdocumentAttributeFilename) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdocumentAttributeFilename) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdocumentAttributeFilename) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdocumentAttributeFilename, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdocumentAttributeFilename) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdocumentAttributeFilename) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdocumentAttributeHasStickers struct implement
type TLdocumentAttributeHasStickers struct {
	Data DocumentAttribute_Data `json:"data"`
}

func (st *TLdocumentAttributeHasStickers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdocumentAttributeHasStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdocumentAttributeHasStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdocumentAttributeHasStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdocumentAttributeHasStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdocumentAttributeHasStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureRequiredType struct implement
type SecureRequiredType struct {
	Constructor int32                   `json:"constructor"`
	Data        SecureRequiredType_Data `json:"data"`
}

func (st *SecureRequiredType) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureRequiredType) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureRequiredType) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureRequiredType, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureRequiredType) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureRequiredType) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureRequiredType_Data struct implement
type SecureRequiredType_Data struct {
	Native_names         bool                 `json:"native_names"`
	Selfie_required      bool                 `json:"selfie_required"`
	Translation_required bool                 `json:"translation_required"`
	Type                 SecureValueType      `json:"type"`
	Types                []SecureRequiredType `json:"types"`
}

func (st *SecureRequiredType_Data) ResetDefault() {
	st.Type.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureRequiredType_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Native_names, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Selfie_required, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Translation_required, 2, false)
	if err != nil {
		return err
	}

	err = st.Type.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Types = make([]SecureRequiredType, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Types[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureRequiredType_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureRequiredType_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureRequiredType_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Native_names, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Selfie_required, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Translation_required, 2)
	if err != nil {
		return err
	}

	err = st.Type.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Types)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Types {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureRequiredType_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureRequiredType struct implement
type TLsecureRequiredType struct {
	Data SecureRequiredType_Data `json:"data"`
}

func (st *TLsecureRequiredType) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureRequiredType) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureRequiredType) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureRequiredType, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureRequiredType) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureRequiredType) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureRequiredTypeOneOf struct implement
type TLsecureRequiredTypeOneOf struct {
	Data SecureRequiredType_Data `json:"data"`
}

func (st *TLsecureRequiredTypeOneOf) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureRequiredTypeOneOf) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureRequiredTypeOneOf) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureRequiredTypeOneOf, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureRequiredTypeOneOf) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureRequiredTypeOneOf) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_PromoData struct implement
type Help_PromoData struct {
	Constructor int32               `json:"constructor"`
	Data        Help_PromoData_Data `json:"data"`
}

func (st *Help_PromoData) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_PromoData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_PromoData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_PromoData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_PromoData) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_PromoData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_PromoData_Data struct implement
type Help_PromoData_Data struct {
	Expires     int32  `json:"expires"`
	Proxy       bool   `json:"proxy"`
	Peer        Peer   `json:"peer"`
	Chats       []Chat `json:"chats"`
	Users       []User `json:"users"`
	Psa_type    string `json:"psa_type"`
	Psa_message string `json:"psa_message"`
}

func (st *Help_PromoData_Data) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_PromoData_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Expires, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Proxy, 1, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Chats[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Users[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Psa_type, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Psa_message, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_PromoData_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_PromoData_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_PromoData_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Expires, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Proxy, 1)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Psa_type, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Psa_message, 6)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_PromoData_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_promoDataEmpty struct implement
type TLhelp_promoDataEmpty struct {
	Data Help_PromoData_Data `json:"data"`
}

func (st *TLhelp_promoDataEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_promoDataEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_promoDataEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_promoDataEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_promoDataEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_promoDataEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_promoData struct implement
type TLhelp_promoData struct {
	Data Help_PromoData_Data `json:"data"`
}

func (st *TLhelp_promoData) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_promoData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_promoData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_promoData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_promoData) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_promoData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// JSONValue struct implement
type JSONValue struct {
	Constructor int32          `json:"constructor"`
	Data        JSONValue_Data `json:"data"`
}

func (st *JSONValue) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *JSONValue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *JSONValue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require JSONValue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *JSONValue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *JSONValue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// JSONValue_Data struct implement
type JSONValue_Data struct {
	Value   Bool              `json:"value"`
	Value_2 float64           `json:"value_2"`
	Value_3 string            `json:"value_3"`
	Value_4 []JSONValue       `json:"value_4"`
	Value_5 []JSONObjectValue `json:"value_5"`
}

func (st *JSONValue_Data) ResetDefault() {
	st.Value.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *JSONValue_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Value.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Value_2, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Value_3, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Value_4 = make([]JSONValue, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Value_4[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Value_5 = make([]JSONObjectValue, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Value_5[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *JSONValue_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require JSONValue_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *JSONValue_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Value.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Value_2, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Value_3, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Value_4)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Value_4 {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Value_5)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Value_5 {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *JSONValue_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLjsonNull struct implement
type TLjsonNull struct {
	Data JSONValue_Data `json:"data"`
}

func (st *TLjsonNull) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLjsonNull) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLjsonNull) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLjsonNull, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLjsonNull) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLjsonNull) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLjsonBool struct implement
type TLjsonBool struct {
	Data JSONValue_Data `json:"data"`
}

func (st *TLjsonBool) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLjsonBool) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLjsonBool) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLjsonBool, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLjsonBool) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLjsonBool) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLjsonNumber struct implement
type TLjsonNumber struct {
	Data JSONValue_Data `json:"data"`
}

func (st *TLjsonNumber) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLjsonNumber) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLjsonNumber) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLjsonNumber, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLjsonNumber) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLjsonNumber) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLjsonString struct implement
type TLjsonString struct {
	Data JSONValue_Data `json:"data"`
}

func (st *TLjsonString) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLjsonString) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLjsonString) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLjsonString, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLjsonString) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLjsonString) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLjsonArray struct implement
type TLjsonArray struct {
	Data JSONValue_Data `json:"data"`
}

func (st *TLjsonArray) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLjsonArray) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLjsonArray) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLjsonArray, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLjsonArray) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLjsonArray) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLjsonObject struct implement
type TLjsonObject struct {
	Data JSONValue_Data `json:"data"`
}

func (st *TLjsonObject) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLjsonObject) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLjsonObject) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLjsonObject, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLjsonObject) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLjsonObject) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_UserInfo struct implement
type Help_UserInfo struct {
	Constructor int32              `json:"constructor"`
	Data        Help_UserInfo_Data `json:"data"`
}

func (st *Help_UserInfo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_UserInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_UserInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_UserInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_UserInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_UserInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_UserInfo_Data struct implement
type Help_UserInfo_Data struct {
	Message  string          `json:"message"`
	Entities []MessageEntity `json:"entities"`
	Author   string          `json:"author"`
	Date     int32           `json:"date"`
}

func (st *Help_UserInfo_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_UserInfo_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Message, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Author, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_UserInfo_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_UserInfo_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_UserInfo_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Message, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Author, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_UserInfo_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_userInfoEmpty struct implement
type TLhelp_userInfoEmpty struct {
	Data Help_UserInfo_Data `json:"data"`
}

func (st *TLhelp_userInfoEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_userInfoEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_userInfoEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_userInfoEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_userInfoEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_userInfoEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_userInfo struct implement
type TLhelp_userInfo struct {
	Data Help_UserInfo_Data `json:"data"`
}

func (st *TLhelp_userInfo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_userInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_userInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_userInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_userInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_userInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Authorization struct implement
type Authorization struct {
	Constructor int32              `json:"constructor"`
	Data        Authorization_Data `json:"data"`
}

func (st *Authorization) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Authorization) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Authorization) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Authorization, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Authorization) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Authorization) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Authorization_Data struct implement
type Authorization_Data struct {
	Current          bool   `json:"current"`
	Official_app     bool   `json:"official_app"`
	Password_pending bool   `json:"password_pending"`
	Hash             int64  `json:"hash"`
	Device_model     string `json:"device_model"`
	Platform         string `json:"platform"`
	System_version   string `json:"system_version"`
	Api_id           int32  `json:"api_id"`
	App_name         string `json:"app_name"`
	App_version      string `json:"app_version"`
	Date_created     int32  `json:"date_created"`
	Date_active      int32  `json:"date_active"`
	Ip               string `json:"ip"`
	Country          string `json:"country"`
	Region           string `json:"region"`
}

func (st *Authorization_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Authorization_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Current, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Official_app, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Password_pending, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Hash, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Device_model, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Platform, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.System_version, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Api_id, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.App_name, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.App_version, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date_created, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date_active, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Ip, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Country, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Region, 14, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Authorization_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Authorization_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Authorization_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Current, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Official_app, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Password_pending, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Hash, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Device_model, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Platform, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.System_version, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Api_id, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.App_name, 8)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.App_version, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date_created, 10)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date_active, 11)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Ip, 12)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Country, 13)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Region, 14)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Authorization_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauthorization struct implement
type TLauthorization struct {
	Data Authorization_Data `json:"data"`
}

func (st *TLauthorization) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauthorization) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauthorization) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauthorization, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauthorization) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauthorization) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_VotesList struct implement
type Messages_VotesList struct {
	Constructor int32                   `json:"constructor"`
	Data        Messages_VotesList_Data `json:"data"`
}

func (st *Messages_VotesList) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_VotesList) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_VotesList) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_VotesList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_VotesList) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_VotesList) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_VotesList_Data struct implement
type Messages_VotesList_Data struct {
	Count       int32             `json:"count"`
	Votes       []MessageUserVote `json:"votes"`
	Users       []User            `json:"users"`
	Next_offset string            `json:"next_offset"`
}

func (st *Messages_VotesList_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_VotesList_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Count, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Votes = make([]MessageUserVote, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Votes[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Users[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Next_offset, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_VotesList_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_VotesList_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_VotesList_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Count, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Votes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Votes {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Next_offset, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_VotesList_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_votesList struct implement
type TLmessages_votesList struct {
	Data Messages_VotesList_Data `json:"data"`
}

func (st *TLmessages_votesList) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_votesList) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_votesList) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_votesList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_votesList) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_votesList) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Auth_LoginToken struct implement
type Auth_LoginToken struct {
	Constructor int32                `json:"constructor"`
	Data        Auth_LoginToken_Data `json:"data"`
}

func (st *Auth_LoginToken) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Auth_LoginToken) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Auth_LoginToken) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Auth_LoginToken, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Auth_LoginToken) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Auth_LoginToken) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Auth_LoginToken_Data struct implement
type Auth_LoginToken_Data struct {
	Expires       int32              `json:"expires"`
	Token         []uint8            `json:"token"`
	Dc_id         int32              `json:"dc_id"`
	Authorization Auth_Authorization `json:"authorization"`
}

func (st *Auth_LoginToken_Data) ResetDefault() {
	st.Authorization.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Auth_LoginToken_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Expires, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Token = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Token[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Token, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Dc_id, 2, false)
	if err != nil {
		return err
	}

	err = st.Authorization.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Auth_LoginToken_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Auth_LoginToken_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Auth_LoginToken_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Expires, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Token)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Token {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Dc_id, 2)
	if err != nil {
		return err
	}

	err = st.Authorization.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Auth_LoginToken_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_loginToken struct implement
type TLauth_loginToken struct {
	Data Auth_LoginToken_Data `json:"data"`
}

func (st *TLauth_loginToken) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_loginToken) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_loginToken) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_loginToken, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_loginToken) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_loginToken) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_loginTokenMigrateTo struct implement
type TLauth_loginTokenMigrateTo struct {
	Data Auth_LoginToken_Data `json:"data"`
}

func (st *TLauth_loginTokenMigrateTo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_loginTokenMigrateTo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_loginTokenMigrateTo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_loginTokenMigrateTo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_loginTokenMigrateTo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_loginTokenMigrateTo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_loginTokenSuccess struct implement
type TLauth_loginTokenSuccess struct {
	Data Auth_LoginToken_Data `json:"data"`
}

func (st *TLauth_loginTokenSuccess) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_loginTokenSuccess) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_loginTokenSuccess) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_loginTokenSuccess, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_loginTokenSuccess) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_loginTokenSuccess) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// JSONObjectValue struct implement
type JSONObjectValue struct {
	Constructor int32                `json:"constructor"`
	Data        JSONObjectValue_Data `json:"data"`
}

func (st *JSONObjectValue) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *JSONObjectValue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *JSONObjectValue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require JSONObjectValue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *JSONObjectValue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *JSONObjectValue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// JSONObjectValue_Data struct implement
type JSONObjectValue_Data struct {
	Key_key string    `json:"key_key"`
	Value   JSONValue `json:"value"`
}

func (st *JSONObjectValue_Data) ResetDefault() {
	st.Value.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *JSONObjectValue_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Key_key, 0, false)
	if err != nil {
		return err
	}

	err = st.Value.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *JSONObjectValue_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require JSONObjectValue_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *JSONObjectValue_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Key_key, 0)
	if err != nil {
		return err
	}

	err = st.Value.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *JSONObjectValue_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLjsonObjectValue struct implement
type TLjsonObjectValue struct {
	Data JSONObjectValue_Data `json:"data"`
}

func (st *TLjsonObjectValue) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLjsonObjectValue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLjsonObjectValue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLjsonObjectValue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLjsonObjectValue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLjsonObjectValue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_DhConfig struct implement
type Messages_DhConfig struct {
	Constructor int32                  `json:"constructor"`
	Data        Messages_DhConfig_Data `json:"data"`
}

func (st *Messages_DhConfig) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_DhConfig) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_DhConfig) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_DhConfig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_DhConfig) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_DhConfig) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_DhConfig_Data struct implement
type Messages_DhConfig_Data struct {
	Random  []uint8 `json:"random"`
	G       int32   `json:"g"`
	P       []uint8 `json:"p"`
	Version int32   `json:"version"`
}

func (st *Messages_DhConfig_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_DhConfig_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Random = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Random[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Random, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.G, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.P = make([]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_uint8(&st.P[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.P, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Version, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_DhConfig_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_DhConfig_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_DhConfig_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Random)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Random {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.G, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.P)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.P {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Version, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_DhConfig_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_dhConfigNotModified struct implement
type TLmessages_dhConfigNotModified struct {
	Data Messages_DhConfig_Data `json:"data"`
}

func (st *TLmessages_dhConfigNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_dhConfigNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_dhConfigNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_dhConfigNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_dhConfigNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_dhConfigNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_dhConfig struct implement
type TLmessages_dhConfig struct {
	Data Messages_DhConfig_Data `json:"data"`
}

func (st *TLmessages_dhConfig) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_dhConfig) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_dhConfig) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_dhConfig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_dhConfig) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_dhConfig) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_FoundStickerSets struct implement
type Messages_FoundStickerSets struct {
	Constructor int32                          `json:"constructor"`
	Data        Messages_FoundStickerSets_Data `json:"data"`
}

func (st *Messages_FoundStickerSets) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_FoundStickerSets) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_FoundStickerSets) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_FoundStickerSets, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_FoundStickerSets) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_FoundStickerSets) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_FoundStickerSets_Data struct implement
type Messages_FoundStickerSets_Data struct {
	Hash int32               `json:"hash"`
	Sets []StickerSetCovered `json:"sets"`
}

func (st *Messages_FoundStickerSets_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_FoundStickerSets_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Sets = make([]StickerSetCovered, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Sets[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_FoundStickerSets_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_FoundStickerSets_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_FoundStickerSets_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Sets)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Sets {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_FoundStickerSets_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_foundStickerSetsNotModified struct implement
type TLmessages_foundStickerSetsNotModified struct {
	Data Messages_FoundStickerSets_Data `json:"data"`
}

func (st *TLmessages_foundStickerSetsNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_foundStickerSetsNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_foundStickerSetsNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_foundStickerSetsNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_foundStickerSetsNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_foundStickerSetsNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_foundStickerSets struct implement
type TLmessages_foundStickerSets struct {
	Data Messages_FoundStickerSets_Data `json:"data"`
}

func (st *TLmessages_foundStickerSets) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_foundStickerSets) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_foundStickerSets) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_foundStickerSets, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_foundStickerSets) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_foundStickerSets) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageFwdHeader struct implement
type MessageFwdHeader struct {
	Constructor int32                 `json:"constructor"`
	Data        MessageFwdHeader_Data `json:"data"`
}

func (st *MessageFwdHeader) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageFwdHeader) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageFwdHeader) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageFwdHeader, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageFwdHeader) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageFwdHeader) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageFwdHeader_Data struct implement
type MessageFwdHeader_Data struct {
	From_id           Peer   `json:"from_id"`
	From_name         string `json:"from_name"`
	Date              int32  `json:"date"`
	Channel_post      int32  `json:"channel_post"`
	Post_author       string `json:"post_author"`
	Saved_from_peer   Peer   `json:"saved_from_peer"`
	Saved_from_msg_id int32  `json:"saved_from_msg_id"`
	Psa_type          string `json:"psa_type"`
}

func (st *MessageFwdHeader_Data) ResetDefault() {
	st.From_id.ResetDefault()
	st.Saved_from_peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageFwdHeader_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.From_id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.From_name, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Channel_post, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Post_author, 4, false)
	if err != nil {
		return err
	}

	err = st.Saved_from_peer.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Saved_from_msg_id, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Psa_type, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageFwdHeader_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageFwdHeader_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageFwdHeader_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.From_id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.From_name, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Channel_post, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Post_author, 4)
	if err != nil {
		return err
	}

	err = st.Saved_from_peer.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Saved_from_msg_id, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Psa_type, 7)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageFwdHeader_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageFwdHeader struct implement
type TLmessageFwdHeader struct {
	Data MessageFwdHeader_Data `json:"data"`
}

func (st *TLmessageFwdHeader) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageFwdHeader) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageFwdHeader) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageFwdHeader, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageFwdHeader) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageFwdHeader) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// KeyboardButton struct implement
type KeyboardButton struct {
	Constructor int32               `json:"constructor"`
	Data        KeyboardButton_Data `json:"data"`
}

func (st *KeyboardButton) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *KeyboardButton) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *KeyboardButton) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require KeyboardButton, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *KeyboardButton) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *KeyboardButton) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// KeyboardButton_Data struct implement
type KeyboardButton_Data struct {
	Text                 string    `json:"text"`
	Url                  string    `json:"url"`
	Requires_password    bool      `json:"requires_password"`
	Data                 []uint8   `json:"data"`
	Same_peer            bool      `json:"same_peer"`
	Query                string    `json:"query"`
	Fwd_text             string    `json:"fwd_text"`
	Button_id            int32     `json:"button_id"`
	Request_write_access bool      `json:"request_write_access"`
	Bot                  InputUser `json:"bot"`
	Quiz                 Bool      `json:"quiz"`
}

func (st *KeyboardButton_Data) ResetDefault() {
	st.Bot.ResetDefault()
	st.Quiz.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *KeyboardButton_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Text, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Url, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Requires_password, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Data = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Data[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Data, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_bool(&st.Same_peer, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Query, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Fwd_text, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Button_id, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Request_write_access, 8, false)
	if err != nil {
		return err
	}

	err = st.Bot.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err = st.Quiz.ReadBlock(_is, 10, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *KeyboardButton_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require KeyboardButton_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *KeyboardButton_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Text, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Url, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Requires_password, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Data)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Data {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_bool(st.Same_peer, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Query, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Fwd_text, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Button_id, 7)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Request_write_access, 8)
	if err != nil {
		return err
	}

	err = st.Bot.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = st.Quiz.WriteBlock(_os, 10)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *KeyboardButton_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLkeyboardButton struct implement
type TLkeyboardButton struct {
	Data KeyboardButton_Data `json:"data"`
}

func (st *TLkeyboardButton) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLkeyboardButton) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLkeyboardButton) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLkeyboardButton, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLkeyboardButton) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLkeyboardButton) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLkeyboardButtonUrl struct implement
type TLkeyboardButtonUrl struct {
	Data KeyboardButton_Data `json:"data"`
}

func (st *TLkeyboardButtonUrl) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLkeyboardButtonUrl) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLkeyboardButtonUrl) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLkeyboardButtonUrl, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLkeyboardButtonUrl) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLkeyboardButtonUrl) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLkeyboardButtonCallback struct implement
type TLkeyboardButtonCallback struct {
	Data KeyboardButton_Data `json:"data"`
}

func (st *TLkeyboardButtonCallback) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLkeyboardButtonCallback) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLkeyboardButtonCallback) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLkeyboardButtonCallback, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLkeyboardButtonCallback) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLkeyboardButtonCallback) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLkeyboardButtonRequestPhone struct implement
type TLkeyboardButtonRequestPhone struct {
	Data KeyboardButton_Data `json:"data"`
}

func (st *TLkeyboardButtonRequestPhone) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLkeyboardButtonRequestPhone) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLkeyboardButtonRequestPhone) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLkeyboardButtonRequestPhone, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLkeyboardButtonRequestPhone) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLkeyboardButtonRequestPhone) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLkeyboardButtonRequestGeoLocation struct implement
type TLkeyboardButtonRequestGeoLocation struct {
	Data KeyboardButton_Data `json:"data"`
}

func (st *TLkeyboardButtonRequestGeoLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLkeyboardButtonRequestGeoLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLkeyboardButtonRequestGeoLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLkeyboardButtonRequestGeoLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLkeyboardButtonRequestGeoLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLkeyboardButtonRequestGeoLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLkeyboardButtonSwitchInline struct implement
type TLkeyboardButtonSwitchInline struct {
	Data KeyboardButton_Data `json:"data"`
}

func (st *TLkeyboardButtonSwitchInline) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLkeyboardButtonSwitchInline) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLkeyboardButtonSwitchInline) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLkeyboardButtonSwitchInline, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLkeyboardButtonSwitchInline) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLkeyboardButtonSwitchInline) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLkeyboardButtonGame struct implement
type TLkeyboardButtonGame struct {
	Data KeyboardButton_Data `json:"data"`
}

func (st *TLkeyboardButtonGame) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLkeyboardButtonGame) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLkeyboardButtonGame) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLkeyboardButtonGame, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLkeyboardButtonGame) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLkeyboardButtonGame) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLkeyboardButtonBuy struct implement
type TLkeyboardButtonBuy struct {
	Data KeyboardButton_Data `json:"data"`
}

func (st *TLkeyboardButtonBuy) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLkeyboardButtonBuy) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLkeyboardButtonBuy) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLkeyboardButtonBuy, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLkeyboardButtonBuy) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLkeyboardButtonBuy) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLkeyboardButtonUrlAuth struct implement
type TLkeyboardButtonUrlAuth struct {
	Data KeyboardButton_Data `json:"data"`
}

func (st *TLkeyboardButtonUrlAuth) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLkeyboardButtonUrlAuth) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLkeyboardButtonUrlAuth) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLkeyboardButtonUrlAuth, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLkeyboardButtonUrlAuth) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLkeyboardButtonUrlAuth) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputKeyboardButtonUrlAuth struct implement
type TLinputKeyboardButtonUrlAuth struct {
	Data KeyboardButton_Data `json:"data"`
}

func (st *TLinputKeyboardButtonUrlAuth) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputKeyboardButtonUrlAuth) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputKeyboardButtonUrlAuth) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputKeyboardButtonUrlAuth, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputKeyboardButtonUrlAuth) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputKeyboardButtonUrlAuth) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLkeyboardButtonRequestPoll struct implement
type TLkeyboardButtonRequestPoll struct {
	Data KeyboardButton_Data `json:"data"`
}

func (st *TLkeyboardButtonRequestPoll) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLkeyboardButtonRequestPoll) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLkeyboardButtonRequestPoll) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLkeyboardButtonRequestPoll, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLkeyboardButtonRequestPoll) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLkeyboardButtonRequestPoll) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputAppEvent struct implement
type InputAppEvent struct {
	Constructor int32              `json:"constructor"`
	Data        InputAppEvent_Data `json:"data"`
}

func (st *InputAppEvent) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputAppEvent) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputAppEvent) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputAppEvent, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputAppEvent) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputAppEvent) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputAppEvent_Data struct implement
type InputAppEvent_Data struct {
	Time float64   `json:"time"`
	Type string    `json:"type"`
	Peer int64     `json:"peer"`
	Data JSONValue `json:"data"`
}

func (st *InputAppEvent_Data) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputAppEvent_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_float64(&st.Time, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Type, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Peer, 2, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputAppEvent_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputAppEvent_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputAppEvent_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_float64(st.Time, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Type, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Peer, 2)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputAppEvent_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputAppEvent struct implement
type TLinputAppEvent struct {
	Data InputAppEvent_Data `json:"data"`
}

func (st *TLinputAppEvent) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputAppEvent) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputAppEvent) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputAppEvent, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputAppEvent) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputAppEvent) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputBotInlineMessage struct implement
type InputBotInlineMessage struct {
	Constructor int32                      `json:"constructor"`
	Data        InputBotInlineMessage_Data `json:"data"`
}

func (st *InputBotInlineMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputBotInlineMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputBotInlineMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputBotInlineMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputBotInlineMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputBotInlineMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputBotInlineMessage_Data struct implement
type InputBotInlineMessage_Data struct {
	Message                       string          `json:"message"`
	Entities                      []MessageEntity `json:"entities"`
	Reply_markup                  ReplyMarkup     `json:"reply_markup"`
	No_webpage                    bool            `json:"no_webpage"`
	Geo_point                     InputGeoPoint   `json:"geo_point"`
	Heading                       int32           `json:"heading"`
	Period                        int32           `json:"period"`
	Proximity_notification_radius int32           `json:"proximity_notification_radius"`
	Title                         string          `json:"title"`
	Address                       string          `json:"address"`
	Provider                      string          `json:"provider"`
	Venue_id                      string          `json:"venue_id"`
	Venue_type                    string          `json:"venue_type"`
	Phone_number                  string          `json:"phone_number"`
	First_name                    string          `json:"first_name"`
	Last_name                     string          `json:"last_name"`
	Vcard                         string          `json:"vcard"`
}

func (st *InputBotInlineMessage_Data) ResetDefault() {
	st.Reply_markup.ResetDefault()
	st.Geo_point.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputBotInlineMessage_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Message, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Reply_markup.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.No_webpage, 3, false)
	if err != nil {
		return err
	}

	err = st.Geo_point.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Heading, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Period, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Proximity_notification_radius, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Address, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Provider, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Venue_id, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Venue_type, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone_number, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.First_name, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Last_name, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Vcard, 16, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputBotInlineMessage_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputBotInlineMessage_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputBotInlineMessage_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Message, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Reply_markup.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.No_webpage, 3)
	if err != nil {
		return err
	}

	err = st.Geo_point.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Heading, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Period, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Proximity_notification_radius, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 8)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Address, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Provider, 10)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Venue_id, 11)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Venue_type, 12)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone_number, 13)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.First_name, 14)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Last_name, 15)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Vcard, 16)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputBotInlineMessage_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputBotInlineMessageMediaAuto struct implement
type TLinputBotInlineMessageMediaAuto struct {
	Data InputBotInlineMessage_Data `json:"data"`
}

func (st *TLinputBotInlineMessageMediaAuto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputBotInlineMessageMediaAuto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputBotInlineMessageMediaAuto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputBotInlineMessageMediaAuto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputBotInlineMessageMediaAuto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputBotInlineMessageMediaAuto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputBotInlineMessageText struct implement
type TLinputBotInlineMessageText struct {
	Data InputBotInlineMessage_Data `json:"data"`
}

func (st *TLinputBotInlineMessageText) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputBotInlineMessageText) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputBotInlineMessageText) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputBotInlineMessageText, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputBotInlineMessageText) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputBotInlineMessageText) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputBotInlineMessageMediaGeo struct implement
type TLinputBotInlineMessageMediaGeo struct {
	Data InputBotInlineMessage_Data `json:"data"`
}

func (st *TLinputBotInlineMessageMediaGeo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputBotInlineMessageMediaGeo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputBotInlineMessageMediaGeo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputBotInlineMessageMediaGeo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputBotInlineMessageMediaGeo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputBotInlineMessageMediaGeo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputBotInlineMessageMediaVenue struct implement
type TLinputBotInlineMessageMediaVenue struct {
	Data InputBotInlineMessage_Data `json:"data"`
}

func (st *TLinputBotInlineMessageMediaVenue) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputBotInlineMessageMediaVenue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputBotInlineMessageMediaVenue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputBotInlineMessageMediaVenue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputBotInlineMessageMediaVenue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputBotInlineMessageMediaVenue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputBotInlineMessageMediaContact struct implement
type TLinputBotInlineMessageMediaContact struct {
	Data InputBotInlineMessage_Data `json:"data"`
}

func (st *TLinputBotInlineMessageMediaContact) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputBotInlineMessageMediaContact) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputBotInlineMessageMediaContact) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputBotInlineMessageMediaContact, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputBotInlineMessageMediaContact) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputBotInlineMessageMediaContact) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputBotInlineMessageGame struct implement
type TLinputBotInlineMessageGame struct {
	Data InputBotInlineMessage_Data `json:"data"`
}

func (st *TLinputBotInlineMessageGame) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputBotInlineMessageGame) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputBotInlineMessageGame) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputBotInlineMessageGame, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputBotInlineMessageGame) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputBotInlineMessageGame) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Invoice struct implement
type Invoice struct {
	Constructor int32        `json:"constructor"`
	Data        Invoice_Data `json:"data"`
}

func (st *Invoice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Invoice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Invoice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Invoice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Invoice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Invoice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Invoice_Data struct implement
type Invoice_Data struct {
	Test                       bool           `json:"test"`
	Name_requested             bool           `json:"name_requested"`
	Phone_requested            bool           `json:"phone_requested"`
	Email_requested            bool           `json:"email_requested"`
	Shipping_address_requested bool           `json:"shipping_address_requested"`
	Flexible                   bool           `json:"flexible"`
	Phone_to_provider          bool           `json:"phone_to_provider"`
	Email_to_provider          bool           `json:"email_to_provider"`
	Currency                   string         `json:"currency"`
	Prices                     []LabeledPrice `json:"prices"`
}

func (st *Invoice_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Invoice_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Test, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Name_requested, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Phone_requested, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Email_requested, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Shipping_address_requested, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Flexible, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Phone_to_provider, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Email_to_provider, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Currency, 8, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(9, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Prices = make([]LabeledPrice, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Prices[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Invoice_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Invoice_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Invoice_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Test, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Name_requested, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Phone_requested, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Email_requested, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Shipping_address_requested, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Flexible, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Phone_to_provider, 6)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Email_to_provider, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Currency, 8)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Prices)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Prices {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Invoice_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinvoice struct implement
type TLinvoice struct {
	Data Invoice_Data `json:"data"`
}

func (st *TLinvoice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinvoice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinvoice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinvoice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinvoice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinvoice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// DialogFilterSuggested struct implement
type DialogFilterSuggested struct {
	Constructor int32                      `json:"constructor"`
	Data        DialogFilterSuggested_Data `json:"data"`
}

func (st *DialogFilterSuggested) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *DialogFilterSuggested) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DialogFilterSuggested) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DialogFilterSuggested, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DialogFilterSuggested) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DialogFilterSuggested) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// DialogFilterSuggested_Data struct implement
type DialogFilterSuggested_Data struct {
	Filter      DialogFilter `json:"filter"`
	Description string       `json:"description"`
}

func (st *DialogFilterSuggested_Data) ResetDefault() {
	st.Filter.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *DialogFilterSuggested_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Filter.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Description, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DialogFilterSuggested_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DialogFilterSuggested_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DialogFilterSuggested_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Filter.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Description, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DialogFilterSuggested_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdialogFilterSuggested struct implement
type TLdialogFilterSuggested struct {
	Data DialogFilterSuggested_Data `json:"data"`
}

func (st *TLdialogFilterSuggested) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdialogFilterSuggested) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdialogFilterSuggested) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdialogFilterSuggested, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdialogFilterSuggested) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdialogFilterSuggested) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputWebDocument struct implement
type InputWebDocument struct {
	Constructor int32                 `json:"constructor"`
	Data        InputWebDocument_Data `json:"data"`
}

func (st *InputWebDocument) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputWebDocument) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputWebDocument) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputWebDocument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputWebDocument) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputWebDocument) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputWebDocument_Data struct implement
type InputWebDocument_Data struct {
	Url        string              `json:"url"`
	Size       int32               `json:"size"`
	Mime_type  string              `json:"mime_type"`
	Attributes []DocumentAttribute `json:"attributes"`
}

func (st *InputWebDocument_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputWebDocument_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Url, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Size, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Mime_type, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Attributes = make([]DocumentAttribute, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Attributes[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputWebDocument_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputWebDocument_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputWebDocument_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Url, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Size, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Mime_type, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Attributes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Attributes {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputWebDocument_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputWebDocument struct implement
type TLinputWebDocument struct {
	Data InputWebDocument_Data `json:"data"`
}

func (st *TLinputWebDocument) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputWebDocument) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputWebDocument) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputWebDocument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputWebDocument) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputWebDocument) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Updates_State struct implement
type Updates_State struct {
	Constructor int32              `json:"constructor"`
	Data        Updates_State_Data `json:"data"`
}

func (st *Updates_State) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Updates_State) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Updates_State) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Updates_State, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Updates_State) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Updates_State) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Updates_State_Data struct implement
type Updates_State_Data struct {
	Pts          int32 `json:"pts"`
	Qts          int32 `json:"qts"`
	Date         int32 `json:"date"`
	Seq          int32 `json:"seq"`
	Unread_count int32 `json:"unread_count"`
}

func (st *Updates_State_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Updates_State_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Pts, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Qts, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Seq, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Unread_count, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Updates_State_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Updates_State_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Updates_State_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Pts, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Qts, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Seq, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Unread_count, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Updates_State_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdates_state struct implement
type TLupdates_state struct {
	Data Updates_State_Data `json:"data"`
}

func (st *TLupdates_state) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdates_state) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdates_state) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdates_state, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdates_state) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdates_state) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputBotInlineResult struct implement
type InputBotInlineResult struct {
	Constructor int32                     `json:"constructor"`
	Data        InputBotInlineResult_Data `json:"data"`
}

func (st *InputBotInlineResult) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputBotInlineResult) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputBotInlineResult) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputBotInlineResult, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputBotInlineResult) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputBotInlineResult) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputBotInlineResult_Data struct implement
type InputBotInlineResult_Data struct {
	Id           string                `json:"id"`
	Type         string                `json:"type"`
	Title        string                `json:"title"`
	Description  string                `json:"description"`
	Url          string                `json:"url"`
	Thumb        InputWebDocument      `json:"thumb"`
	Content      InputWebDocument      `json:"content"`
	Send_message InputBotInlineMessage `json:"send_message"`
	Photo        InputPhoto            `json:"photo"`
	Document     InputDocument         `json:"document"`
	Short_name   string                `json:"short_name"`
}

func (st *InputBotInlineResult_Data) ResetDefault() {
	st.Thumb.ResetDefault()
	st.Content.ResetDefault()
	st.Send_message.ResetDefault()
	st.Photo.ResetDefault()
	st.Document.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputBotInlineResult_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Type, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Description, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Url, 4, false)
	if err != nil {
		return err
	}

	err = st.Thumb.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = st.Content.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	err = st.Send_message.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	err = st.Photo.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err = st.Document.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Short_name, 10, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputBotInlineResult_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputBotInlineResult_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputBotInlineResult_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Type, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Description, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Url, 4)
	if err != nil {
		return err
	}

	err = st.Thumb.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = st.Content.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	err = st.Send_message.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	err = st.Photo.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = st.Document.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Short_name, 10)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputBotInlineResult_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputBotInlineResult struct implement
type TLinputBotInlineResult struct {
	Data InputBotInlineResult_Data `json:"data"`
}

func (st *TLinputBotInlineResult) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputBotInlineResult) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputBotInlineResult) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputBotInlineResult, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputBotInlineResult) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputBotInlineResult) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputBotInlineResultPhoto struct implement
type TLinputBotInlineResultPhoto struct {
	Data InputBotInlineResult_Data `json:"data"`
}

func (st *TLinputBotInlineResultPhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputBotInlineResultPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputBotInlineResultPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputBotInlineResultPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputBotInlineResultPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputBotInlineResultPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputBotInlineResultDocument struct implement
type TLinputBotInlineResultDocument struct {
	Data InputBotInlineResult_Data `json:"data"`
}

func (st *TLinputBotInlineResultDocument) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputBotInlineResultDocument) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputBotInlineResultDocument) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputBotInlineResultDocument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputBotInlineResultDocument) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputBotInlineResultDocument) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputBotInlineResultGame struct implement
type TLinputBotInlineResultGame struct {
	Data InputBotInlineResult_Data `json:"data"`
}

func (st *TLinputBotInlineResultGame) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputBotInlineResultGame) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputBotInlineResultGame) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputBotInlineResultGame, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputBotInlineResultGame) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputBotInlineResultGame) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InlineBotSwitchPM struct implement
type InlineBotSwitchPM struct {
	Constructor int32                  `json:"constructor"`
	Data        InlineBotSwitchPM_Data `json:"data"`
}

func (st *InlineBotSwitchPM) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InlineBotSwitchPM) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InlineBotSwitchPM) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InlineBotSwitchPM, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InlineBotSwitchPM) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InlineBotSwitchPM) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InlineBotSwitchPM_Data struct implement
type InlineBotSwitchPM_Data struct {
	Text        string `json:"text"`
	Start_param string `json:"start_param"`
}

func (st *InlineBotSwitchPM_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InlineBotSwitchPM_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Text, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Start_param, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InlineBotSwitchPM_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InlineBotSwitchPM_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InlineBotSwitchPM_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Text, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Start_param, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InlineBotSwitchPM_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinlineBotSwitchPM struct implement
type TLinlineBotSwitchPM struct {
	Data InlineBotSwitchPM_Data `json:"data"`
}

func (st *TLinlineBotSwitchPM) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinlineBotSwitchPM) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinlineBotSwitchPM) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinlineBotSwitchPM, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinlineBotSwitchPM) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinlineBotSwitchPM) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_AllStickers struct implement
type Messages_AllStickers struct {
	Constructor int32                     `json:"constructor"`
	Data        Messages_AllStickers_Data `json:"data"`
}

func (st *Messages_AllStickers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_AllStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_AllStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_AllStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_AllStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_AllStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_AllStickers_Data struct implement
type Messages_AllStickers_Data struct {
	Hash int32        `json:"hash"`
	Sets []StickerSet `json:"sets"`
}

func (st *Messages_AllStickers_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_AllStickers_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Sets = make([]StickerSet, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Sets[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_AllStickers_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_AllStickers_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_AllStickers_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Sets)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Sets {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_AllStickers_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_allStickersNotModified struct implement
type TLmessages_allStickersNotModified struct {
	Data Messages_AllStickers_Data `json:"data"`
}

func (st *TLmessages_allStickersNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_allStickersNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_allStickersNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_allStickersNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_allStickersNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_allStickersNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_allStickers struct implement
type TLmessages_allStickers struct {
	Data Messages_AllStickers_Data `json:"data"`
}

func (st *TLmessages_allStickers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_allStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_allStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_allStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_allStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_allStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputBotInlineMessageID struct implement
type InputBotInlineMessageID struct {
	Constructor int32                        `json:"constructor"`
	Data        InputBotInlineMessageID_Data `json:"data"`
}

func (st *InputBotInlineMessageID) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputBotInlineMessageID) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputBotInlineMessageID) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputBotInlineMessageID, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputBotInlineMessageID) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputBotInlineMessageID) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputBotInlineMessageID_Data struct implement
type InputBotInlineMessageID_Data struct {
	Dc_id       int32 `json:"dc_id"`
	Id          int64 `json:"id"`
	Access_hash int64 `json:"access_hash"`
}

func (st *InputBotInlineMessageID_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputBotInlineMessageID_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Dc_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputBotInlineMessageID_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputBotInlineMessageID_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputBotInlineMessageID_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Dc_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputBotInlineMessageID_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputBotInlineMessageID struct implement
type TLinputBotInlineMessageID struct {
	Data InputBotInlineMessageID_Data `json:"data"`
}

func (st *TLinputBotInlineMessageID) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputBotInlineMessageID) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputBotInlineMessageID) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputBotInlineMessageID, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputBotInlineMessageID) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputBotInlineMessageID) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// FolderPeer struct implement
type FolderPeer struct {
	Constructor int32           `json:"constructor"`
	Data        FolderPeer_Data `json:"data"`
}

func (st *FolderPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *FolderPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *FolderPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require FolderPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *FolderPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *FolderPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// FolderPeer_Data struct implement
type FolderPeer_Data struct {
	Peer      Peer  `json:"peer"`
	Folder_id int32 `json:"folder_id"`
}

func (st *FolderPeer_Data) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *FolderPeer_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Folder_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *FolderPeer_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require FolderPeer_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *FolderPeer_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Folder_id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *FolderPeer_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLfolderPeer struct implement
type TLfolderPeer struct {
	Data FolderPeer_Data `json:"data"`
}

func (st *TLfolderPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLfolderPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLfolderPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLfolderPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLfolderPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLfolderPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PaymentRequestedInfo struct implement
type PaymentRequestedInfo struct {
	Constructor int32                     `json:"constructor"`
	Data        PaymentRequestedInfo_Data `json:"data"`
}

func (st *PaymentRequestedInfo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PaymentRequestedInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PaymentRequestedInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PaymentRequestedInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PaymentRequestedInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PaymentRequestedInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PaymentRequestedInfo_Data struct implement
type PaymentRequestedInfo_Data struct {
	Name             string      `json:"name"`
	Phone            string      `json:"phone"`
	Email            string      `json:"email"`
	Shipping_address PostAddress `json:"shipping_address"`
}

func (st *PaymentRequestedInfo_Data) ResetDefault() {
	st.Shipping_address.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PaymentRequestedInfo_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Name, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Email, 2, false)
	if err != nil {
		return err
	}

	err = st.Shipping_address.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PaymentRequestedInfo_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PaymentRequestedInfo_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PaymentRequestedInfo_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Name, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Email, 2)
	if err != nil {
		return err
	}

	err = st.Shipping_address.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PaymentRequestedInfo_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpaymentRequestedInfo struct implement
type TLpaymentRequestedInfo struct {
	Data PaymentRequestedInfo_Data `json:"data"`
}

func (st *TLpaymentRequestedInfo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpaymentRequestedInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpaymentRequestedInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpaymentRequestedInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpaymentRequestedInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpaymentRequestedInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageReplies struct implement
type MessageReplies struct {
	Constructor int32               `json:"constructor"`
	Data        MessageReplies_Data `json:"data"`
}

func (st *MessageReplies) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageReplies) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageReplies) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageReplies, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageReplies) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageReplies) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageReplies_Data struct implement
type MessageReplies_Data struct {
	Comments        bool   `json:"comments"`
	Replies         int32  `json:"replies"`
	Replies_pts     int32  `json:"replies_pts"`
	Recent_repliers []Peer `json:"recent_repliers"`
	Channel_id      int32  `json:"channel_id"`
	Max_id          int32  `json:"max_id"`
	Read_max_id     int32  `json:"read_max_id"`
}

func (st *MessageReplies_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageReplies_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Comments, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Replies, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Replies_pts, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Recent_repliers = make([]Peer, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Recent_repliers[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Channel_id, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_id, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Read_max_id, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageReplies_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageReplies_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageReplies_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Comments, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Replies, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Replies_pts, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Recent_repliers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Recent_repliers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Channel_id, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_id, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Read_max_id, 6)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageReplies_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageReplies struct implement
type TLmessageReplies struct {
	Data MessageReplies_Data `json:"data"`
}

func (st *TLmessageReplies) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageReplies) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageReplies) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageReplies, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageReplies) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageReplies) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Upload_CdnFile struct implement
type Upload_CdnFile struct {
	Constructor int32               `json:"constructor"`
	Data        Upload_CdnFile_Data `json:"data"`
}

func (st *Upload_CdnFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Upload_CdnFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Upload_CdnFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Upload_CdnFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Upload_CdnFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Upload_CdnFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Upload_CdnFile_Data struct implement
type Upload_CdnFile_Data struct {
	Request_token []uint8 `json:"request_token"`
	Bytes         []uint8 `json:"bytes"`
}

func (st *Upload_CdnFile_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Upload_CdnFile_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Request_token = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Request_token[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Request_token, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Bytes = make([]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_uint8(&st.Bytes[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Bytes, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Upload_CdnFile_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Upload_CdnFile_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Upload_CdnFile_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Request_token)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Request_token {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Bytes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Bytes {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Upload_CdnFile_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupload_cdnFileReuploadNeeded struct implement
type TLupload_cdnFileReuploadNeeded struct {
	Data Upload_CdnFile_Data `json:"data"`
}

func (st *TLupload_cdnFileReuploadNeeded) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupload_cdnFileReuploadNeeded) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupload_cdnFileReuploadNeeded) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupload_cdnFileReuploadNeeded, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupload_cdnFileReuploadNeeded) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupload_cdnFileReuploadNeeded) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupload_cdnFile struct implement
type TLupload_cdnFile struct {
	Data Upload_CdnFile_Data `json:"data"`
}

func (st *TLupload_cdnFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupload_cdnFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupload_cdnFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupload_cdnFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupload_cdnFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupload_cdnFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChatInvite struct implement
type ChatInvite struct {
	Constructor int32           `json:"constructor"`
	Data        ChatInvite_Data `json:"data"`
}

func (st *ChatInvite) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChatInvite) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChatInvite) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChatInvite, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChatInvite) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChatInvite) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChatInvite_Data struct implement
type ChatInvite_Data struct {
	Chat               Chat   `json:"chat"`
	Channel            bool   `json:"channel"`
	Broadcast          bool   `json:"broadcast"`
	Public             bool   `json:"public"`
	Megagroup          bool   `json:"megagroup"`
	Title              string `json:"title"`
	Photo              Photo  `json:"photo"`
	Participants_count int32  `json:"participants_count"`
	Participants       []User `json:"participants"`
	Expires            int32  `json:"expires"`
}

func (st *ChatInvite_Data) ResetDefault() {
	st.Chat.ResetDefault()
	st.Photo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChatInvite_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Chat.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Channel, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Broadcast, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Public, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Megagroup, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 5, false)
	if err != nil {
		return err
	}

	err = st.Photo.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Participants_count, 7, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Participants = make([]User, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Participants[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Expires, 9, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChatInvite_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChatInvite_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChatInvite_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Chat.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Channel, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Broadcast, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Public, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Megagroup, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 5)
	if err != nil {
		return err
	}

	err = st.Photo.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Participants_count, 7)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Participants)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Participants {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Expires, 9)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChatInvite_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatInviteAlready struct implement
type TLchatInviteAlready struct {
	Data ChatInvite_Data `json:"data"`
}

func (st *TLchatInviteAlready) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatInviteAlready) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatInviteAlready) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatInviteAlready, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatInviteAlready) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatInviteAlready) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatInvite struct implement
type TLchatInvite struct {
	Data ChatInvite_Data `json:"data"`
}

func (st *TLchatInvite) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatInvite) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatInvite) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatInvite, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatInvite) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatInvite) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatInvitePeek struct implement
type TLchatInvitePeek struct {
	Data ChatInvite_Data `json:"data"`
}

func (st *TLchatInvitePeek) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatInvitePeek) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatInvitePeek) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatInvitePeek, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatInvitePeek) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatInvitePeek) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// LangPackDifference struct implement
type LangPackDifference struct {
	Constructor int32                   `json:"constructor"`
	Data        LangPackDifference_Data `json:"data"`
}

func (st *LangPackDifference) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *LangPackDifference) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *LangPackDifference) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require LangPackDifference, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *LangPackDifference) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *LangPackDifference) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// LangPackDifference_Data struct implement
type LangPackDifference_Data struct {
	Lang_code    string           `json:"lang_code"`
	From_version int32            `json:"from_version"`
	Version      int32            `json:"version"`
	Strings      []LangPackString `json:"strings"`
}

func (st *LangPackDifference_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *LangPackDifference_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Lang_code, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.From_version, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Version, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Strings = make([]LangPackString, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Strings[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *LangPackDifference_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require LangPackDifference_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *LangPackDifference_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Lang_code, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.From_version, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Version, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Strings)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Strings {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *LangPackDifference_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLlangPackDifference struct implement
type TLlangPackDifference struct {
	Data LangPackDifference_Data `json:"data"`
}

func (st *TLlangPackDifference) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLlangPackDifference) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLlangPackDifference) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLlangPackDifference, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLlangPackDifference) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLlangPackDifference) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StatsGroupTopAdmin struct implement
type StatsGroupTopAdmin struct {
	Constructor int32                   `json:"constructor"`
	Data        StatsGroupTopAdmin_Data `json:"data"`
}

func (st *StatsGroupTopAdmin) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *StatsGroupTopAdmin) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StatsGroupTopAdmin) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StatsGroupTopAdmin, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StatsGroupTopAdmin) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StatsGroupTopAdmin) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StatsGroupTopAdmin_Data struct implement
type StatsGroupTopAdmin_Data struct {
	User_id int32 `json:"user_id"`
	Deleted int32 `json:"deleted"`
	Kicked  int32 `json:"kicked"`
	Banned  int32 `json:"banned"`
}

func (st *StatsGroupTopAdmin_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *StatsGroupTopAdmin_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Deleted, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Kicked, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Banned, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StatsGroupTopAdmin_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StatsGroupTopAdmin_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StatsGroupTopAdmin_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.User_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Deleted, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Kicked, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Banned, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StatsGroupTopAdmin_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstatsGroupTopAdmin struct implement
type TLstatsGroupTopAdmin struct {
	Data StatsGroupTopAdmin_Data `json:"data"`
}

func (st *TLstatsGroupTopAdmin) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstatsGroupTopAdmin) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstatsGroupTopAdmin) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstatsGroupTopAdmin, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstatsGroupTopAdmin) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstatsGroupTopAdmin) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_ChatFull struct implement
type Messages_ChatFull struct {
	Constructor int32                  `json:"constructor"`
	Data        Messages_ChatFull_Data `json:"data"`
}

func (st *Messages_ChatFull) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_ChatFull) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_ChatFull) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_ChatFull, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_ChatFull) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_ChatFull) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_ChatFull_Data struct implement
type Messages_ChatFull_Data struct {
	Full_chat ChatFull `json:"full_chat"`
	Chats     []Chat   `json:"chats"`
	Users     []User   `json:"users"`
}

func (st *Messages_ChatFull_Data) ResetDefault() {
	st.Full_chat.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_ChatFull_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Full_chat.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Chats[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Users[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_ChatFull_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_ChatFull_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_ChatFull_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Full_chat.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_ChatFull_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_chatFull struct implement
type TLmessages_chatFull struct {
	Data Messages_ChatFull_Data `json:"data"`
}

func (st *TLmessages_chatFull) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_chatFull) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_chatFull) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_chatFull, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_chatFull) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_chatFull) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// RichText struct implement
type RichText struct {
	Constructor int32         `json:"constructor"`
	Data        RichText_Data `json:"data"`
}

func (st *RichText) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *RichText) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *RichText) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RichText, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *RichText) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *RichText) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// RichText_Data struct implement
type RichText_Data struct {
	Text        string     `json:"text"`
	Text_2      RichText   `json:"text_2"`
	Url         string     `json:"url"`
	Webpage_id  int64      `json:"webpage_id"`
	Email       string     `json:"email"`
	Texts       []RichText `json:"texts"`
	Phone       string     `json:"phone"`
	Document_id int64      `json:"document_id"`
	W           int32      `json:"w"`
	H           int32      `json:"h"`
	Name        string     `json:"name"`
}

func (st *RichText_Data) ResetDefault() {
	st.Text_2.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *RichText_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Text, 0, false)
	if err != nil {
		return err
	}

	err = st.Text_2.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Url, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Webpage_id, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Email, 4, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Texts = make([]RichText, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Texts[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Phone, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Document_id, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.W, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.H, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Name, 10, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *RichText_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RichText_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *RichText_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Text, 0)
	if err != nil {
		return err
	}

	err = st.Text_2.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Url, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Webpage_id, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Email, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Texts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Texts {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Phone, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Document_id, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.W, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.H, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Name, 10)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *RichText_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtextEmpty struct implement
type TLtextEmpty struct {
	Data RichText_Data `json:"data"`
}

func (st *TLtextEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtextEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtextEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtextEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtextEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtextEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtextPlain struct implement
type TLtextPlain struct {
	Data RichText_Data `json:"data"`
}

func (st *TLtextPlain) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtextPlain) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtextPlain) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtextPlain, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtextPlain) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtextPlain) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtextBold struct implement
type TLtextBold struct {
	Data RichText_Data `json:"data"`
}

func (st *TLtextBold) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtextBold) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtextBold) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtextBold, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtextBold) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtextBold) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtextItalic struct implement
type TLtextItalic struct {
	Data RichText_Data `json:"data"`
}

func (st *TLtextItalic) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtextItalic) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtextItalic) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtextItalic, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtextItalic) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtextItalic) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtextUnderline struct implement
type TLtextUnderline struct {
	Data RichText_Data `json:"data"`
}

func (st *TLtextUnderline) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtextUnderline) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtextUnderline) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtextUnderline, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtextUnderline) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtextUnderline) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtextStrike struct implement
type TLtextStrike struct {
	Data RichText_Data `json:"data"`
}

func (st *TLtextStrike) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtextStrike) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtextStrike) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtextStrike, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtextStrike) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtextStrike) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtextFixed struct implement
type TLtextFixed struct {
	Data RichText_Data `json:"data"`
}

func (st *TLtextFixed) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtextFixed) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtextFixed) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtextFixed, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtextFixed) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtextFixed) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtextUrl struct implement
type TLtextUrl struct {
	Data RichText_Data `json:"data"`
}

func (st *TLtextUrl) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtextUrl) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtextUrl) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtextUrl, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtextUrl) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtextUrl) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtextEmail struct implement
type TLtextEmail struct {
	Data RichText_Data `json:"data"`
}

func (st *TLtextEmail) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtextEmail) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtextEmail) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtextEmail, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtextEmail) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtextEmail) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtextConcat struct implement
type TLtextConcat struct {
	Data RichText_Data `json:"data"`
}

func (st *TLtextConcat) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtextConcat) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtextConcat) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtextConcat, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtextConcat) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtextConcat) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtextSubscript struct implement
type TLtextSubscript struct {
	Data RichText_Data `json:"data"`
}

func (st *TLtextSubscript) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtextSubscript) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtextSubscript) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtextSubscript, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtextSubscript) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtextSubscript) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtextSuperscript struct implement
type TLtextSuperscript struct {
	Data RichText_Data `json:"data"`
}

func (st *TLtextSuperscript) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtextSuperscript) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtextSuperscript) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtextSuperscript, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtextSuperscript) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtextSuperscript) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtextMarked struct implement
type TLtextMarked struct {
	Data RichText_Data `json:"data"`
}

func (st *TLtextMarked) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtextMarked) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtextMarked) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtextMarked, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtextMarked) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtextMarked) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtextPhone struct implement
type TLtextPhone struct {
	Data RichText_Data `json:"data"`
}

func (st *TLtextPhone) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtextPhone) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtextPhone) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtextPhone, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtextPhone) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtextPhone) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtextImage struct implement
type TLtextImage struct {
	Data RichText_Data `json:"data"`
}

func (st *TLtextImage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtextImage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtextImage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtextImage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtextImage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtextImage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtextAnchor struct implement
type TLtextAnchor struct {
	Data RichText_Data `json:"data"`
}

func (st *TLtextAnchor) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtextAnchor) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtextAnchor) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtextAnchor, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtextAnchor) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtextAnchor) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_MessageEditData struct implement
type Messages_MessageEditData struct {
	Constructor int32                         `json:"constructor"`
	Data        Messages_MessageEditData_Data `json:"data"`
}

func (st *Messages_MessageEditData) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_MessageEditData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_MessageEditData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_MessageEditData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_MessageEditData) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_MessageEditData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_MessageEditData_Data struct implement
type Messages_MessageEditData_Data struct {
	Caption bool `json:"caption"`
}

func (st *Messages_MessageEditData_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_MessageEditData_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Caption, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_MessageEditData_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_MessageEditData_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_MessageEditData_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Caption, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_MessageEditData_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_messageEditData struct implement
type TLmessages_messageEditData struct {
	Data Messages_MessageEditData_Data `json:"data"`
}

func (st *TLmessages_messageEditData) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_messageEditData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_messageEditData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_messageEditData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_messageEditData) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_messageEditData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PeerLocated struct implement
type PeerLocated struct {
	Constructor int32            `json:"constructor"`
	Data        PeerLocated_Data `json:"data"`
}

func (st *PeerLocated) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PeerLocated) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PeerLocated) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PeerLocated, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PeerLocated) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PeerLocated) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PeerLocated_Data struct implement
type PeerLocated_Data struct {
	Peer     Peer  `json:"peer"`
	Expires  int32 `json:"expires"`
	Distance int32 `json:"distance"`
}

func (st *PeerLocated_Data) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PeerLocated_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Expires, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Distance, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PeerLocated_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PeerLocated_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PeerLocated_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Expires, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Distance, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PeerLocated_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpeerLocated struct implement
type TLpeerLocated struct {
	Data PeerLocated_Data `json:"data"`
}

func (st *TLpeerLocated) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpeerLocated) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpeerLocated) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpeerLocated, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpeerLocated) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpeerLocated) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpeerSelfLocated struct implement
type TLpeerSelfLocated struct {
	Data PeerLocated_Data `json:"data"`
}

func (st *TLpeerSelfLocated) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpeerSelfLocated) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpeerSelfLocated) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpeerSelfLocated, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpeerSelfLocated) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpeerSelfLocated) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_AutoDownloadSettings struct implement
type Account_AutoDownloadSettings struct {
	Constructor int32                             `json:"constructor"`
	Data        Account_AutoDownloadSettings_Data `json:"data"`
}

func (st *Account_AutoDownloadSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_AutoDownloadSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_AutoDownloadSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_AutoDownloadSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_AutoDownloadSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_AutoDownloadSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_AutoDownloadSettings_Data struct implement
type Account_AutoDownloadSettings_Data struct {
	Low    AutoDownloadSettings `json:"low"`
	Medium AutoDownloadSettings `json:"medium"`
	High   AutoDownloadSettings `json:"high"`
}

func (st *Account_AutoDownloadSettings_Data) ResetDefault() {
	st.Low.ResetDefault()
	st.Medium.ResetDefault()
	st.High.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_AutoDownloadSettings_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Low.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Medium.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.High.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_AutoDownloadSettings_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_AutoDownloadSettings_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_AutoDownloadSettings_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Low.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Medium.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.High.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_AutoDownloadSettings_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_autoDownloadSettings struct implement
type TLaccount_autoDownloadSettings struct {
	Data Account_AutoDownloadSettings_Data `json:"data"`
}

func (st *TLaccount_autoDownloadSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_autoDownloadSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_autoDownloadSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_autoDownloadSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_autoDownloadSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_autoDownloadSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StickerPack struct implement
type StickerPack struct {
	Constructor int32            `json:"constructor"`
	Data        StickerPack_Data `json:"data"`
}

func (st *StickerPack) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *StickerPack) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StickerPack) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StickerPack, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StickerPack) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StickerPack) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StickerPack_Data struct implement
type StickerPack_Data struct {
	Emoticon  string  `json:"emoticon"`
	Documents []int64 `json:"documents"`
}

func (st *StickerPack_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *StickerPack_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Emoticon, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Documents = make([]int64, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int64(&st.Documents[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StickerPack_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StickerPack_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StickerPack_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Emoticon, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Documents)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Documents {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StickerPack_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstickerPack struct implement
type TLstickerPack struct {
	Data StickerPack_Data `json:"data"`
}

func (st *TLstickerPack) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstickerPack) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstickerPack) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstickerPack, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstickerPack) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstickerPack) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChatBannedRights struct implement
type ChatBannedRights struct {
	Constructor int32                 `json:"constructor"`
	Data        ChatBannedRights_Data `json:"data"`
}

func (st *ChatBannedRights) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChatBannedRights) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChatBannedRights) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChatBannedRights, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChatBannedRights) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChatBannedRights) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChatBannedRights_Data struct implement
type ChatBannedRights_Data struct {
	View_messages bool  `json:"view_messages"`
	Send_messages bool  `json:"send_messages"`
	Send_media    bool  `json:"send_media"`
	Send_stickers bool  `json:"send_stickers"`
	Send_gifs     bool  `json:"send_gifs"`
	Send_games    bool  `json:"send_games"`
	Send_inline   bool  `json:"send_inline"`
	Embed_links   bool  `json:"embed_links"`
	Send_polls    bool  `json:"send_polls"`
	Change_info   bool  `json:"change_info"`
	Invite_users  bool  `json:"invite_users"`
	Pin_messages  bool  `json:"pin_messages"`
	Until_date    int32 `json:"until_date"`
}

func (st *ChatBannedRights_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *ChatBannedRights_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.View_messages, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Send_messages, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Send_media, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Send_stickers, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Send_gifs, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Send_games, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Send_inline, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Embed_links, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Send_polls, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Change_info, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Invite_users, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Pin_messages, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Until_date, 12, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChatBannedRights_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChatBannedRights_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChatBannedRights_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.View_messages, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Send_messages, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Send_media, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Send_stickers, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Send_gifs, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Send_games, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Send_inline, 6)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Embed_links, 7)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Send_polls, 8)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Change_info, 9)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Invite_users, 10)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Pin_messages, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Until_date, 12)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChatBannedRights_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatBannedRights struct implement
type TLchatBannedRights struct {
	Data ChatBannedRights_Data `json:"data"`
}

func (st *TLchatBannedRights) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatBannedRights) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatBannedRights) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatBannedRights, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatBannedRights) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatBannedRights) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Upload_File struct implement
type Upload_File struct {
	Constructor int32            `json:"constructor"`
	Data        Upload_File_Data `json:"data"`
}

func (st *Upload_File) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Upload_File) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Upload_File) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Upload_File, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Upload_File) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Upload_File) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Upload_File_Data struct implement
type Upload_File_Data struct {
	Type           Storage_FileType `json:"type"`
	Mtime          int32            `json:"mtime"`
	Bytes          []uint8          `json:"bytes"`
	Dc_id          int32            `json:"dc_id"`
	File_token     []uint8          `json:"file_token"`
	Encryption_key []uint8          `json:"encryption_key"`
	Encryption_iv  []uint8          `json:"encryption_iv"`
	File_hashes    []FileHash       `json:"file_hashes"`
}

func (st *Upload_File_Data) ResetDefault() {
	st.Type.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Upload_File_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Type.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Mtime, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Bytes = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Bytes[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Bytes, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Dc_id, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.File_token = make([]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_uint8(&st.File_token[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.File_token, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Encryption_key = make([]uint8, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = _is.Read_uint8(&st.Encryption_key[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Encryption_key, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Encryption_iv = make([]uint8, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = _is.Read_uint8(&st.Encryption_iv[i3], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Encryption_iv, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.File_hashes = make([]FileHash, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = st.File_hashes[i4].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Upload_File_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Upload_File_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Upload_File_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Type.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Mtime, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Bytes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Bytes {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Dc_id, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.File_token)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.File_token {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Encryption_key)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Encryption_key {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Encryption_iv)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Encryption_iv {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.File_hashes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.File_hashes {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Upload_File_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupload_file struct implement
type TLupload_file struct {
	Data Upload_File_Data `json:"data"`
}

func (st *TLupload_file) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupload_file) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupload_file) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupload_file, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupload_file) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupload_file) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupload_fileCdnRedirect struct implement
type TLupload_fileCdnRedirect struct {
	Data Upload_File_Data `json:"data"`
}

func (st *TLupload_fileCdnRedirect) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupload_fileCdnRedirect) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupload_fileCdnRedirect) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupload_fileCdnRedirect, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupload_fileCdnRedirect) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupload_fileCdnRedirect) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputPrivacyKey struct implement
type InputPrivacyKey struct {
	Constructor int32                `json:"constructor"`
	Data        InputPrivacyKey_Data `json:"data"`
}

func (st *InputPrivacyKey) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputPrivacyKey) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputPrivacyKey) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputPrivacyKey, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputPrivacyKey) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputPrivacyKey) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputPrivacyKey_Data struct implement
type InputPrivacyKey_Data struct {
}

func (st *InputPrivacyKey_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputPrivacyKey_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputPrivacyKey_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputPrivacyKey_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputPrivacyKey_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputPrivacyKey_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPrivacyKeyStatusTimestamp struct implement
type TLinputPrivacyKeyStatusTimestamp struct {
	Data InputPrivacyKey_Data `json:"data"`
}

func (st *TLinputPrivacyKeyStatusTimestamp) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPrivacyKeyStatusTimestamp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPrivacyKeyStatusTimestamp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPrivacyKeyStatusTimestamp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPrivacyKeyStatusTimestamp) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPrivacyKeyStatusTimestamp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPrivacyKeyChatInvite struct implement
type TLinputPrivacyKeyChatInvite struct {
	Data InputPrivacyKey_Data `json:"data"`
}

func (st *TLinputPrivacyKeyChatInvite) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPrivacyKeyChatInvite) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPrivacyKeyChatInvite) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPrivacyKeyChatInvite, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPrivacyKeyChatInvite) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPrivacyKeyChatInvite) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPrivacyKeyPhoneCall struct implement
type TLinputPrivacyKeyPhoneCall struct {
	Data InputPrivacyKey_Data `json:"data"`
}

func (st *TLinputPrivacyKeyPhoneCall) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPrivacyKeyPhoneCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPrivacyKeyPhoneCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPrivacyKeyPhoneCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPrivacyKeyPhoneCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPrivacyKeyPhoneCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPrivacyKeyPhoneP2P struct implement
type TLinputPrivacyKeyPhoneP2P struct {
	Data InputPrivacyKey_Data `json:"data"`
}

func (st *TLinputPrivacyKeyPhoneP2P) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPrivacyKeyPhoneP2P) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPrivacyKeyPhoneP2P) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPrivacyKeyPhoneP2P, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPrivacyKeyPhoneP2P) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPrivacyKeyPhoneP2P) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPrivacyKeyForwards struct implement
type TLinputPrivacyKeyForwards struct {
	Data InputPrivacyKey_Data `json:"data"`
}

func (st *TLinputPrivacyKeyForwards) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPrivacyKeyForwards) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPrivacyKeyForwards) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPrivacyKeyForwards, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPrivacyKeyForwards) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPrivacyKeyForwards) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPrivacyKeyProfilePhoto struct implement
type TLinputPrivacyKeyProfilePhoto struct {
	Data InputPrivacyKey_Data `json:"data"`
}

func (st *TLinputPrivacyKeyProfilePhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPrivacyKeyProfilePhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPrivacyKeyProfilePhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPrivacyKeyProfilePhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPrivacyKeyProfilePhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPrivacyKeyProfilePhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPrivacyKeyPhoneNumber struct implement
type TLinputPrivacyKeyPhoneNumber struct {
	Data InputPrivacyKey_Data `json:"data"`
}

func (st *TLinputPrivacyKeyPhoneNumber) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPrivacyKeyPhoneNumber) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPrivacyKeyPhoneNumber) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPrivacyKeyPhoneNumber, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPrivacyKeyPhoneNumber) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPrivacyKeyPhoneNumber) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputPrivacyKeyAddedByPhone struct implement
type TLinputPrivacyKeyAddedByPhone struct {
	Data InputPrivacyKey_Data `json:"data"`
}

func (st *TLinputPrivacyKeyAddedByPhone) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputPrivacyKeyAddedByPhone) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputPrivacyKeyAddedByPhone) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputPrivacyKeyAddedByPhone, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputPrivacyKeyAddedByPhone) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputPrivacyKeyAddedByPhone) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Auth_ExportedAuthorization struct implement
type Auth_ExportedAuthorization struct {
	Constructor int32                           `json:"constructor"`
	Data        Auth_ExportedAuthorization_Data `json:"data"`
}

func (st *Auth_ExportedAuthorization) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Auth_ExportedAuthorization) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Auth_ExportedAuthorization) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Auth_ExportedAuthorization, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Auth_ExportedAuthorization) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Auth_ExportedAuthorization) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Auth_ExportedAuthorization_Data struct implement
type Auth_ExportedAuthorization_Data struct {
	Id    int32   `json:"id"`
	Bytes []uint8 `json:"bytes"`
}

func (st *Auth_ExportedAuthorization_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Auth_ExportedAuthorization_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Bytes = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Bytes[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Bytes, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Auth_ExportedAuthorization_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Auth_ExportedAuthorization_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Auth_ExportedAuthorization_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Bytes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Bytes {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Auth_ExportedAuthorization_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_exportedAuthorization struct implement
type TLauth_exportedAuthorization struct {
	Data Auth_ExportedAuthorization_Data `json:"data"`
}

func (st *TLauth_exportedAuthorization) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_exportedAuthorization) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_exportedAuthorization) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_exportedAuthorization, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_exportedAuthorization) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_exportedAuthorization) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChannelAdminLogEventAction struct implement
type ChannelAdminLogEventAction struct {
	Constructor int32                           `json:"constructor"`
	Data        ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *ChannelAdminLogEventAction) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChannelAdminLogEventAction) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChannelAdminLogEventAction) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChannelAdminLogEventAction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChannelAdminLogEventAction) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChannelAdminLogEventAction) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChannelAdminLogEventAction_Data struct implement
type ChannelAdminLogEventAction_Data struct {
	Prev_value         string             `json:"prev_value"`
	New_value          string             `json:"new_value"`
	Prev_photo         Photo              `json:"prev_photo"`
	New_photo          Photo              `json:"new_photo"`
	New_value_5        Bool               `json:"new_value_5"`
	Message            Message            `json:"message"`
	Prev_message       Message            `json:"prev_message"`
	New_message        Message            `json:"new_message"`
	Participant        ChannelParticipant `json:"participant"`
	Prev_participant   ChannelParticipant `json:"prev_participant"`
	New_participant    ChannelParticipant `json:"new_participant"`
	Prev_stickerset    InputStickerSet    `json:"prev_stickerset"`
	New_stickerset     InputStickerSet    `json:"new_stickerset"`
	Prev_banned_rights ChatBannedRights   `json:"prev_banned_rights"`
	New_banned_rights  ChatBannedRights   `json:"new_banned_rights"`
	Prev_value_16      int32              `json:"prev_value_16"`
	New_value_17       int32              `json:"new_value_17"`
	Prev_value_18      ChannelLocation    `json:"prev_value_18"`
	New_value_19       ChannelLocation    `json:"new_value_19"`
}

func (st *ChannelAdminLogEventAction_Data) ResetDefault() {
	st.Prev_photo.ResetDefault()
	st.New_photo.ResetDefault()
	st.New_value_5.ResetDefault()
	st.Message.ResetDefault()
	st.Prev_message.ResetDefault()
	st.New_message.ResetDefault()
	st.Participant.ResetDefault()
	st.Prev_participant.ResetDefault()
	st.New_participant.ResetDefault()
	st.Prev_stickerset.ResetDefault()
	st.New_stickerset.ResetDefault()
	st.Prev_banned_rights.ResetDefault()
	st.New_banned_rights.ResetDefault()
	st.Prev_value_18.ResetDefault()
	st.New_value_19.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChannelAdminLogEventAction_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Prev_value, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.New_value, 1, false)
	if err != nil {
		return err
	}

	err = st.Prev_photo.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = st.New_photo.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = st.New_value_5.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = st.Message.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = st.Prev_message.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	err = st.New_message.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	err = st.Participant.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err = st.Prev_participant.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err = st.New_participant.ReadBlock(_is, 10, false)
	if err != nil {
		return err
	}

	err = st.Prev_stickerset.ReadBlock(_is, 11, false)
	if err != nil {
		return err
	}

	err = st.New_stickerset.ReadBlock(_is, 12, false)
	if err != nil {
		return err
	}

	err = st.Prev_banned_rights.ReadBlock(_is, 13, false)
	if err != nil {
		return err
	}

	err = st.New_banned_rights.ReadBlock(_is, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Prev_value_16, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.New_value_17, 16, false)
	if err != nil {
		return err
	}

	err = st.Prev_value_18.ReadBlock(_is, 17, false)
	if err != nil {
		return err
	}

	err = st.New_value_19.ReadBlock(_is, 18, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChannelAdminLogEventAction_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChannelAdminLogEventAction_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChannelAdminLogEventAction_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Prev_value, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.New_value, 1)
	if err != nil {
		return err
	}

	err = st.Prev_photo.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = st.New_photo.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = st.New_value_5.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = st.Message.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = st.Prev_message.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	err = st.New_message.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	err = st.Participant.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = st.Prev_participant.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = st.New_participant.WriteBlock(_os, 10)
	if err != nil {
		return err
	}

	err = st.Prev_stickerset.WriteBlock(_os, 11)
	if err != nil {
		return err
	}

	err = st.New_stickerset.WriteBlock(_os, 12)
	if err != nil {
		return err
	}

	err = st.Prev_banned_rights.WriteBlock(_os, 13)
	if err != nil {
		return err
	}

	err = st.New_banned_rights.WriteBlock(_os, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Prev_value_16, 15)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.New_value_17, 16)
	if err != nil {
		return err
	}

	err = st.Prev_value_18.WriteBlock(_os, 17)
	if err != nil {
		return err
	}

	err = st.New_value_19.WriteBlock(_os, 18)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChannelAdminLogEventAction_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionChangeTitle struct implement
type TLchannelAdminLogEventActionChangeTitle struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionChangeTitle) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionChangeTitle) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionChangeTitle) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionChangeTitle, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionChangeTitle) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionChangeTitle) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionChangeAbout struct implement
type TLchannelAdminLogEventActionChangeAbout struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionChangeAbout) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionChangeAbout) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionChangeAbout) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionChangeAbout, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionChangeAbout) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionChangeAbout) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionChangeUsername struct implement
type TLchannelAdminLogEventActionChangeUsername struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionChangeUsername) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionChangeUsername) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionChangeUsername) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionChangeUsername, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionChangeUsername) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionChangeUsername) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionChangePhoto struct implement
type TLchannelAdminLogEventActionChangePhoto struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionChangePhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionChangePhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionChangePhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionChangePhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionChangePhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionChangePhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionToggleInvites struct implement
type TLchannelAdminLogEventActionToggleInvites struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionToggleInvites) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionToggleInvites) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionToggleInvites) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionToggleInvites, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionToggleInvites) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionToggleInvites) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionToggleSignatures struct implement
type TLchannelAdminLogEventActionToggleSignatures struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionToggleSignatures) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionToggleSignatures) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionToggleSignatures) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionToggleSignatures, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionToggleSignatures) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionToggleSignatures) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionUpdatePinned struct implement
type TLchannelAdminLogEventActionUpdatePinned struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionUpdatePinned) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionUpdatePinned) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionUpdatePinned) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionUpdatePinned, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionUpdatePinned) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionUpdatePinned) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionEditMessage struct implement
type TLchannelAdminLogEventActionEditMessage struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionEditMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionEditMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionEditMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionEditMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionEditMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionEditMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionDeleteMessage struct implement
type TLchannelAdminLogEventActionDeleteMessage struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionDeleteMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionDeleteMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionDeleteMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionDeleteMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionDeleteMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionDeleteMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionParticipantJoin struct implement
type TLchannelAdminLogEventActionParticipantJoin struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionParticipantJoin) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionParticipantJoin) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionParticipantJoin) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionParticipantJoin, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionParticipantJoin) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionParticipantJoin) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionParticipantLeave struct implement
type TLchannelAdminLogEventActionParticipantLeave struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionParticipantLeave) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionParticipantLeave) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionParticipantLeave) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionParticipantLeave, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionParticipantLeave) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionParticipantLeave) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionParticipantInvite struct implement
type TLchannelAdminLogEventActionParticipantInvite struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionParticipantInvite) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionParticipantInvite) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionParticipantInvite) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionParticipantInvite, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionParticipantInvite) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionParticipantInvite) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionParticipantToggleBan struct implement
type TLchannelAdminLogEventActionParticipantToggleBan struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionParticipantToggleBan) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionParticipantToggleBan) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionParticipantToggleBan) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionParticipantToggleBan, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionParticipantToggleBan) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionParticipantToggleBan) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionParticipantToggleAdmin struct implement
type TLchannelAdminLogEventActionParticipantToggleAdmin struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionParticipantToggleAdmin) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionParticipantToggleAdmin) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionParticipantToggleAdmin) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionParticipantToggleAdmin, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionParticipantToggleAdmin) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionParticipantToggleAdmin) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionChangeStickerSet struct implement
type TLchannelAdminLogEventActionChangeStickerSet struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionChangeStickerSet) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionChangeStickerSet) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionChangeStickerSet) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionChangeStickerSet, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionChangeStickerSet) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionChangeStickerSet) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionTogglePreHistoryHidden struct implement
type TLchannelAdminLogEventActionTogglePreHistoryHidden struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionTogglePreHistoryHidden) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionTogglePreHistoryHidden) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionTogglePreHistoryHidden) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionTogglePreHistoryHidden, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionTogglePreHistoryHidden) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionTogglePreHistoryHidden) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionDefaultBannedRights struct implement
type TLchannelAdminLogEventActionDefaultBannedRights struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionDefaultBannedRights) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionDefaultBannedRights) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionDefaultBannedRights) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionDefaultBannedRights, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionDefaultBannedRights) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionDefaultBannedRights) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionStopPoll struct implement
type TLchannelAdminLogEventActionStopPoll struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionStopPoll) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionStopPoll) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionStopPoll) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionStopPoll, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionStopPoll) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionStopPoll) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionChangeLinkedChat struct implement
type TLchannelAdminLogEventActionChangeLinkedChat struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionChangeLinkedChat) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionChangeLinkedChat) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionChangeLinkedChat) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionChangeLinkedChat, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionChangeLinkedChat) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionChangeLinkedChat) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionChangeLocation struct implement
type TLchannelAdminLogEventActionChangeLocation struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionChangeLocation) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionChangeLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionChangeLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionChangeLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionChangeLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionChangeLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelAdminLogEventActionToggleSlowMode struct implement
type TLchannelAdminLogEventActionToggleSlowMode struct {
	Data ChannelAdminLogEventAction_Data `json:"data"`
}

func (st *TLchannelAdminLogEventActionToggleSlowMode) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelAdminLogEventActionToggleSlowMode) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelAdminLogEventActionToggleSlowMode) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelAdminLogEventActionToggleSlowMode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelAdminLogEventActionToggleSlowMode) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelAdminLogEventActionToggleSlowMode) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_Themes struct implement
type Account_Themes struct {
	Constructor int32               `json:"constructor"`
	Data        Account_Themes_Data `json:"data"`
}

func (st *Account_Themes) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_Themes) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_Themes) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_Themes, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_Themes) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_Themes) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_Themes_Data struct implement
type Account_Themes_Data struct {
	Hash   int32   `json:"hash"`
	Themes []Theme `json:"themes"`
}

func (st *Account_Themes_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_Themes_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Themes = make([]Theme, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Themes[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_Themes_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_Themes_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_Themes_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Themes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Themes {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_Themes_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_themesNotModified struct implement
type TLaccount_themesNotModified struct {
	Data Account_Themes_Data `json:"data"`
}

func (st *TLaccount_themesNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_themesNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_themesNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_themesNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_themesNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_themesNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_themes struct implement
type TLaccount_themes struct {
	Data Account_Themes_Data `json:"data"`
}

func (st *TLaccount_themes) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_themes) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_themes) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_themes, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_themes) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_themes) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// DialogPeer struct implement
type DialogPeer struct {
	Constructor int32           `json:"constructor"`
	Data        DialogPeer_Data `json:"data"`
}

func (st *DialogPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *DialogPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DialogPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DialogPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DialogPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DialogPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// DialogPeer_Data struct implement
type DialogPeer_Data struct {
	Peer      Peer  `json:"peer"`
	Folder_id int32 `json:"folder_id"`
}

func (st *DialogPeer_Data) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *DialogPeer_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Folder_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DialogPeer_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DialogPeer_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DialogPeer_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Folder_id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DialogPeer_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdialogPeer struct implement
type TLdialogPeer struct {
	Data DialogPeer_Data `json:"data"`
}

func (st *TLdialogPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdialogPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdialogPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdialogPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdialogPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdialogPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdialogPeerFolder struct implement
type TLdialogPeerFolder struct {
	Data DialogPeer_Data `json:"data"`
}

func (st *TLdialogPeerFolder) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdialogPeerFolder) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdialogPeerFolder) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdialogPeerFolder, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdialogPeerFolder) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdialogPeerFolder) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PageCaption struct implement
type PageCaption struct {
	Constructor int32            `json:"constructor"`
	Data        PageCaption_Data `json:"data"`
}

func (st *PageCaption) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PageCaption) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PageCaption) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PageCaption, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PageCaption) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PageCaption) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PageCaption_Data struct implement
type PageCaption_Data struct {
	Text   RichText `json:"text"`
	Credit RichText `json:"credit"`
}

func (st *PageCaption_Data) ResetDefault() {
	st.Text.ResetDefault()
	st.Credit.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PageCaption_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Text.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Credit.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PageCaption_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PageCaption_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PageCaption_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Text.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Credit.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PageCaption_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpageCaption struct implement
type TLpageCaption struct {
	Data PageCaption_Data `json:"data"`
}

func (st *TLpageCaption) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpageCaption) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpageCaption) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpageCaption, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpageCaption) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpageCaption) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StickerSet struct implement
type StickerSet struct {
	Constructor int32           `json:"constructor"`
	Data        StickerSet_Data `json:"data"`
}

func (st *StickerSet) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *StickerSet) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StickerSet) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StickerSet, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StickerSet) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StickerSet) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StickerSet_Data struct implement
type StickerSet_Data struct {
	Archived       bool      `json:"archived"`
	Official       bool      `json:"official"`
	Masks          bool      `json:"masks"`
	Animated       bool      `json:"animated"`
	Installed_date int32     `json:"installed_date"`
	Id             int64     `json:"id"`
	Access_hash    int64     `json:"access_hash"`
	Title          string    `json:"title"`
	Short_name     string    `json:"short_name"`
	Thumb          PhotoSize `json:"thumb"`
	Thumb_dc_id    int32     `json:"thumb_dc_id"`
	Count          int32     `json:"count"`
	Hash           int32     `json:"hash"`
}

func (st *StickerSet_Data) ResetDefault() {
	st.Thumb.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *StickerSet_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Archived, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Official, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Masks, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Animated, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Installed_date, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Id, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Short_name, 8, false)
	if err != nil {
		return err
	}

	err = st.Thumb.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Thumb_dc_id, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Count, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 12, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StickerSet_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StickerSet_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StickerSet_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Archived, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Official, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Masks, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Animated, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Installed_date, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Id, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Short_name, 8)
	if err != nil {
		return err
	}

	err = st.Thumb.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Thumb_dc_id, 10)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Count, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 12)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StickerSet_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstickerSet struct implement
type TLstickerSet struct {
	Data StickerSet_Data `json:"data"`
}

func (st *TLstickerSet) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstickerSet) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstickerSet) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstickerSet, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstickerSet) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstickerSet) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// UserProfilePhoto struct implement
type UserProfilePhoto struct {
	Constructor int32                 `json:"constructor"`
	Data        UserProfilePhoto_Data `json:"data"`
}

func (st *UserProfilePhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *UserProfilePhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *UserProfilePhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserProfilePhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *UserProfilePhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *UserProfilePhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// UserProfilePhoto_Data struct implement
type UserProfilePhoto_Data struct {
	Has_video   bool         `json:"has_video"`
	Photo_id    int64        `json:"photo_id"`
	Photo_small FileLocation `json:"photo_small"`
	Photo_big   FileLocation `json:"photo_big"`
	Dc_id       int32        `json:"dc_id"`
}

func (st *UserProfilePhoto_Data) ResetDefault() {
	st.Photo_small.ResetDefault()
	st.Photo_big.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *UserProfilePhoto_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Has_video, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Photo_id, 1, false)
	if err != nil {
		return err
	}

	err = st.Photo_small.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = st.Photo_big.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Dc_id, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *UserProfilePhoto_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserProfilePhoto_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *UserProfilePhoto_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Has_video, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Photo_id, 1)
	if err != nil {
		return err
	}

	err = st.Photo_small.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = st.Photo_big.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Dc_id, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *UserProfilePhoto_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLuserProfilePhotoEmpty struct implement
type TLuserProfilePhotoEmpty struct {
	Data UserProfilePhoto_Data `json:"data"`
}

func (st *TLuserProfilePhotoEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLuserProfilePhotoEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLuserProfilePhotoEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLuserProfilePhotoEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLuserProfilePhotoEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLuserProfilePhotoEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLuserProfilePhoto struct implement
type TLuserProfilePhoto struct {
	Data UserProfilePhoto_Data `json:"data"`
}

func (st *TLuserProfilePhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLuserProfilePhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLuserProfilePhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLuserProfilePhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLuserProfilePhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLuserProfilePhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Payments_BankCardData struct implement
type Payments_BankCardData struct {
	Constructor int32                      `json:"constructor"`
	Data        Payments_BankCardData_Data `json:"data"`
}

func (st *Payments_BankCardData) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Payments_BankCardData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Payments_BankCardData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Payments_BankCardData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Payments_BankCardData) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Payments_BankCardData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Payments_BankCardData_Data struct implement
type Payments_BankCardData_Data struct {
	Title     string            `json:"title"`
	Open_urls []BankCardOpenUrl `json:"open_urls"`
}

func (st *Payments_BankCardData_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Payments_BankCardData_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Title, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Open_urls = make([]BankCardOpenUrl, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Open_urls[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Payments_BankCardData_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Payments_BankCardData_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Payments_BankCardData_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Title, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Open_urls)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Open_urls {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Payments_BankCardData_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpayments_bankCardData struct implement
type TLpayments_bankCardData struct {
	Data Payments_BankCardData_Data `json:"data"`
}

func (st *TLpayments_bankCardData) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpayments_bankCardData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpayments_bankCardData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpayments_bankCardData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpayments_bankCardData) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpayments_bankCardData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_SupportName struct implement
type Help_SupportName struct {
	Constructor int32                 `json:"constructor"`
	Data        Help_SupportName_Data `json:"data"`
}

func (st *Help_SupportName) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_SupportName) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_SupportName) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_SupportName, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_SupportName) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_SupportName) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_SupportName_Data struct implement
type Help_SupportName_Data struct {
	Name string `json:"name"`
}

func (st *Help_SupportName_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_SupportName_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Name, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_SupportName_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_SupportName_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_SupportName_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Name, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_SupportName_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_supportName struct implement
type TLhelp_supportName struct {
	Data Help_SupportName_Data `json:"data"`
}

func (st *TLhelp_supportName) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_supportName) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_supportName) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_supportName, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_supportName) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_supportName) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PeerNotifySettings struct implement
type PeerNotifySettings struct {
	Constructor int32                   `json:"constructor"`
	Data        PeerNotifySettings_Data `json:"data"`
}

func (st *PeerNotifySettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PeerNotifySettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PeerNotifySettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PeerNotifySettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PeerNotifySettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PeerNotifySettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PeerNotifySettings_Data struct implement
type PeerNotifySettings_Data struct {
	Show_previews Bool   `json:"show_previews"`
	Silent        Bool   `json:"silent"`
	Mute_until    int32  `json:"mute_until"`
	Sound         string `json:"sound"`
}

func (st *PeerNotifySettings_Data) ResetDefault() {
	st.Show_previews.ResetDefault()
	st.Silent.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PeerNotifySettings_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Show_previews.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Silent.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Mute_until, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Sound, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PeerNotifySettings_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PeerNotifySettings_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PeerNotifySettings_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Show_previews.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Silent.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Mute_until, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Sound, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PeerNotifySettings_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpeerNotifySettings struct implement
type TLpeerNotifySettings struct {
	Data PeerNotifySettings_Data `json:"data"`
}

func (st *TLpeerNotifySettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpeerNotifySettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpeerNotifySettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpeerNotifySettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpeerNotifySettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpeerNotifySettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_TmpPassword struct implement
type Account_TmpPassword struct {
	Constructor int32                    `json:"constructor"`
	Data        Account_TmpPassword_Data `json:"data"`
}

func (st *Account_TmpPassword) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_TmpPassword) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_TmpPassword) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_TmpPassword, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_TmpPassword) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_TmpPassword) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_TmpPassword_Data struct implement
type Account_TmpPassword_Data struct {
	Tmp_password []uint8 `json:"tmp_password"`
	Valid_until  int32   `json:"valid_until"`
}

func (st *Account_TmpPassword_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_TmpPassword_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Tmp_password = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Tmp_password[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Tmp_password, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Valid_until, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_TmpPassword_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_TmpPassword_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_TmpPassword_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Tmp_password)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Tmp_password {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Valid_until, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_TmpPassword_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_tmpPassword struct implement
type TLaccount_tmpPassword struct {
	Data Account_TmpPassword_Data `json:"data"`
}

func (st *TLaccount_tmpPassword) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_tmpPassword) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_tmpPassword) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_tmpPassword, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_tmpPassword) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_tmpPassword) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StatsPercentValue struct implement
type StatsPercentValue struct {
	Constructor int32                  `json:"constructor"`
	Data        StatsPercentValue_Data `json:"data"`
}

func (st *StatsPercentValue) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *StatsPercentValue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StatsPercentValue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StatsPercentValue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StatsPercentValue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StatsPercentValue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StatsPercentValue_Data struct implement
type StatsPercentValue_Data struct {
	Part  float64 `json:"part"`
	Total float64 `json:"total"`
}

func (st *StatsPercentValue_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *StatsPercentValue_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_float64(&st.Part, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Total, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StatsPercentValue_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StatsPercentValue_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StatsPercentValue_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_float64(st.Part, 0)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Total, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StatsPercentValue_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstatsPercentValue struct implement
type TLstatsPercentValue struct {
	Data StatsPercentValue_Data `json:"data"`
}

func (st *TLstatsPercentValue) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstatsPercentValue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstatsPercentValue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstatsPercentValue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstatsPercentValue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstatsPercentValue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Updates_ChannelDifference struct implement
type Updates_ChannelDifference struct {
	Constructor int32                          `json:"constructor"`
	Data        Updates_ChannelDifference_Data `json:"data"`
}

func (st *Updates_ChannelDifference) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Updates_ChannelDifference) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Updates_ChannelDifference) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Updates_ChannelDifference, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Updates_ChannelDifference) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Updates_ChannelDifference) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Updates_ChannelDifference_Data struct implement
type Updates_ChannelDifference_Data struct {
	Final         bool      `json:"final"`
	Pts           int32     `json:"pts"`
	Timeout       int32     `json:"timeout"`
	Dialog        Dialog    `json:"dialog"`
	Messages      []Message `json:"messages"`
	Chats         []Chat    `json:"chats"`
	Users         []User    `json:"users"`
	New_messages  []Message `json:"new_messages"`
	Other_updates []Update  `json:"other_updates"`
}

func (st *Updates_ChannelDifference_Data) ResetDefault() {
	st.Dialog.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Updates_ChannelDifference_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Final, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Pts, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Timeout, 2, false)
	if err != nil {
		return err
	}

	err = st.Dialog.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Messages = make([]Message, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Messages[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Chats[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Users[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.New_messages = make([]Message, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.New_messages[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Other_updates = make([]Update, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = st.Other_updates[i4].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Updates_ChannelDifference_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Updates_ChannelDifference_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Updates_ChannelDifference_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Final, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Pts, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Timeout, 2)
	if err != nil {
		return err
	}

	err = st.Dialog.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Messages)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Messages {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.New_messages)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.New_messages {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Other_updates)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Other_updates {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Updates_ChannelDifference_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdates_channelDifferenceEmpty struct implement
type TLupdates_channelDifferenceEmpty struct {
	Data Updates_ChannelDifference_Data `json:"data"`
}

func (st *TLupdates_channelDifferenceEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdates_channelDifferenceEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdates_channelDifferenceEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdates_channelDifferenceEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdates_channelDifferenceEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdates_channelDifferenceEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdates_channelDifferenceTooLong struct implement
type TLupdates_channelDifferenceTooLong struct {
	Data Updates_ChannelDifference_Data `json:"data"`
}

func (st *TLupdates_channelDifferenceTooLong) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdates_channelDifferenceTooLong) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdates_channelDifferenceTooLong) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdates_channelDifferenceTooLong, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdates_channelDifferenceTooLong) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdates_channelDifferenceTooLong) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdates_channelDifference struct implement
type TLupdates_channelDifference struct {
	Data Updates_ChannelDifference_Data `json:"data"`
}

func (st *TLupdates_channelDifference) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdates_channelDifference) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdates_channelDifference) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdates_channelDifference, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdates_channelDifference) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdates_channelDifference) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// CdnPublicKey struct implement
type CdnPublicKey struct {
	Constructor int32             `json:"constructor"`
	Data        CdnPublicKey_Data `json:"data"`
}

func (st *CdnPublicKey) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *CdnPublicKey) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *CdnPublicKey) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CdnPublicKey, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *CdnPublicKey) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *CdnPublicKey) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// CdnPublicKey_Data struct implement
type CdnPublicKey_Data struct {
	Dc_id      int32  `json:"dc_id"`
	Public_key string `json:"public_key"`
}

func (st *CdnPublicKey_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *CdnPublicKey_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Dc_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Public_key, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *CdnPublicKey_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CdnPublicKey_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *CdnPublicKey_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Dc_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Public_key, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *CdnPublicKey_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcdnPublicKey struct implement
type TLcdnPublicKey struct {
	Data CdnPublicKey_Data `json:"data"`
}

func (st *TLcdnPublicKey) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcdnPublicKey) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcdnPublicKey) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcdnPublicKey, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcdnPublicKey) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcdnPublicKey) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// CodeSettings struct implement
type CodeSettings struct {
	Constructor int32             `json:"constructor"`
	Data        CodeSettings_Data `json:"data"`
}

func (st *CodeSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *CodeSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *CodeSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CodeSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *CodeSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *CodeSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// CodeSettings_Data struct implement
type CodeSettings_Data struct {
	Allow_flashcall bool `json:"allow_flashcall"`
	Current_number  bool `json:"current_number"`
	Allow_app_hash  bool `json:"allow_app_hash"`
}

func (st *CodeSettings_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *CodeSettings_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Allow_flashcall, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Current_number, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Allow_app_hash, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *CodeSettings_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CodeSettings_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *CodeSettings_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Allow_flashcall, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Current_number, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Allow_app_hash, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *CodeSettings_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcodeSettings struct implement
type TLcodeSettings struct {
	Data CodeSettings_Data `json:"data"`
}

func (st *TLcodeSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcodeSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcodeSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcodeSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcodeSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcodeSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_DeepLinkInfo struct implement
type Help_DeepLinkInfo struct {
	Constructor int32                  `json:"constructor"`
	Data        Help_DeepLinkInfo_Data `json:"data"`
}

func (st *Help_DeepLinkInfo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_DeepLinkInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_DeepLinkInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_DeepLinkInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_DeepLinkInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_DeepLinkInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_DeepLinkInfo_Data struct implement
type Help_DeepLinkInfo_Data struct {
	Update_app bool            `json:"update_app"`
	Message    string          `json:"message"`
	Entities   []MessageEntity `json:"entities"`
}

func (st *Help_DeepLinkInfo_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_DeepLinkInfo_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Update_app, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_DeepLinkInfo_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_DeepLinkInfo_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_DeepLinkInfo_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Update_app, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_DeepLinkInfo_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_deepLinkInfoEmpty struct implement
type TLhelp_deepLinkInfoEmpty struct {
	Data Help_DeepLinkInfo_Data `json:"data"`
}

func (st *TLhelp_deepLinkInfoEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_deepLinkInfoEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_deepLinkInfoEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_deepLinkInfoEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_deepLinkInfoEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_deepLinkInfoEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_deepLinkInfo struct implement
type TLhelp_deepLinkInfo struct {
	Data Help_DeepLinkInfo_Data `json:"data"`
}

func (st *TLhelp_deepLinkInfo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_deepLinkInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_deepLinkInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_deepLinkInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_deepLinkInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_deepLinkInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputDialogPeer struct implement
type InputDialogPeer struct {
	Constructor int32                `json:"constructor"`
	Data        InputDialogPeer_Data `json:"data"`
}

func (st *InputDialogPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputDialogPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputDialogPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputDialogPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputDialogPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputDialogPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputDialogPeer_Data struct implement
type InputDialogPeer_Data struct {
	Peer      InputPeer `json:"peer"`
	Folder_id int32     `json:"folder_id"`
}

func (st *InputDialogPeer_Data) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputDialogPeer_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Folder_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputDialogPeer_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputDialogPeer_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputDialogPeer_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Folder_id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputDialogPeer_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputDialogPeer struct implement
type TLinputDialogPeer struct {
	Data InputDialogPeer_Data `json:"data"`
}

func (st *TLinputDialogPeer) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputDialogPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputDialogPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputDialogPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputDialogPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputDialogPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputDialogPeerFolder struct implement
type TLinputDialogPeerFolder struct {
	Data InputDialogPeer_Data `json:"data"`
}

func (st *TLinputDialogPeerFolder) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputDialogPeerFolder) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputDialogPeerFolder) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputDialogPeerFolder, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputDialogPeerFolder) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputDialogPeerFolder) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputSecureFile struct implement
type InputSecureFile struct {
	Constructor int32                `json:"constructor"`
	Data        InputSecureFile_Data `json:"data"`
}

func (st *InputSecureFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputSecureFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputSecureFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputSecureFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputSecureFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputSecureFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputSecureFile_Data struct implement
type InputSecureFile_Data struct {
	Id           int64   `json:"id"`
	Parts        int32   `json:"parts"`
	Md5_checksum string  `json:"md5_checksum"`
	File_hash    []uint8 `json:"file_hash"`
	Secret       []uint8 `json:"secret"`
	Access_hash  int64   `json:"access_hash"`
}

func (st *InputSecureFile_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputSecureFile_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Parts, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Md5_checksum, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.File_hash = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.File_hash[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.File_hash, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Secret = make([]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_uint8(&st.Secret[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Secret, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int64(&st.Access_hash, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputSecureFile_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputSecureFile_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputSecureFile_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Parts, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Md5_checksum, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.File_hash)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.File_hash {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Secret)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Secret {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int64(st.Access_hash, 5)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputSecureFile_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputSecureFileUploaded struct implement
type TLinputSecureFileUploaded struct {
	Data InputSecureFile_Data `json:"data"`
}

func (st *TLinputSecureFileUploaded) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputSecureFileUploaded) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputSecureFileUploaded) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputSecureFileUploaded, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputSecureFileUploaded) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputSecureFileUploaded) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputSecureFile struct implement
type TLinputSecureFile struct {
	Data InputSecureFile_Data `json:"data"`
}

func (st *TLinputSecureFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputSecureFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputSecureFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputSecureFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputSecureFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputSecureFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ThemeSettings struct implement
type ThemeSettings struct {
	Constructor int32              `json:"constructor"`
	Data        ThemeSettings_Data `json:"data"`
}

func (st *ThemeSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ThemeSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ThemeSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ThemeSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ThemeSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ThemeSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ThemeSettings_Data struct implement
type ThemeSettings_Data struct {
	Base_theme           BaseTheme `json:"base_theme"`
	Accent_color         int32     `json:"accent_color"`
	Message_top_color    int32     `json:"message_top_color"`
	Message_bottom_color int32     `json:"message_bottom_color"`
	Wallpaper            WallPaper `json:"wallpaper"`
}

func (st *ThemeSettings_Data) ResetDefault() {
	st.Base_theme.ResetDefault()
	st.Wallpaper.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ThemeSettings_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Base_theme.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Accent_color, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Message_top_color, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Message_bottom_color, 3, false)
	if err != nil {
		return err
	}

	err = st.Wallpaper.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ThemeSettings_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ThemeSettings_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ThemeSettings_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Base_theme.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Accent_color, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Message_top_color, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Message_bottom_color, 3)
	if err != nil {
		return err
	}

	err = st.Wallpaper.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ThemeSettings_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLthemeSettings struct implement
type TLthemeSettings struct {
	Data ThemeSettings_Data `json:"data"`
}

func (st *TLthemeSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLthemeSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLthemeSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLthemeSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLthemeSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLthemeSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// LangPackLanguage struct implement
type LangPackLanguage struct {
	Constructor int32                 `json:"constructor"`
	Data        LangPackLanguage_Data `json:"data"`
}

func (st *LangPackLanguage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *LangPackLanguage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *LangPackLanguage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require LangPackLanguage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *LangPackLanguage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *LangPackLanguage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// LangPackLanguage_Data struct implement
type LangPackLanguage_Data struct {
	Official         bool   `json:"official"`
	Rtl              bool   `json:"rtl"`
	Beta             bool   `json:"beta"`
	Name             string `json:"name"`
	Native_name      string `json:"native_name"`
	Lang_code        string `json:"lang_code"`
	Base_lang_code   string `json:"base_lang_code"`
	Plural_code      string `json:"plural_code"`
	Strings_count    int32  `json:"strings_count"`
	Translated_count int32  `json:"translated_count"`
	Translations_url string `json:"translations_url"`
}

func (st *LangPackLanguage_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *LangPackLanguage_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Official, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Rtl, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Beta, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Name, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Native_name, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Lang_code, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Base_lang_code, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Plural_code, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Strings_count, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Translated_count, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Translations_url, 10, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *LangPackLanguage_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require LangPackLanguage_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *LangPackLanguage_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Official, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Rtl, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Beta, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Name, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Native_name, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Lang_code, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Base_lang_code, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Plural_code, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Strings_count, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Translated_count, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Translations_url, 10)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *LangPackLanguage_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLlangPackLanguage struct implement
type TLlangPackLanguage struct {
	Data LangPackLanguage_Data `json:"data"`
}

func (st *TLlangPackLanguage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLlangPackLanguage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLlangPackLanguage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLlangPackLanguage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLlangPackLanguage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLlangPackLanguage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// NearestDc struct implement
type NearestDc struct {
	Constructor int32          `json:"constructor"`
	Data        NearestDc_Data `json:"data"`
}

func (st *NearestDc) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *NearestDc) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *NearestDc) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require NearestDc, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *NearestDc) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *NearestDc) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// NearestDc_Data struct implement
type NearestDc_Data struct {
	Country    string `json:"country"`
	This_dc    int32  `json:"this_dc"`
	Nearest_dc int32  `json:"nearest_dc"`
}

func (st *NearestDc_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *NearestDc_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Country, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.This_dc, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Nearest_dc, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *NearestDc_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require NearestDc_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *NearestDc_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Country, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.This_dc, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Nearest_dc, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *NearestDc_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLnearestDc struct implement
type TLnearestDc struct {
	Data NearestDc_Data `json:"data"`
}

func (st *TLnearestDc) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLnearestDc) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLnearestDc) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLnearestDc, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLnearestDc) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLnearestDc) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PaymentCharge struct implement
type PaymentCharge struct {
	Constructor int32              `json:"constructor"`
	Data        PaymentCharge_Data `json:"data"`
}

func (st *PaymentCharge) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PaymentCharge) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PaymentCharge) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PaymentCharge, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PaymentCharge) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PaymentCharge) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PaymentCharge_Data struct implement
type PaymentCharge_Data struct {
	Id                 string `json:"id"`
	Provider_charge_id string `json:"provider_charge_id"`
}

func (st *PaymentCharge_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *PaymentCharge_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Provider_charge_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PaymentCharge_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PaymentCharge_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PaymentCharge_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Provider_charge_id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PaymentCharge_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpaymentCharge struct implement
type TLpaymentCharge struct {
	Data PaymentCharge_Data `json:"data"`
}

func (st *TLpaymentCharge) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpaymentCharge) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpaymentCharge) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpaymentCharge, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpaymentCharge) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpaymentCharge) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputWallPaper struct implement
type InputWallPaper struct {
	Constructor int32               `json:"constructor"`
	Data        InputWallPaper_Data `json:"data"`
}

func (st *InputWallPaper) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *InputWallPaper) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputWallPaper) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputWallPaper, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputWallPaper) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputWallPaper) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// InputWallPaper_Data struct implement
type InputWallPaper_Data struct {
	Id          int64  `json:"id"`
	Access_hash int64  `json:"access_hash"`
	Slug        string `json:"slug"`
}

func (st *InputWallPaper_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InputWallPaper_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Slug, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InputWallPaper_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InputWallPaper_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InputWallPaper_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Slug, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InputWallPaper_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputWallPaper struct implement
type TLinputWallPaper struct {
	Data InputWallPaper_Data `json:"data"`
}

func (st *TLinputWallPaper) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputWallPaper) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputWallPaper) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputWallPaper, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputWallPaper) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputWallPaper) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputWallPaperSlug struct implement
type TLinputWallPaperSlug struct {
	Data InputWallPaper_Data `json:"data"`
}

func (st *TLinputWallPaperSlug) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputWallPaperSlug) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputWallPaperSlug) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputWallPaperSlug, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputWallPaperSlug) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputWallPaperSlug) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinputWallPaperNoFile struct implement
type TLinputWallPaperNoFile struct {
	Data InputWallPaper_Data `json:"data"`
}

func (st *TLinputWallPaperNoFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinputWallPaperNoFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinputWallPaperNoFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinputWallPaperNoFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinputWallPaperNoFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinputWallPaperNoFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StickerSetCovered struct implement
type StickerSetCovered struct {
	Constructor int32                  `json:"constructor"`
	Data        StickerSetCovered_Data `json:"data"`
}

func (st *StickerSetCovered) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *StickerSetCovered) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StickerSetCovered) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StickerSetCovered, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StickerSetCovered) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StickerSetCovered) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StickerSetCovered_Data struct implement
type StickerSetCovered_Data struct {
	Set    StickerSet `json:"set"`
	Cover  Document   `json:"cover"`
	Covers []Document `json:"covers"`
}

func (st *StickerSetCovered_Data) ResetDefault() {
	st.Set.ResetDefault()
	st.Cover.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *StickerSetCovered_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Set.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Cover.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Covers = make([]Document, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Covers[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StickerSetCovered_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StickerSetCovered_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StickerSetCovered_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Set.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Cover.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Covers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Covers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StickerSetCovered_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstickerSetCovered struct implement
type TLstickerSetCovered struct {
	Data StickerSetCovered_Data `json:"data"`
}

func (st *TLstickerSetCovered) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstickerSetCovered) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstickerSetCovered) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstickerSetCovered, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstickerSetCovered) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstickerSetCovered) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstickerSetMultiCovered struct implement
type TLstickerSetMultiCovered struct {
	Data StickerSetCovered_Data `json:"data"`
}

func (st *TLstickerSetMultiCovered) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstickerSetMultiCovered) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstickerSetMultiCovered) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstickerSetMultiCovered, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstickerSetMultiCovered) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstickerSetMultiCovered) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_SentEmailCode struct implement
type Account_SentEmailCode struct {
	Constructor int32                      `json:"constructor"`
	Data        Account_SentEmailCode_Data `json:"data"`
}

func (st *Account_SentEmailCode) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_SentEmailCode) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_SentEmailCode) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_SentEmailCode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_SentEmailCode) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_SentEmailCode) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account_SentEmailCode_Data struct implement
type Account_SentEmailCode_Data struct {
	Email_pattern string `json:"email_pattern"`
	Length        int32  `json:"length"`
}

func (st *Account_SentEmailCode_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Account_SentEmailCode_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Email_pattern, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Length, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Account_SentEmailCode_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account_SentEmailCode_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Account_SentEmailCode_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Email_pattern, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Length, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Account_SentEmailCode_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_sentEmailCode struct implement
type TLaccount_sentEmailCode struct {
	Data Account_SentEmailCode_Data `json:"data"`
}

func (st *TLaccount_sentEmailCode) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_sentEmailCode) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_sentEmailCode) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_sentEmailCode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_sentEmailCode) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_sentEmailCode) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_InactiveChats struct implement
type Messages_InactiveChats struct {
	Constructor int32                       `json:"constructor"`
	Data        Messages_InactiveChats_Data `json:"data"`
}

func (st *Messages_InactiveChats) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_InactiveChats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_InactiveChats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_InactiveChats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_InactiveChats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_InactiveChats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_InactiveChats_Data struct implement
type Messages_InactiveChats_Data struct {
	Dates []int32 `json:"dates"`
	Chats []Chat  `json:"chats"`
	Users []User  `json:"users"`
}

func (st *Messages_InactiveChats_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_InactiveChats_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Dates = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Dates[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Chats[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Users[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_InactiveChats_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_InactiveChats_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_InactiveChats_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Dates)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Dates {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_InactiveChats_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_inactiveChats struct implement
type TLmessages_inactiveChats struct {
	Data Messages_InactiveChats_Data `json:"data"`
}

func (st *TLmessages_inactiveChats) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_inactiveChats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_inactiveChats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_inactiveChats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_inactiveChats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_inactiveChats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// True struct implement
type True struct {
	Constructor int32     `json:"constructor"`
	Data        True_Data `json:"data"`
}

func (st *True) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *True) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *True) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require True, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *True) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *True) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// True_Data struct implement
type True_Data struct {
}

func (st *True_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *True_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *True_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require True_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *True_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *True_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLtrue struct implement
type TLtrue struct {
	Data True_Data `json:"data"`
}

func (st *TLtrue) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLtrue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLtrue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLtrue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLtrue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLtrue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Photos_Photos struct implement
type Photos_Photos struct {
	Constructor int32              `json:"constructor"`
	Data        Photos_Photos_Data `json:"data"`
}

func (st *Photos_Photos) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Photos_Photos) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Photos_Photos) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Photos_Photos, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Photos_Photos) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Photos_Photos) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Photos_Photos_Data struct implement
type Photos_Photos_Data struct {
	Photos []Photo `json:"photos"`
	Users  []User  `json:"users"`
	Count  int32   `json:"count"`
}

func (st *Photos_Photos_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Photos_Photos_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Photos = make([]Photo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Photos[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Users[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Count, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Photos_Photos_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Photos_Photos_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Photos_Photos_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Photos)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Photos {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Count, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Photos_Photos_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphotos_photos struct implement
type TLphotos_photos struct {
	Data Photos_Photos_Data `json:"data"`
}

func (st *TLphotos_photos) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphotos_photos) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphotos_photos) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphotos_photos, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphotos_photos) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphotos_photos) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphotos_photosSlice struct implement
type TLphotos_photosSlice struct {
	Data Photos_Photos_Data `json:"data"`
}

func (st *TLphotos_photosSlice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphotos_photosSlice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphotos_photosSlice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphotos_photosSlice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphotos_photosSlice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphotos_photosSlice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// DraftMessage struct implement
type DraftMessage struct {
	Constructor int32             `json:"constructor"`
	Data        DraftMessage_Data `json:"data"`
}

func (st *DraftMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *DraftMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DraftMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DraftMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DraftMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DraftMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// DraftMessage_Data struct implement
type DraftMessage_Data struct {
	Date            int32           `json:"date"`
	No_webpage      bool            `json:"no_webpage"`
	Reply_to_msg_id int32           `json:"reply_to_msg_id"`
	Message         string          `json:"message"`
	Entities        []MessageEntity `json:"entities"`
}

func (st *DraftMessage_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *DraftMessage_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Date, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.No_webpage, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Reply_to_msg_id, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *DraftMessage_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DraftMessage_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *DraftMessage_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Date, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.No_webpage, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Reply_to_msg_id, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *DraftMessage_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdraftMessageEmpty struct implement
type TLdraftMessageEmpty struct {
	Data DraftMessage_Data `json:"data"`
}

func (st *TLdraftMessageEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdraftMessageEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdraftMessageEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdraftMessageEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdraftMessageEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdraftMessageEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdraftMessage struct implement
type TLdraftMessage struct {
	Data DraftMessage_Data `json:"data"`
}

func (st *TLdraftMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdraftMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdraftMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdraftMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdraftMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdraftMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// HighScore struct implement
type HighScore struct {
	Constructor int32          `json:"constructor"`
	Data        HighScore_Data `json:"data"`
}

func (st *HighScore) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *HighScore) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HighScore) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HighScore, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HighScore) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HighScore) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// HighScore_Data struct implement
type HighScore_Data struct {
	Pos     int32 `json:"pos"`
	User_id int32 `json:"user_id"`
	Score   int32 `json:"score"`
}

func (st *HighScore_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *HighScore_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Pos, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.User_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Score, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *HighScore_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HighScore_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *HighScore_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Pos, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.User_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Score, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *HighScore_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhighScore struct implement
type TLhighScore struct {
	Data HighScore_Data `json:"data"`
}

func (st *TLhighScore) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhighScore) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhighScore) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhighScore, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhighScore) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhighScore) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_StickerSetInstallResult struct implement
type Messages_StickerSetInstallResult struct {
	Constructor int32                                 `json:"constructor"`
	Data        Messages_StickerSetInstallResult_Data `json:"data"`
}

func (st *Messages_StickerSetInstallResult) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_StickerSetInstallResult) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_StickerSetInstallResult) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_StickerSetInstallResult, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_StickerSetInstallResult) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_StickerSetInstallResult) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_StickerSetInstallResult_Data struct implement
type Messages_StickerSetInstallResult_Data struct {
	Sets []StickerSetCovered `json:"sets"`
}

func (st *Messages_StickerSetInstallResult_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_StickerSetInstallResult_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Sets = make([]StickerSetCovered, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Sets[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_StickerSetInstallResult_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_StickerSetInstallResult_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_StickerSetInstallResult_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Sets)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Sets {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_StickerSetInstallResult_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_stickerSetInstallResultSuccess struct implement
type TLmessages_stickerSetInstallResultSuccess struct {
	Data Messages_StickerSetInstallResult_Data `json:"data"`
}

func (st *TLmessages_stickerSetInstallResultSuccess) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_stickerSetInstallResultSuccess) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_stickerSetInstallResultSuccess) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_stickerSetInstallResultSuccess, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_stickerSetInstallResultSuccess) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_stickerSetInstallResultSuccess) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_stickerSetInstallResultArchive struct implement
type TLmessages_stickerSetInstallResultArchive struct {
	Data Messages_StickerSetInstallResult_Data `json:"data"`
}

func (st *TLmessages_stickerSetInstallResultArchive) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_stickerSetInstallResultArchive) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_stickerSetInstallResultArchive) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_stickerSetInstallResultArchive, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_stickerSetInstallResultArchive) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_stickerSetInstallResultArchive) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_FavedStickers struct implement
type Messages_FavedStickers struct {
	Constructor int32                       `json:"constructor"`
	Data        Messages_FavedStickers_Data `json:"data"`
}

func (st *Messages_FavedStickers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_FavedStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_FavedStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_FavedStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_FavedStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_FavedStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Messages_FavedStickers_Data struct implement
type Messages_FavedStickers_Data struct {
	Hash     int32         `json:"hash"`
	Packs    []StickerPack `json:"packs"`
	Stickers []Document    `json:"stickers"`
}

func (st *Messages_FavedStickers_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Messages_FavedStickers_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Packs = make([]StickerPack, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Packs[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Stickers = make([]Document, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Stickers[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Messages_FavedStickers_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Messages_FavedStickers_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Messages_FavedStickers_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Packs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Packs {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Stickers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Stickers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Messages_FavedStickers_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_favedStickersNotModified struct implement
type TLmessages_favedStickersNotModified struct {
	Data Messages_FavedStickers_Data `json:"data"`
}

func (st *TLmessages_favedStickersNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_favedStickersNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_favedStickersNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_favedStickersNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_favedStickersNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_favedStickersNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_favedStickers struct implement
type TLmessages_favedStickers struct {
	Data Messages_FavedStickers_Data `json:"data"`
}

func (st *TLmessages_favedStickers) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_favedStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_favedStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_favedStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_favedStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_favedStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Contacts_Contacts struct implement
type Contacts_Contacts struct {
	Constructor int32                  `json:"constructor"`
	Data        Contacts_Contacts_Data `json:"data"`
}

func (st *Contacts_Contacts) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Contacts_Contacts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Contacts_Contacts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Contacts_Contacts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Contacts_Contacts) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Contacts_Contacts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Contacts_Contacts_Data struct implement
type Contacts_Contacts_Data struct {
	Contacts    []Contact `json:"contacts"`
	Saved_count int32     `json:"saved_count"`
	Users       []User    `json:"users"`
}

func (st *Contacts_Contacts_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Contacts_Contacts_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Contacts = make([]Contact, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Contacts[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Saved_count, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Users[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Contacts_Contacts_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Contacts_Contacts_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Contacts_Contacts_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Contacts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Contacts {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Saved_count, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Contacts_Contacts_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_contactsNotModified struct implement
type TLcontacts_contactsNotModified struct {
	Data Contacts_Contacts_Data `json:"data"`
}

func (st *TLcontacts_contactsNotModified) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_contactsNotModified) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_contactsNotModified) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_contactsNotModified, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_contactsNotModified) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_contactsNotModified) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_contacts struct implement
type TLcontacts_contacts struct {
	Data Contacts_Contacts_Data `json:"data"`
}

func (st *TLcontacts_contacts) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_contacts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_contacts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_contacts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_contacts) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_contacts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageRange struct implement
type MessageRange struct {
	Constructor int32             `json:"constructor"`
	Data        MessageRange_Data `json:"data"`
}

func (st *MessageRange) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageRange) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageRange) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageRange, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageRange) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageRange) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageRange_Data struct implement
type MessageRange_Data struct {
	Min_id int32 `json:"min_id"`
	Max_id int32 `json:"max_id"`
}

func (st *MessageRange_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageRange_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Min_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageRange_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageRange_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageRange_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Min_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageRange_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageRange struct implement
type TLmessageRange struct {
	Data MessageRange_Data `json:"data"`
}

func (st *TLmessageRange) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageRange) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageRange) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageRange, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageRange) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageRange) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_InviteText struct implement
type Help_InviteText struct {
	Constructor int32                `json:"constructor"`
	Data        Help_InviteText_Data `json:"data"`
}

func (st *Help_InviteText) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_InviteText) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_InviteText) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_InviteText, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_InviteText) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_InviteText) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Help_InviteText_Data struct implement
type Help_InviteText_Data struct {
	Message string `json:"message"`
}

func (st *Help_InviteText_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Help_InviteText_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Message, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Help_InviteText_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Help_InviteText_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Help_InviteText_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Message, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Help_InviteText_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_inviteText struct implement
type TLhelp_inviteText struct {
	Data Help_InviteText_Data `json:"data"`
}

func (st *TLhelp_inviteText) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_inviteText) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_inviteText) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_inviteText, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_inviteText) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_inviteText) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChatFull struct implement
type ChatFull struct {
	Constructor int32         `json:"constructor"`
	Data        ChatFull_Data `json:"data"`
}

func (st *ChatFull) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChatFull) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChatFull) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChatFull, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChatFull) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChatFull) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChatFull_Data struct implement
type ChatFull_Data struct {
	Can_set_username        bool               `json:"can_set_username"`
	Has_scheduled           bool               `json:"has_scheduled"`
	Id                      int32              `json:"id"`
	About                   string             `json:"about"`
	Participants            ChatParticipants   `json:"participants"`
	Chat_photo              Photo              `json:"chat_photo"`
	Notify_settings         PeerNotifySettings `json:"notify_settings"`
	Exported_invite         ExportedChatInvite `json:"exported_invite"`
	Bot_info                []BotInfo          `json:"bot_info"`
	Pinned_msg_id           int32              `json:"pinned_msg_id"`
	Folder_id               int32              `json:"folder_id"`
	Can_view_participants   bool               `json:"can_view_participants"`
	Can_set_stickers        bool               `json:"can_set_stickers"`
	Hidden_prehistory       bool               `json:"hidden_prehistory"`
	Can_set_location        bool               `json:"can_set_location"`
	Can_view_stats          bool               `json:"can_view_stats"`
	Blocked                 bool               `json:"blocked"`
	Participants_count      int32              `json:"participants_count"`
	Admins_count            int32              `json:"admins_count"`
	Kicked_count            int32              `json:"kicked_count"`
	Banned_count            int32              `json:"banned_count"`
	Online_count            int32              `json:"online_count"`
	Read_inbox_max_id       int32              `json:"read_inbox_max_id"`
	Read_outbox_max_id      int32              `json:"read_outbox_max_id"`
	Unread_count            int32              `json:"unread_count"`
	Migrated_from_chat_id   int32              `json:"migrated_from_chat_id"`
	Migrated_from_max_id    int32              `json:"migrated_from_max_id"`
	Stickerset              StickerSet         `json:"stickerset"`
	Available_min_id        int32              `json:"available_min_id"`
	Linked_chat_id          int32              `json:"linked_chat_id"`
	Location                ChannelLocation    `json:"location"`
	Slowmode_seconds        int32              `json:"slowmode_seconds"`
	Slowmode_next_send_date int32              `json:"slowmode_next_send_date"`
	Stats_dc                int32              `json:"stats_dc"`
	Pts                     int32              `json:"pts"`
}

func (st *ChatFull_Data) ResetDefault() {
	st.Participants.ResetDefault()
	st.Chat_photo.ResetDefault()
	st.Notify_settings.ResetDefault()
	st.Exported_invite.ResetDefault()
	st.Stickerset.ResetDefault()
	st.Location.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChatFull_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Can_set_username, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Has_scheduled, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Id, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.About, 3, false)
	if err != nil {
		return err
	}

	err = st.Participants.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = st.Chat_photo.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = st.Notify_settings.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	err = st.Exported_invite.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Bot_info = make([]BotInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Bot_info[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Pinned_msg_id, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Folder_id, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Can_view_participants, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Can_set_stickers, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Hidden_prehistory, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Can_set_location, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Can_view_stats, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Blocked, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Participants_count, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Admins_count, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Kicked_count, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Banned_count, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Online_count, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Read_inbox_max_id, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Read_outbox_max_id, 23, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Unread_count, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Migrated_from_chat_id, 25, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Migrated_from_max_id, 26, false)
	if err != nil {
		return err
	}

	err = st.Stickerset.ReadBlock(_is, 27, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Available_min_id, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Linked_chat_id, 29, false)
	if err != nil {
		return err
	}

	err = st.Location.ReadBlock(_is, 30, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Slowmode_seconds, 31, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Slowmode_next_send_date, 32, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Stats_dc, 33, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Pts, 34, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChatFull_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChatFull_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChatFull_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Can_set_username, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Has_scheduled, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Id, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.About, 3)
	if err != nil {
		return err
	}

	err = st.Participants.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = st.Chat_photo.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = st.Notify_settings.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	err = st.Exported_invite.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Bot_info)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Bot_info {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Pinned_msg_id, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Folder_id, 10)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Can_view_participants, 11)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Can_set_stickers, 12)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Hidden_prehistory, 13)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Can_set_location, 14)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Can_view_stats, 15)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Blocked, 16)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Participants_count, 17)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Admins_count, 18)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Kicked_count, 19)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Banned_count, 20)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Online_count, 21)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Read_inbox_max_id, 22)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Read_outbox_max_id, 23)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Unread_count, 24)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Migrated_from_chat_id, 25)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Migrated_from_max_id, 26)
	if err != nil {
		return err
	}

	err = st.Stickerset.WriteBlock(_os, 27)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Available_min_id, 28)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Linked_chat_id, 29)
	if err != nil {
		return err
	}

	err = st.Location.WriteBlock(_os, 30)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Slowmode_seconds, 31)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Slowmode_next_send_date, 32)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Stats_dc, 33)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Pts, 34)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChatFull_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchatFull struct implement
type TLchatFull struct {
	Data ChatFull_Data `json:"data"`
}

func (st *TLchatFull) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchatFull) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchatFull) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchatFull, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchatFull) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchatFull) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelFull struct implement
type TLchannelFull struct {
	Data ChatFull_Data `json:"data"`
}

func (st *TLchannelFull) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelFull) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelFull) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelFull, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelFull) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelFull) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureFile struct implement
type SecureFile struct {
	Constructor int32           `json:"constructor"`
	Data        SecureFile_Data `json:"data"`
}

func (st *SecureFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureFile_Data struct implement
type SecureFile_Data struct {
	Id          int64   `json:"id"`
	Access_hash int64   `json:"access_hash"`
	Size        int32   `json:"size"`
	Dc_id       int32   `json:"dc_id"`
	Date        int32   `json:"date"`
	File_hash   []uint8 `json:"file_hash"`
	Secret      []uint8 `json:"secret"`
}

func (st *SecureFile_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureFile_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Size, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Dc_id, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 4, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.File_hash = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.File_hash[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.File_hash, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Secret = make([]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_uint8(&st.Secret[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Secret, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureFile_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureFile_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureFile_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Size, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Dc_id, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.File_hash)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.File_hash {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Secret)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Secret {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureFile_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureFileEmpty struct implement
type TLsecureFileEmpty struct {
	Data SecureFile_Data `json:"data"`
}

func (st *TLsecureFileEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureFileEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureFileEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureFileEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureFileEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureFileEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureFile struct implement
type TLsecureFile struct {
	Data SecureFile_Data `json:"data"`
}

func (st *TLsecureFile) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChannelMessagesFilter struct implement
type ChannelMessagesFilter struct {
	Constructor int32                      `json:"constructor"`
	Data        ChannelMessagesFilter_Data `json:"data"`
}

func (st *ChannelMessagesFilter) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *ChannelMessagesFilter) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChannelMessagesFilter) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChannelMessagesFilter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChannelMessagesFilter) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChannelMessagesFilter) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChannelMessagesFilter_Data struct implement
type ChannelMessagesFilter_Data struct {
	Exclude_new_messages bool           `json:"exclude_new_messages"`
	Ranges               []MessageRange `json:"ranges"`
}

func (st *ChannelMessagesFilter_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *ChannelMessagesFilter_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Exclude_new_messages, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Ranges = make([]MessageRange, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Ranges[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ChannelMessagesFilter_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChannelMessagesFilter_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ChannelMessagesFilter_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Exclude_new_messages, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Ranges)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Ranges {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ChannelMessagesFilter_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelMessagesFilterEmpty struct implement
type TLchannelMessagesFilterEmpty struct {
	Data ChannelMessagesFilter_Data `json:"data"`
}

func (st *TLchannelMessagesFilterEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelMessagesFilterEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelMessagesFilterEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelMessagesFilterEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelMessagesFilterEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelMessagesFilterEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannelMessagesFilter struct implement
type TLchannelMessagesFilter struct {
	Data ChannelMessagesFilter_Data `json:"data"`
}

func (st *TLchannelMessagesFilter) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannelMessagesFilter) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannelMessagesFilter) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannelMessagesFilter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannelMessagesFilter) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannelMessagesFilter) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureValueType struct implement
type SecureValueType struct {
	Constructor int32                `json:"constructor"`
	Data        SecureValueType_Data `json:"data"`
}

func (st *SecureValueType) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureValueType) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureValueType) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureValueType, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureValueType) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureValueType) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureValueType_Data struct implement
type SecureValueType_Data struct {
}

func (st *SecureValueType_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *SecureValueType_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *SecureValueType_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureValueType_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *SecureValueType_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *SecureValueType_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueTypePersonalDetails struct implement
type TLsecureValueTypePersonalDetails struct {
	Data SecureValueType_Data `json:"data"`
}

func (st *TLsecureValueTypePersonalDetails) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueTypePersonalDetails) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueTypePersonalDetails) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueTypePersonalDetails, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueTypePersonalDetails) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueTypePersonalDetails) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueTypePassport struct implement
type TLsecureValueTypePassport struct {
	Data SecureValueType_Data `json:"data"`
}

func (st *TLsecureValueTypePassport) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueTypePassport) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueTypePassport) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueTypePassport, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueTypePassport) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueTypePassport) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueTypeDriverLicense struct implement
type TLsecureValueTypeDriverLicense struct {
	Data SecureValueType_Data `json:"data"`
}

func (st *TLsecureValueTypeDriverLicense) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueTypeDriverLicense) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueTypeDriverLicense) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueTypeDriverLicense, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueTypeDriverLicense) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueTypeDriverLicense) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueTypeIdentityCard struct implement
type TLsecureValueTypeIdentityCard struct {
	Data SecureValueType_Data `json:"data"`
}

func (st *TLsecureValueTypeIdentityCard) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueTypeIdentityCard) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueTypeIdentityCard) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueTypeIdentityCard, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueTypeIdentityCard) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueTypeIdentityCard) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueTypeInternalPassport struct implement
type TLsecureValueTypeInternalPassport struct {
	Data SecureValueType_Data `json:"data"`
}

func (st *TLsecureValueTypeInternalPassport) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueTypeInternalPassport) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueTypeInternalPassport) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueTypeInternalPassport, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueTypeInternalPassport) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueTypeInternalPassport) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueTypeAddress struct implement
type TLsecureValueTypeAddress struct {
	Data SecureValueType_Data `json:"data"`
}

func (st *TLsecureValueTypeAddress) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueTypeAddress) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueTypeAddress) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueTypeAddress, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueTypeAddress) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueTypeAddress) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueTypeUtilityBill struct implement
type TLsecureValueTypeUtilityBill struct {
	Data SecureValueType_Data `json:"data"`
}

func (st *TLsecureValueTypeUtilityBill) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueTypeUtilityBill) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueTypeUtilityBill) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueTypeUtilityBill, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueTypeUtilityBill) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueTypeUtilityBill) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueTypeBankStatement struct implement
type TLsecureValueTypeBankStatement struct {
	Data SecureValueType_Data `json:"data"`
}

func (st *TLsecureValueTypeBankStatement) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueTypeBankStatement) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueTypeBankStatement) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueTypeBankStatement, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueTypeBankStatement) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueTypeBankStatement) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueTypeRentalAgreement struct implement
type TLsecureValueTypeRentalAgreement struct {
	Data SecureValueType_Data `json:"data"`
}

func (st *TLsecureValueTypeRentalAgreement) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueTypeRentalAgreement) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueTypeRentalAgreement) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueTypeRentalAgreement, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueTypeRentalAgreement) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueTypeRentalAgreement) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueTypePassportRegistration struct implement
type TLsecureValueTypePassportRegistration struct {
	Data SecureValueType_Data `json:"data"`
}

func (st *TLsecureValueTypePassportRegistration) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueTypePassportRegistration) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueTypePassportRegistration) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueTypePassportRegistration, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueTypePassportRegistration) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueTypePassportRegistration) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueTypeTemporaryRegistration struct implement
type TLsecureValueTypeTemporaryRegistration struct {
	Data SecureValueType_Data `json:"data"`
}

func (st *TLsecureValueTypeTemporaryRegistration) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueTypeTemporaryRegistration) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueTypeTemporaryRegistration) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueTypeTemporaryRegistration, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueTypeTemporaryRegistration) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueTypeTemporaryRegistration) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueTypePhone struct implement
type TLsecureValueTypePhone struct {
	Data SecureValueType_Data `json:"data"`
}

func (st *TLsecureValueTypePhone) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueTypePhone) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueTypePhone) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueTypePhone, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueTypePhone) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueTypePhone) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLsecureValueTypeEmail struct implement
type TLsecureValueTypeEmail struct {
	Data SecureValueType_Data `json:"data"`
}

func (st *TLsecureValueTypeEmail) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLsecureValueTypeEmail) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLsecureValueTypeEmail) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLsecureValueTypeEmail, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLsecureValueTypeEmail) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLsecureValueTypeEmail) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PeerSettings struct implement
type PeerSettings struct {
	Constructor int32             `json:"constructor"`
	Data        PeerSettings_Data `json:"data"`
}

func (st *PeerSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *PeerSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PeerSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PeerSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PeerSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PeerSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// PeerSettings_Data struct implement
type PeerSettings_Data struct {
	Report_spam             bool  `json:"report_spam"`
	Add_contact             bool  `json:"add_contact"`
	Block_contact           bool  `json:"block_contact"`
	Share_contact           bool  `json:"share_contact"`
	Need_contacts_exception bool  `json:"need_contacts_exception"`
	Report_geo              bool  `json:"report_geo"`
	Autoarchived            bool  `json:"autoarchived"`
	Geo_distance            int32 `json:"geo_distance"`
}

func (st *PeerSettings_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *PeerSettings_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Report_spam, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Add_contact, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Block_contact, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Share_contact, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Need_contacts_exception, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Report_geo, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Autoarchived, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Geo_distance, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *PeerSettings_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PeerSettings_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *PeerSettings_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Report_spam, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Add_contact, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Block_contact, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Share_contact, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Need_contacts_exception, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Report_geo, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Autoarchived, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Geo_distance, 7)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *PeerSettings_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpeerSettings struct implement
type TLpeerSettings struct {
	Data PeerSettings_Data `json:"data"`
}

func (st *TLpeerSettings) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpeerSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpeerSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpeerSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpeerSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpeerSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Contacts_Blocked struct implement
type Contacts_Blocked struct {
	Constructor int32                 `json:"constructor"`
	Data        Contacts_Blocked_Data `json:"data"`
}

func (st *Contacts_Blocked) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Contacts_Blocked) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Contacts_Blocked) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Contacts_Blocked, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Contacts_Blocked) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Contacts_Blocked) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Contacts_Blocked_Data struct implement
type Contacts_Blocked_Data struct {
	Blocked []PeerBlocked `json:"blocked"`
	Chats   []Chat        `json:"chats"`
	Users   []User        `json:"users"`
	Count   int32         `json:"count"`
}

func (st *Contacts_Blocked_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Contacts_Blocked_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Blocked = make([]PeerBlocked, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Blocked[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Chats[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Users[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Count, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Contacts_Blocked_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Contacts_Blocked_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Contacts_Blocked_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Blocked)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Blocked {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Count, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Contacts_Blocked_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_blocked struct implement
type TLcontacts_blocked struct {
	Data Contacts_Blocked_Data `json:"data"`
}

func (st *TLcontacts_blocked) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_blocked) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_blocked) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_blocked, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_blocked) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_blocked) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_blockedSlice struct implement
type TLcontacts_blockedSlice struct {
	Data Contacts_Blocked_Data `json:"data"`
}

func (st *TLcontacts_blockedSlice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_blockedSlice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_blockedSlice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_blockedSlice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_blockedSlice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_blockedSlice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Document struct implement
type Document struct {
	Constructor int32         `json:"constructor"`
	Data        Document_Data `json:"data"`
}

func (st *Document) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Document) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Document) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Document, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Document) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Document) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Document_Data struct implement
type Document_Data struct {
	Id             int64               `json:"id"`
	Access_hash    int64               `json:"access_hash"`
	File_reference []uint8             `json:"file_reference"`
	Date           int32               `json:"date"`
	Mime_type      string              `json:"mime_type"`
	Size           int32               `json:"size"`
	Thumbs         []PhotoSize         `json:"thumbs"`
	Video_thumbs   []VideoSize         `json:"video_thumbs"`
	Dc_id          int32               `json:"dc_id"`
	Attributes     []DocumentAttribute `json:"attributes"`
}

func (st *Document_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *Document_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Access_hash, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.File_reference = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.File_reference[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.File_reference, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Date, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Mime_type, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Size, 5, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Thumbs = make([]PhotoSize, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Thumbs[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Video_thumbs = make([]VideoSize, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Video_thumbs[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Dc_id, 8, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(9, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Attributes = make([]DocumentAttribute, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Attributes[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Document_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Document_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Document_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Access_hash, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.File_reference)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.File_reference {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Date, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Mime_type, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Size, 5)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Thumbs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Thumbs {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Video_thumbs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Video_thumbs {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Dc_id, 8)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Attributes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Attributes {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Document_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdocumentEmpty struct implement
type TLdocumentEmpty struct {
	Data Document_Data `json:"data"`
}

func (st *TLdocumentEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdocumentEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdocumentEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdocumentEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdocumentEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdocumentEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLdocument struct implement
type TLdocument struct {
	Data Document_Data `json:"data"`
}

func (st *TLdocument) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLdocument) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLdocument) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLdocument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLdocument) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLdocument) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Updates struct implement
type Updates struct {
	Constructor int32        `json:"constructor"`
	Data        Updates_Data `json:"data"`
}

func (st *Updates) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Updates) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Updates) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Updates, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Updates) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Updates) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Updates_Data struct implement
type Updates_Data struct {
	Out_key      bool               `json:"out_key"`
	Mentioned    bool               `json:"mentioned"`
	Media_unread bool               `json:"media_unread"`
	Silent       bool               `json:"silent"`
	Id           int32              `json:"id"`
	User_id      int32              `json:"user_id"`
	Message      string             `json:"message"`
	Pts          int32              `json:"pts"`
	Pts_count    int32              `json:"pts_count"`
	Date         int32              `json:"date"`
	Fwd_from     MessageFwdHeader   `json:"fwd_from"`
	Via_bot_id   int32              `json:"via_bot_id"`
	Reply_to     MessageReplyHeader `json:"reply_to"`
	Entities     []MessageEntity    `json:"entities"`
	From_id      int32              `json:"from_id"`
	Chat_id      int32              `json:"chat_id"`
	Update       Update             `json:"update"`
	Updates      []Update           `json:"updates"`
	Users        []User             `json:"users"`
	Chats        []Chat             `json:"chats"`
	Seq_start    int32              `json:"seq_start"`
	Seq          int32              `json:"seq"`
	Media        MessageMedia       `json:"media"`
}

func (st *Updates_Data) ResetDefault() {
	st.Fwd_from.ResetDefault()
	st.Reply_to.ResetDefault()
	st.Update.ResetDefault()
	st.Media.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Updates_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Out_key, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Mentioned, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Media_unread, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Silent, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Id, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.User_id, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Pts, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Pts_count, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 9, false)
	if err != nil {
		return err
	}

	err = st.Fwd_from.ReadBlock(_is, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Via_bot_id, 11, false)
	if err != nil {
		return err
	}

	err = st.Reply_to.ReadBlock(_is, 12, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(13, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.From_id, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Chat_id, 15, false)
	if err != nil {
		return err
	}

	err = st.Update.ReadBlock(_is, 16, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(17, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Updates = make([]Update, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Updates[i1].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(18, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]User, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Users[i2].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(19, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Chats = make([]Chat, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Chats[i3].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Seq_start, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Seq, 21, false)
	if err != nil {
		return err
	}

	err = st.Media.ReadBlock(_is, 22, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Updates_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Updates_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Updates_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Out_key, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Mentioned, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Media_unread, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Silent, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Id, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.User_id, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Pts, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Pts_count, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 9)
	if err != nil {
		return err
	}

	err = st.Fwd_from.WriteBlock(_os, 10)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Via_bot_id, 11)
	if err != nil {
		return err
	}

	err = st.Reply_to.WriteBlock(_os, 12)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.From_id, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Chat_id, 15)
	if err != nil {
		return err
	}

	err = st.Update.WriteBlock(_os, 16)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 17)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Updates)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Updates {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 18)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 19)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Chats)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Chats {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Seq_start, 20)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Seq, 21)
	if err != nil {
		return err
	}

	err = st.Media.WriteBlock(_os, 22)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Updates_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdatesTooLong struct implement
type TLupdatesTooLong struct {
	Data Updates_Data `json:"data"`
}

func (st *TLupdatesTooLong) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdatesTooLong) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdatesTooLong) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdatesTooLong, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdatesTooLong) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdatesTooLong) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateShortMessage struct implement
type TLupdateShortMessage struct {
	Data Updates_Data `json:"data"`
}

func (st *TLupdateShortMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateShortMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateShortMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateShortMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateShortMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateShortMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateShortChatMessage struct implement
type TLupdateShortChatMessage struct {
	Data Updates_Data `json:"data"`
}

func (st *TLupdateShortChatMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateShortChatMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateShortChatMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateShortChatMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateShortChatMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateShortChatMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateShort struct implement
type TLupdateShort struct {
	Data Updates_Data `json:"data"`
}

func (st *TLupdateShort) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateShort) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateShort) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateShort, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateShort) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateShort) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdatesCombined struct implement
type TLupdatesCombined struct {
	Data Updates_Data `json:"data"`
}

func (st *TLupdatesCombined) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdatesCombined) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdatesCombined) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdatesCombined, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdatesCombined) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdatesCombined) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdates struct implement
type TLupdates struct {
	Data Updates_Data `json:"data"`
}

func (st *TLupdates) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdates) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdates) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdates, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdates) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdates) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdateShortSentMessage struct implement
type TLupdateShortSentMessage struct {
	Data Updates_Data `json:"data"`
}

func (st *TLupdateShortSentMessage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdateShortSentMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdateShortSentMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdateShortSentMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdateShortSentMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdateShortSentMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Config struct implement
type Config struct {
	Constructor int32       `json:"constructor"`
	Data        Config_Data `json:"data"`
}

func (st *Config) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Config) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Config) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Config, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Config) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Config) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// Config_Data struct implement
type Config_Data struct {
	Phonecalls_enabled         bool       `json:"phonecalls_enabled"`
	Default_p2p_contacts       bool       `json:"default_p2p_contacts"`
	Preload_featured_stickers  bool       `json:"preload_featured_stickers"`
	Ignore_phone_entities      bool       `json:"ignore_phone_entities"`
	Revoke_pm_inbox            bool       `json:"revoke_pm_inbox"`
	Blocked_mode               bool       `json:"blocked_mode"`
	Pfs_enabled                bool       `json:"pfs_enabled"`
	Date                       int32      `json:"date"`
	Expires                    int32      `json:"expires"`
	Test_mode                  Bool       `json:"test_mode"`
	This_dc                    int32      `json:"this_dc"`
	Dc_options                 []DcOption `json:"dc_options"`
	Dc_txt_domain_name         string     `json:"dc_txt_domain_name"`
	Chat_size_max              int32      `json:"chat_size_max"`
	Megagroup_size_max         int32      `json:"megagroup_size_max"`
	Forwarded_count_max        int32      `json:"forwarded_count_max"`
	Online_update_period_ms    int32      `json:"online_update_period_ms"`
	Offline_blur_timeout_ms    int32      `json:"offline_blur_timeout_ms"`
	Offline_idle_timeout_ms    int32      `json:"offline_idle_timeout_ms"`
	Online_cloud_timeout_ms    int32      `json:"online_cloud_timeout_ms"`
	Notify_cloud_delay_ms      int32      `json:"notify_cloud_delay_ms"`
	Notify_default_delay_ms    int32      `json:"notify_default_delay_ms"`
	Push_chat_period_ms        int32      `json:"push_chat_period_ms"`
	Push_chat_limit            int32      `json:"push_chat_limit"`
	Saved_gifs_limit           int32      `json:"saved_gifs_limit"`
	Edit_time_limit            int32      `json:"edit_time_limit"`
	Revoke_time_limit          int32      `json:"revoke_time_limit"`
	Revoke_pm_time_limit       int32      `json:"revoke_pm_time_limit"`
	Rating_e_decay             int32      `json:"rating_e_decay"`
	Stickers_recent_limit      int32      `json:"stickers_recent_limit"`
	Stickers_faved_limit       int32      `json:"stickers_faved_limit"`
	Channels_read_media_period int32      `json:"channels_read_media_period"`
	Tmp_sessions               int32      `json:"tmp_sessions"`
	Pinned_dialogs_count_max   int32      `json:"pinned_dialogs_count_max"`
	Pinned_infolder_count_max  int32      `json:"pinned_infolder_count_max"`
	Call_receive_timeout_ms    int32      `json:"call_receive_timeout_ms"`
	Call_ring_timeout_ms       int32      `json:"call_ring_timeout_ms"`
	Call_connect_timeout_ms    int32      `json:"call_connect_timeout_ms"`
	Call_packet_timeout_ms     int32      `json:"call_packet_timeout_ms"`
	Me_url_prefix              string     `json:"me_url_prefix"`
	Autoupdate_url_prefix      string     `json:"autoupdate_url_prefix"`
	Gif_search_username        string     `json:"gif_search_username"`
	Venue_search_username      string     `json:"venue_search_username"`
	Img_search_username        string     `json:"img_search_username"`
	Static_maps_provider       string     `json:"static_maps_provider"`
	Caption_length_max         int32      `json:"caption_length_max"`
	Message_length_max         int32      `json:"message_length_max"`
	Webfile_dc_id              int32      `json:"webfile_dc_id"`
	Suggested_lang_code        string     `json:"suggested_lang_code"`
	Lang_pack_version          int32      `json:"lang_pack_version"`
	Base_lang_pack_version     int32      `json:"base_lang_pack_version"`
}

func (st *Config_Data) ResetDefault() {
	st.Test_mode.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *Config_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Phonecalls_enabled, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Default_p2p_contacts, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Preload_featured_stickers, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Ignore_phone_entities, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Revoke_pm_inbox, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Blocked_mode, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Pfs_enabled, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Expires, 8, false)
	if err != nil {
		return err
	}

	err = st.Test_mode.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.This_dc, 10, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(11, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Dc_options = make([]DcOption, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Dc_options[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Dc_txt_domain_name, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Chat_size_max, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Megagroup_size_max, 14, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Forwarded_count_max, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Online_update_period_ms, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offline_blur_timeout_ms, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offline_idle_timeout_ms, 18, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Online_cloud_timeout_ms, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Notify_cloud_delay_ms, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Notify_default_delay_ms, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Push_chat_period_ms, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Push_chat_limit, 23, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Saved_gifs_limit, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Edit_time_limit, 25, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Revoke_time_limit, 26, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Revoke_pm_time_limit, 27, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Rating_e_decay, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Stickers_recent_limit, 29, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Stickers_faved_limit, 30, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Channels_read_media_period, 31, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Tmp_sessions, 32, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Pinned_dialogs_count_max, 33, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Pinned_infolder_count_max, 34, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Call_receive_timeout_ms, 35, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Call_ring_timeout_ms, 36, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Call_connect_timeout_ms, 37, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Call_packet_timeout_ms, 38, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Me_url_prefix, 39, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Autoupdate_url_prefix, 40, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Gif_search_username, 41, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Venue_search_username, 42, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Img_search_username, 43, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Static_maps_provider, 44, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Caption_length_max, 45, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Message_length_max, 46, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Webfile_dc_id, 47, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Suggested_lang_code, 48, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Lang_pack_version, 49, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Base_lang_pack_version, 50, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *Config_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Config_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *Config_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Phonecalls_enabled, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Default_p2p_contacts, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Preload_featured_stickers, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Ignore_phone_entities, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Revoke_pm_inbox, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Blocked_mode, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Pfs_enabled, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Expires, 8)
	if err != nil {
		return err
	}

	err = st.Test_mode.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.This_dc, 10)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Dc_options)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Dc_options {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Dc_txt_domain_name, 12)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Chat_size_max, 13)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Megagroup_size_max, 14)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Forwarded_count_max, 15)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Online_update_period_ms, 16)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offline_blur_timeout_ms, 17)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offline_idle_timeout_ms, 18)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Online_cloud_timeout_ms, 19)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Notify_cloud_delay_ms, 20)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Notify_default_delay_ms, 21)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Push_chat_period_ms, 22)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Push_chat_limit, 23)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Saved_gifs_limit, 24)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Edit_time_limit, 25)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Revoke_time_limit, 26)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Revoke_pm_time_limit, 27)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Rating_e_decay, 28)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Stickers_recent_limit, 29)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Stickers_faved_limit, 30)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Channels_read_media_period, 31)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Tmp_sessions, 32)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Pinned_dialogs_count_max, 33)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Pinned_infolder_count_max, 34)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Call_receive_timeout_ms, 35)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Call_ring_timeout_ms, 36)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Call_connect_timeout_ms, 37)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Call_packet_timeout_ms, 38)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Me_url_prefix, 39)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Autoupdate_url_prefix, 40)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Gif_search_username, 41)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Venue_search_username, 42)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Img_search_username, 43)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Static_maps_provider, 44)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Caption_length_max, 45)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Message_length_max, 46)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Webfile_dc_id, 47)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Suggested_lang_code, 48)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Lang_pack_version, 49)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Base_lang_pack_version, 50)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *Config_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLconfig struct implement
type TLconfig struct {
	Data Config_Data `json:"data"`
}

func (st *TLconfig) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLconfig) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLconfig) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLconfig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLconfig) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLconfig) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageMedia struct implement
type MessageMedia struct {
	Constructor int32             `json:"constructor"`
	Data        MessageMedia_Data `json:"data"`
}

func (st *MessageMedia) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageMedia) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageMedia) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageMedia, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageMedia) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageMedia) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// MessageMedia_Data struct implement
type MessageMedia_Data struct {
	Photo                         Photo       `json:"photo"`
	Ttl_seconds                   int32       `json:"ttl_seconds"`
	Geo                           GeoPoint    `json:"geo"`
	Phone_number                  string      `json:"phone_number"`
	First_name                    string      `json:"first_name"`
	Last_name                     string      `json:"last_name"`
	Vcard                         string      `json:"vcard"`
	User_id                       int32       `json:"user_id"`
	Document                      Document    `json:"document"`
	Webpage                       WebPage     `json:"webpage"`
	Title                         string      `json:"title"`
	Address                       string      `json:"address"`
	Provider                      string      `json:"provider"`
	Venue_id                      string      `json:"venue_id"`
	Venue_type                    string      `json:"venue_type"`
	Game                          Game        `json:"game"`
	Shipping_address_requested    bool        `json:"shipping_address_requested"`
	Test                          bool        `json:"test"`
	Description                   string      `json:"description"`
	Photo_20                      WebDocument `json:"photo_20"`
	Receipt_msg_id                int32       `json:"receipt_msg_id"`
	Currency                      string      `json:"currency"`
	Total_amount                  int64       `json:"total_amount"`
	Start_param                   string      `json:"start_param"`
	Heading                       int32       `json:"heading"`
	Period                        int32       `json:"period"`
	Proximity_notification_radius int32       `json:"proximity_notification_radius"`
	Poll                          Poll        `json:"poll"`
	Results                       PollResults `json:"results"`
	Value                         int32       `json:"value"`
	Emoticon                      string      `json:"emoticon"`
}

func (st *MessageMedia_Data) ResetDefault() {
	st.Photo.ResetDefault()
	st.Geo.ResetDefault()
	st.Document.ResetDefault()
	st.Webpage.ResetDefault()
	st.Game.ResetDefault()
	st.Photo_20.ResetDefault()
	st.Poll.ResetDefault()
	st.Results.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *MessageMedia_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Photo.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Ttl_seconds, 1, false)
	if err != nil {
		return err
	}

	err = st.Geo.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone_number, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.First_name, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Last_name, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Vcard, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.User_id, 7, false)
	if err != nil {
		return err
	}

	err = st.Document.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err = st.Webpage.ReadBlock(_is, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Address, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Provider, 12, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Venue_id, 13, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Venue_type, 14, false)
	if err != nil {
		return err
	}

	err = st.Game.ReadBlock(_is, 15, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Shipping_address_requested, 16, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Test, 17, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Description, 18, false)
	if err != nil {
		return err
	}

	err = st.Photo_20.ReadBlock(_is, 19, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Receipt_msg_id, 20, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Currency, 21, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Total_amount, 22, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Start_param, 23, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Heading, 24, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Period, 25, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Proximity_notification_radius, 26, false)
	if err != nil {
		return err
	}

	err = st.Poll.ReadBlock(_is, 27, false)
	if err != nil {
		return err
	}

	err = st.Results.ReadBlock(_is, 28, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Value, 29, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Emoticon, 30, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *MessageMedia_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MessageMedia_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *MessageMedia_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Photo.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Ttl_seconds, 1)
	if err != nil {
		return err
	}

	err = st.Geo.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone_number, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.First_name, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Last_name, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Vcard, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.User_id, 7)
	if err != nil {
		return err
	}

	err = st.Document.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = st.Webpage.WriteBlock(_os, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 10)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Address, 11)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Provider, 12)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Venue_id, 13)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Venue_type, 14)
	if err != nil {
		return err
	}

	err = st.Game.WriteBlock(_os, 15)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Shipping_address_requested, 16)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Test, 17)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Description, 18)
	if err != nil {
		return err
	}

	err = st.Photo_20.WriteBlock(_os, 19)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Receipt_msg_id, 20)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Currency, 21)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Total_amount, 22)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Start_param, 23)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Heading, 24)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Period, 25)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Proximity_notification_radius, 26)
	if err != nil {
		return err
	}

	err = st.Poll.WriteBlock(_os, 27)
	if err != nil {
		return err
	}

	err = st.Results.WriteBlock(_os, 28)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Value, 29)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Emoticon, 30)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *MessageMedia_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageMediaEmpty struct implement
type TLmessageMediaEmpty struct {
	Data MessageMedia_Data `json:"data"`
}

func (st *TLmessageMediaEmpty) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageMediaEmpty) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageMediaEmpty) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageMediaEmpty, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageMediaEmpty) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageMediaEmpty) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageMediaPhoto struct implement
type TLmessageMediaPhoto struct {
	Data MessageMedia_Data `json:"data"`
}

func (st *TLmessageMediaPhoto) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageMediaPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageMediaPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageMediaPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageMediaPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageMediaPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageMediaGeo struct implement
type TLmessageMediaGeo struct {
	Data MessageMedia_Data `json:"data"`
}

func (st *TLmessageMediaGeo) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageMediaGeo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageMediaGeo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageMediaGeo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageMediaGeo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageMediaGeo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageMediaContact struct implement
type TLmessageMediaContact struct {
	Data MessageMedia_Data `json:"data"`
}

func (st *TLmessageMediaContact) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageMediaContact) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageMediaContact) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageMediaContact, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageMediaContact) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageMediaContact) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageMediaUnsupported struct implement
type TLmessageMediaUnsupported struct {
	Data MessageMedia_Data `json:"data"`
}

func (st *TLmessageMediaUnsupported) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageMediaUnsupported) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageMediaUnsupported) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageMediaUnsupported, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageMediaUnsupported) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageMediaUnsupported) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageMediaDocument struct implement
type TLmessageMediaDocument struct {
	Data MessageMedia_Data `json:"data"`
}

func (st *TLmessageMediaDocument) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageMediaDocument) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageMediaDocument) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageMediaDocument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageMediaDocument) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageMediaDocument) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageMediaWebPage struct implement
type TLmessageMediaWebPage struct {
	Data MessageMedia_Data `json:"data"`
}

func (st *TLmessageMediaWebPage) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageMediaWebPage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageMediaWebPage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageMediaWebPage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageMediaWebPage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageMediaWebPage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageMediaVenue struct implement
type TLmessageMediaVenue struct {
	Data MessageMedia_Data `json:"data"`
}

func (st *TLmessageMediaVenue) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageMediaVenue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageMediaVenue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageMediaVenue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageMediaVenue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageMediaVenue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageMediaGame struct implement
type TLmessageMediaGame struct {
	Data MessageMedia_Data `json:"data"`
}

func (st *TLmessageMediaGame) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageMediaGame) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageMediaGame) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageMediaGame, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageMediaGame) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageMediaGame) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageMediaInvoice struct implement
type TLmessageMediaInvoice struct {
	Data MessageMedia_Data `json:"data"`
}

func (st *TLmessageMediaInvoice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageMediaInvoice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageMediaInvoice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageMediaInvoice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageMediaInvoice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageMediaInvoice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageMediaGeoLive struct implement
type TLmessageMediaGeoLive struct {
	Data MessageMedia_Data `json:"data"`
}

func (st *TLmessageMediaGeoLive) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageMediaGeoLive) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageMediaGeoLive) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageMediaGeoLive, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageMediaGeoLive) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageMediaGeoLive) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageMediaPoll struct implement
type TLmessageMediaPoll struct {
	Data MessageMedia_Data `json:"data"`
}

func (st *TLmessageMediaPoll) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageMediaPoll) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageMediaPoll) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageMediaPoll, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageMediaPoll) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageMediaPoll) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessageMediaDice struct implement
type TLmessageMediaDice struct {
	Data MessageMedia_Data `json:"data"`
}

func (st *TLmessageMediaDice) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessageMediaDice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessageMediaDice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessageMediaDice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessageMediaDice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessageMediaDice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// BaseTheme struct implement
type BaseTheme struct {
	Constructor int32          `json:"constructor"`
	Data        BaseTheme_Data `json:"data"`
}

func (st *BaseTheme) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *BaseTheme) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *BaseTheme) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BaseTheme, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *BaseTheme) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *BaseTheme) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// BaseTheme_Data struct implement
type BaseTheme_Data struct {
}

func (st *BaseTheme_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *BaseTheme_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *BaseTheme_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BaseTheme_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *BaseTheme_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *BaseTheme_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbaseThemeClassic struct implement
type TLbaseThemeClassic struct {
	Data BaseTheme_Data `json:"data"`
}

func (st *TLbaseThemeClassic) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbaseThemeClassic) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbaseThemeClassic) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbaseThemeClassic, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbaseThemeClassic) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbaseThemeClassic) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbaseThemeDay struct implement
type TLbaseThemeDay struct {
	Data BaseTheme_Data `json:"data"`
}

func (st *TLbaseThemeDay) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbaseThemeDay) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbaseThemeDay) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbaseThemeDay, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbaseThemeDay) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbaseThemeDay) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbaseThemeNight struct implement
type TLbaseThemeNight struct {
	Data BaseTheme_Data `json:"data"`
}

func (st *TLbaseThemeNight) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbaseThemeNight) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbaseThemeNight) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbaseThemeNight, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbaseThemeNight) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbaseThemeNight) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbaseThemeTinted struct implement
type TLbaseThemeTinted struct {
	Data BaseTheme_Data `json:"data"`
}

func (st *TLbaseThemeTinted) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbaseThemeTinted) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbaseThemeTinted) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbaseThemeTinted, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbaseThemeTinted) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbaseThemeTinted) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbaseThemeArctic struct implement
type TLbaseThemeArctic struct {
	Data BaseTheme_Data `json:"data"`
}

func (st *TLbaseThemeArctic) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbaseThemeArctic) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbaseThemeArctic) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbaseThemeArctic, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbaseThemeArctic) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbaseThemeArctic) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StatsGroupTopInviter struct implement
type StatsGroupTopInviter struct {
	Constructor int32                     `json:"constructor"`
	Data        StatsGroupTopInviter_Data `json:"data"`
}

func (st *StatsGroupTopInviter) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *StatsGroupTopInviter) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Constructor, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StatsGroupTopInviter) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StatsGroupTopInviter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StatsGroupTopInviter) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Constructor, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StatsGroupTopInviter) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// StatsGroupTopInviter_Data struct implement
type StatsGroupTopInviter_Data struct {
	User_id     int32 `json:"user_id"`
	Invitations int32 `json:"invitations"`
}

func (st *StatsGroupTopInviter_Data) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *StatsGroupTopInviter_Data) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Invitations, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *StatsGroupTopInviter_Data) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StatsGroupTopInviter_Data, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *StatsGroupTopInviter_Data) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.User_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Invitations, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *StatsGroupTopInviter_Data) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstatsGroupTopInviter struct implement
type TLstatsGroupTopInviter struct {
	Data StatsGroupTopInviter_Data `json:"data"`
}

func (st *TLstatsGroupTopInviter) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstatsGroupTopInviter) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Data.ReadBlock(_is, 0, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstatsGroupTopInviter) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstatsGroupTopInviter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstatsGroupTopInviter) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Data.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstatsGroupTopInviter) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_getParticipant struct implement
type TLchannels_getParticipant struct {
	Channel InputChannel `json:"channel"`
	User_id InputUser    `json:"user_id"`
}

func (st *TLchannels_getParticipant) ResetDefault() {
	st.Channel.ResetDefault()
	st.User_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_getParticipant) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.User_id.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_getParticipant) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_getParticipant, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_getParticipant) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.User_id.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_getParticipant) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getPeerDialogs struct implement
type TLmessages_getPeerDialogs struct {
	Peers []InputDialogPeer `json:"peers"`
}

func (st *TLmessages_getPeerDialogs) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getPeerDialogs) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Peers = make([]InputDialogPeer, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Peers[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getPeerDialogs) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getPeerDialogs, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getPeerDialogs) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Peers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Peers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getPeerDialogs) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getPinnedDialogs struct implement
type TLmessages_getPinnedDialogs struct {
	Folder_id int32 `json:"folder_id"`
}

func (st *TLmessages_getPinnedDialogs) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getPinnedDialogs) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Folder_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getPinnedDialogs) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getPinnedDialogs, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getPinnedDialogs) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Folder_id, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getPinnedDialogs) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_readHistory struct implement
type TLmessages_readHistory struct {
	Peer   InputPeer `json:"peer"`
	Max_id int32     `json:"max_id"`
}

func (st *TLmessages_readHistory) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_readHistory) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_readHistory) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_readHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_readHistory) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_readHistory) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_deleteMessages struct implement
type TLmessages_deleteMessages struct {
	Revoke bool    `json:"revoke"`
	Id     []int32 `json:"id"`
}

func (st *TLmessages_deleteMessages) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_deleteMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Revoke, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_deleteMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_deleteMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_deleteMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Revoke, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_deleteMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_readMessageContents struct implement
type TLmessages_readMessageContents struct {
	Id []int32 `json:"id"`
}

func (st *TLmessages_readMessageContents) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_readMessageContents) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_readMessageContents) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_readMessageContents, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_readMessageContents) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_readMessageContents) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_deleteMessages struct implement
type TLchannels_deleteMessages struct {
	Channel InputChannel `json:"channel"`
	Id      []int32      `json:"id"`
}

func (st *TLchannels_deleteMessages) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_deleteMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_deleteMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_deleteMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_deleteMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_deleteMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getAllStickers struct implement
type TLmessages_getAllStickers struct {
	Hash int32 `json:"hash"`
}

func (st *TLmessages_getAllStickers) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getAllStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getAllStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getAllStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getAllStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getAllStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getMaskStickers struct implement
type TLmessages_getMaskStickers struct {
	Hash int32 `json:"hash"`
}

func (st *TLmessages_getMaskStickers) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getMaskStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getMaskStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getMaskStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getMaskStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getMaskStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getSuggestedDialogFilters struct implement
type TLmessages_getSuggestedDialogFilters struct {
}

func (st *TLmessages_getSuggestedDialogFilters) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getSuggestedDialogFilters) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getSuggestedDialogFilters) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getSuggestedDialogFilters, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getSuggestedDialogFilters) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getSuggestedDialogFilters) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_updateProfile struct implement
type TLaccount_updateProfile struct {
	First_name string `json:"first_name"`
	Last_name  string `json:"last_name"`
	About      string `json:"about"`
}

func (st *TLaccount_updateProfile) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_updateProfile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.First_name, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Last_name, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.About, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_updateProfile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_updateProfile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_updateProfile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.First_name, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Last_name, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.About, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_updateProfile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_updateUsername struct implement
type TLaccount_updateUsername struct {
	Username string `json:"username"`
}

func (st *TLaccount_updateUsername) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_updateUsername) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Username, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_updateUsername) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_updateUsername, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_updateUsername) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Username, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_updateUsername) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_changePhone struct implement
type TLaccount_changePhone struct {
	Phone_number    string `json:"phone_number"`
	Phone_code_hash string `json:"phone_code_hash"`
	Phone_code      string `json:"phone_code"`
}

func (st *TLaccount_changePhone) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_changePhone) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Phone_number, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone_code_hash, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone_code, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_changePhone) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_changePhone, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_changePhone) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Phone_number, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone_code_hash, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone_code, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_changePhone) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_getSupport struct implement
type TLhelp_getSupport struct {
}

func (st *TLhelp_getSupport) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_getSupport) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_getSupport) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_getSupport, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_getSupport) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_getSupport) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getDialogs struct implement
type TLmessages_getDialogs struct {
	Exclude_pinned bool      `json:"exclude_pinned"`
	Folder_id      int32     `json:"folder_id"`
	Offset_date    int32     `json:"offset_date"`
	Offset_id      int32     `json:"offset_id"`
	Offset_peer    InputPeer `json:"offset_peer"`
	Limit          int32     `json:"limit"`
	Hash           int32     `json:"hash"`
}

func (st *TLmessages_getDialogs) ResetDefault() {
	st.Offset_peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getDialogs) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Exclude_pinned, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Folder_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset_date, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset_id, 3, false)
	if err != nil {
		return err
	}

	err = st.Offset_peer.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getDialogs) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getDialogs, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getDialogs) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Exclude_pinned, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Folder_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset_date, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset_id, 3)
	if err != nil {
		return err
	}

	err = st.Offset_peer.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 6)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getDialogs) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_exportMessageLink struct implement
type TLchannels_exportMessageLink struct {
	Grouped bool         `json:"grouped"`
	Thread  bool         `json:"thread"`
	Channel InputChannel `json:"channel"`
	Id      int32        `json:"id"`
}

func (st *TLchannels_exportMessageLink) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_exportMessageLink) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Grouped, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Thread, 1, false)
	if err != nil {
		return err
	}

	err = st.Channel.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Id, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_exportMessageLink) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_exportMessageLink, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_exportMessageLink) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Grouped, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Thread, 1)
	if err != nil {
		return err
	}

	err = st.Channel.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Id, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_exportMessageLink) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstats_loadAsyncGraph struct implement
type TLstats_loadAsyncGraph struct {
	Token string `json:"token"`
	X     int64  `json:"x"`
}

func (st *TLstats_loadAsyncGraph) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstats_loadAsyncGraph) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Token, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.X, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstats_loadAsyncGraph) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstats_loadAsyncGraph, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstats_loadAsyncGraph) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Token, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.X, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstats_loadAsyncGraph) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_getAppConfig struct implement
type TLhelp_getAppConfig struct {
}

func (st *TLhelp_getAppConfig) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_getAppConfig) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_getAppConfig) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_getAppConfig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_getAppConfig) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_getAppConfig) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getAccountTTL struct implement
type TLaccount_getAccountTTL struct {
}

func (st *TLaccount_getAccountTTL) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getAccountTTL) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getAccountTTL) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getAccountTTL, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getAccountTTL) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getAccountTTL) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_exportLoginToken struct implement
type TLauth_exportLoginToken struct {
	Api_id     int32   `json:"api_id"`
	Api_hash   string  `json:"api_hash"`
	Except_ids []int32 `json:"except_ids"`
}

func (st *TLauth_exportLoginToken) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_exportLoginToken) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Api_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Api_hash, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Except_ids = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Except_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_exportLoginToken) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_exportLoginToken, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_exportLoginToken) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Api_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Api_hash, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Except_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Except_ids {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_exportLoginToken) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_importLoginToken struct implement
type TLauth_importLoginToken struct {
	Token []uint8 `json:"token"`
}

func (st *TLauth_importLoginToken) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_importLoginToken) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Token = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Token[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Token, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_importLoginToken) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_importLoginToken, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_importLoginToken) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Token)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Token {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_importLoginToken) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_deleteContacts struct implement
type TLcontacts_deleteContacts struct {
	Id []InputUser `json:"id"`
}

func (st *TLcontacts_deleteContacts) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_deleteContacts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]InputUser, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Id[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_deleteContacts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_deleteContacts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_deleteContacts) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_deleteContacts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_sendMessage struct implement
type TLmessages_sendMessage struct {
	No_webpage      bool            `json:"no_webpage"`
	Silent          bool            `json:"silent"`
	Background      bool            `json:"background"`
	Clear_draft     bool            `json:"clear_draft"`
	Peer            InputPeer       `json:"peer"`
	Reply_to_msg_id int32           `json:"reply_to_msg_id"`
	Message         string          `json:"message"`
	Random_id       int64           `json:"random_id"`
	Reply_markup    ReplyMarkup     `json:"reply_markup"`
	Entities        []MessageEntity `json:"entities"`
	Schedule_date   int32           `json:"schedule_date"`
}

func (st *TLmessages_sendMessage) ResetDefault() {
	st.Peer.ResetDefault()
	st.Reply_markup.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_sendMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.No_webpage, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Silent, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Background, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Clear_draft, 3, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Reply_to_msg_id, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Random_id, 7, false)
	if err != nil {
		return err
	}

	err = st.Reply_markup.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(9, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Schedule_date, 10, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_sendMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_sendMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_sendMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.No_webpage, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Silent, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Background, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Clear_draft, 3)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Reply_to_msg_id, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Random_id, 7)
	if err != nil {
		return err
	}

	err = st.Reply_markup.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Schedule_date, 10)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_sendMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_sendMedia struct implement
type TLmessages_sendMedia struct {
	Silent          bool            `json:"silent"`
	Background      bool            `json:"background"`
	Clear_draft     bool            `json:"clear_draft"`
	Peer            InputPeer       `json:"peer"`
	Reply_to_msg_id int32           `json:"reply_to_msg_id"`
	Media           InputMedia      `json:"media"`
	Message         string          `json:"message"`
	Random_id       int64           `json:"random_id"`
	Reply_markup    ReplyMarkup     `json:"reply_markup"`
	Entities        []MessageEntity `json:"entities"`
	Schedule_date   int32           `json:"schedule_date"`
}

func (st *TLmessages_sendMedia) ResetDefault() {
	st.Peer.ResetDefault()
	st.Media.ResetDefault()
	st.Reply_markup.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_sendMedia) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Silent, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Background, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Clear_draft, 2, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Reply_to_msg_id, 4, false)
	if err != nil {
		return err
	}

	err = st.Media.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Random_id, 7, false)
	if err != nil {
		return err
	}

	err = st.Reply_markup.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(9, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Schedule_date, 10, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_sendMedia) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_sendMedia, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_sendMedia) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Silent, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Background, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Clear_draft, 2)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Reply_to_msg_id, 4)
	if err != nil {
		return err
	}

	err = st.Media.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Random_id, 7)
	if err != nil {
		return err
	}

	err = st.Reply_markup.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Schedule_date, 10)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_sendMedia) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_forwardMessages struct implement
type TLmessages_forwardMessages struct {
	Silent        bool      `json:"silent"`
	Background    bool      `json:"background"`
	With_my_score bool      `json:"with_my_score"`
	From_peer     InputPeer `json:"from_peer"`
	Id            []int32   `json:"id"`
	Random_id     []int64   `json:"random_id"`
	To_peer       InputPeer `json:"to_peer"`
	Schedule_date int32     `json:"schedule_date"`
}

func (st *TLmessages_forwardMessages) ResetDefault() {
	st.From_peer.ResetDefault()
	st.To_peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_forwardMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Silent, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Background, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.With_my_score, 2, false)
	if err != nil {
		return err
	}

	err = st.From_peer.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Random_id = make([]int64, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int64(&st.Random_id[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.To_peer.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Schedule_date, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_forwardMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_forwardMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_forwardMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Silent, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Background, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.With_my_score, 2)
	if err != nil {
		return err
	}

	err = st.From_peer.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Random_id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Random_id {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return err
		}

	}

	err = st.To_peer.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Schedule_date, 7)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_forwardMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_editChatTitle struct implement
type TLmessages_editChatTitle struct {
	Chat_id int32  `json:"chat_id"`
	Title   string `json:"title"`
}

func (st *TLmessages_editChatTitle) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_editChatTitle) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Chat_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_editChatTitle) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_editChatTitle, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_editChatTitle) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Chat_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_editChatTitle) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_editChatPhoto struct implement
type TLmessages_editChatPhoto struct {
	Chat_id int32          `json:"chat_id"`
	Photo   InputChatPhoto `json:"photo"`
}

func (st *TLmessages_editChatPhoto) ResetDefault() {
	st.Photo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_editChatPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Chat_id, 0, false)
	if err != nil {
		return err
	}

	err = st.Photo.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_editChatPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_editChatPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_editChatPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Chat_id, 0)
	if err != nil {
		return err
	}

	err = st.Photo.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_editChatPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_addChatUser struct implement
type TLmessages_addChatUser struct {
	Chat_id   int32     `json:"chat_id"`
	User_id   InputUser `json:"user_id"`
	Fwd_limit int32     `json:"fwd_limit"`
}

func (st *TLmessages_addChatUser) ResetDefault() {
	st.User_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_addChatUser) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Chat_id, 0, false)
	if err != nil {
		return err
	}

	err = st.User_id.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Fwd_limit, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_addChatUser) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_addChatUser, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_addChatUser) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Chat_id, 0)
	if err != nil {
		return err
	}

	err = st.User_id.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Fwd_limit, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_addChatUser) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_deleteChatUser struct implement
type TLmessages_deleteChatUser struct {
	Chat_id int32     `json:"chat_id"`
	User_id InputUser `json:"user_id"`
}

func (st *TLmessages_deleteChatUser) ResetDefault() {
	st.User_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_deleteChatUser) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Chat_id, 0, false)
	if err != nil {
		return err
	}

	err = st.User_id.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_deleteChatUser) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_deleteChatUser, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_deleteChatUser) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Chat_id, 0)
	if err != nil {
		return err
	}

	err = st.User_id.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_deleteChatUser) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_createChat struct implement
type TLmessages_createChat struct {
	Users []InputUser `json:"users"`
	Title string      `json:"title"`
}

func (st *TLmessages_createChat) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_createChat) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]InputUser, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Users[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Title, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_createChat) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_createChat, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_createChat) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Title, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_createChat) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_importChatInvite struct implement
type TLmessages_importChatInvite struct {
	Hash string `json:"hash"`
}

func (st *TLmessages_importChatInvite) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_importChatInvite) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_importChatInvite) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_importChatInvite, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_importChatInvite) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Hash, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_importChatInvite) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_startBot struct implement
type TLmessages_startBot struct {
	Bot         InputUser `json:"bot"`
	Peer        InputPeer `json:"peer"`
	Random_id   int64     `json:"random_id"`
	Start_param string    `json:"start_param"`
}

func (st *TLmessages_startBot) ResetDefault() {
	st.Bot.ResetDefault()
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_startBot) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Bot.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Random_id, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Start_param, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_startBot) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_startBot, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_startBot) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Bot.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Random_id, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Start_param, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_startBot) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_getAppChangelog struct implement
type TLhelp_getAppChangelog struct {
	Prev_app_version string `json:"prev_app_version"`
}

func (st *TLhelp_getAppChangelog) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_getAppChangelog) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Prev_app_version, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_getAppChangelog) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_getAppChangelog, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_getAppChangelog) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Prev_app_version, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_getAppChangelog) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_createChannel struct implement
type TLchannels_createChannel struct {
	Broadcast bool          `json:"broadcast"`
	Megagroup bool          `json:"megagroup"`
	Title     string        `json:"title"`
	About     string        `json:"about"`
	Geo_point InputGeoPoint `json:"geo_point"`
	Address   string        `json:"address"`
}

func (st *TLchannels_createChannel) ResetDefault() {
	st.Geo_point.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_createChannel) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Broadcast, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Megagroup, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.About, 3, false)
	if err != nil {
		return err
	}

	err = st.Geo_point.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Address, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_createChannel) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_createChannel, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_createChannel) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Broadcast, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Megagroup, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.About, 3)
	if err != nil {
		return err
	}

	err = st.Geo_point.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Address, 5)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_createChannel) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_editAdmin struct implement
type TLchannels_editAdmin struct {
	Channel      InputChannel    `json:"channel"`
	User_id      InputUser       `json:"user_id"`
	Admin_rights ChatAdminRights `json:"admin_rights"`
	Rank         string          `json:"rank"`
}

func (st *TLchannels_editAdmin) ResetDefault() {
	st.Channel.ResetDefault()
	st.User_id.ResetDefault()
	st.Admin_rights.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_editAdmin) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.User_id.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.Admin_rights.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Rank, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_editAdmin) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_editAdmin, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_editAdmin) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.User_id.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.Admin_rights.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Rank, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_editAdmin) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_editTitle struct implement
type TLchannels_editTitle struct {
	Channel InputChannel `json:"channel"`
	Title   string       `json:"title"`
}

func (st *TLchannels_editTitle) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_editTitle) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_editTitle) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_editTitle, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_editTitle) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_editTitle) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_editPhoto struct implement
type TLchannels_editPhoto struct {
	Channel InputChannel   `json:"channel"`
	Photo   InputChatPhoto `json:"photo"`
}

func (st *TLchannels_editPhoto) ResetDefault() {
	st.Channel.ResetDefault()
	st.Photo.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_editPhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Photo.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_editPhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_editPhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_editPhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Photo.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_editPhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_joinChannel struct implement
type TLchannels_joinChannel struct {
	Channel InputChannel `json:"channel"`
}

func (st *TLchannels_joinChannel) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_joinChannel) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_joinChannel) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_joinChannel, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_joinChannel) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_joinChannel) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_leaveChannel struct implement
type TLchannels_leaveChannel struct {
	Channel InputChannel `json:"channel"`
}

func (st *TLchannels_leaveChannel) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_leaveChannel) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_leaveChannel) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_leaveChannel, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_leaveChannel) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_leaveChannel) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_inviteToChannel struct implement
type TLchannels_inviteToChannel struct {
	Channel InputChannel `json:"channel"`
	Users   []InputUser  `json:"users"`
}

func (st *TLchannels_inviteToChannel) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_inviteToChannel) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Users = make([]InputUser, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Users[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_inviteToChannel) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_inviteToChannel, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_inviteToChannel) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Users)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Users {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_inviteToChannel) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_deleteChannel struct implement
type TLchannels_deleteChannel struct {
	Channel InputChannel `json:"channel"`
}

func (st *TLchannels_deleteChannel) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_deleteChannel) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_deleteChannel) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_deleteChannel, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_deleteChannel) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_deleteChannel) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_migrateChat struct implement
type TLmessages_migrateChat struct {
	Chat_id int32 `json:"chat_id"`
}

func (st *TLmessages_migrateChat) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_migrateChat) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Chat_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_migrateChat) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_migrateChat, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_migrateChat) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Chat_id, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_migrateChat) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_sendInlineBotResult struct implement
type TLmessages_sendInlineBotResult struct {
	Silent          bool      `json:"silent"`
	Background      bool      `json:"background"`
	Clear_draft     bool      `json:"clear_draft"`
	Hide_via        bool      `json:"hide_via"`
	Peer            InputPeer `json:"peer"`
	Reply_to_msg_id int32     `json:"reply_to_msg_id"`
	Random_id       int64     `json:"random_id"`
	Query_id        int64     `json:"query_id"`
	Id              string    `json:"id"`
	Schedule_date   int32     `json:"schedule_date"`
}

func (st *TLmessages_sendInlineBotResult) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_sendInlineBotResult) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Silent, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Background, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Clear_draft, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Hide_via, 3, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Reply_to_msg_id, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Random_id, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Query_id, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Id, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Schedule_date, 9, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_sendInlineBotResult) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_sendInlineBotResult, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_sendInlineBotResult) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Silent, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Background, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Clear_draft, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Hide_via, 3)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Reply_to_msg_id, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Random_id, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Query_id, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Id, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Schedule_date, 9)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_sendInlineBotResult) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_toggleSignatures struct implement
type TLchannels_toggleSignatures struct {
	Channel InputChannel `json:"channel"`
	Enabled Bool         `json:"enabled"`
}

func (st *TLchannels_toggleSignatures) ResetDefault() {
	st.Channel.ResetDefault()
	st.Enabled.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_toggleSignatures) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Enabled.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_toggleSignatures) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_toggleSignatures, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_toggleSignatures) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Enabled.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_toggleSignatures) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_editMessage struct implement
type TLmessages_editMessage struct {
	No_webpage    bool            `json:"no_webpage"`
	Peer          InputPeer       `json:"peer"`
	Id            int32           `json:"id"`
	Message       string          `json:"message"`
	Media         InputMedia      `json:"media"`
	Reply_markup  ReplyMarkup     `json:"reply_markup"`
	Entities      []MessageEntity `json:"entities"`
	Schedule_date int32           `json:"schedule_date"`
}

func (st *TLmessages_editMessage) ResetDefault() {
	st.Peer.ResetDefault()
	st.Media.ResetDefault()
	st.Reply_markup.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_editMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.No_webpage, 0, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Id, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 3, false)
	if err != nil {
		return err
	}

	err = st.Media.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = st.Reply_markup.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Schedule_date, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_editMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_editMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_editMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.No_webpage, 0)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Id, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 3)
	if err != nil {
		return err
	}

	err = st.Media.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = st.Reply_markup.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Schedule_date, 7)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_editMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getAllDrafts struct implement
type TLmessages_getAllDrafts struct {
}

func (st *TLmessages_getAllDrafts) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getAllDrafts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getAllDrafts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getAllDrafts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getAllDrafts) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getAllDrafts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_setGameScore struct implement
type TLmessages_setGameScore struct {
	Edit_message bool      `json:"edit_message"`
	Force        bool      `json:"force"`
	Peer         InputPeer `json:"peer"`
	Id           int32     `json:"id"`
	User_id      InputUser `json:"user_id"`
	Score        int32     `json:"score"`
}

func (st *TLmessages_setGameScore) ResetDefault() {
	st.Peer.ResetDefault()
	st.User_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_setGameScore) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Edit_message, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Force, 1, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Id, 3, false)
	if err != nil {
		return err
	}

	err = st.User_id.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Score, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_setGameScore) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_setGameScore, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_setGameScore) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Edit_message, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Force, 1)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Id, 3)
	if err != nil {
		return err
	}

	err = st.User_id.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Score, 5)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_setGameScore) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphone_discardCall struct implement
type TLphone_discardCall struct {
	Video         bool                   `json:"video"`
	Peer          InputPhoneCall         `json:"peer"`
	Duration      int32                  `json:"duration"`
	Reason        PhoneCallDiscardReason `json:"reason"`
	Connection_id int64                  `json:"connection_id"`
}

func (st *TLphone_discardCall) ResetDefault() {
	st.Peer.ResetDefault()
	st.Reason.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphone_discardCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Video, 0, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Duration, 2, false)
	if err != nil {
		return err
	}

	err = st.Reason.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Connection_id, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphone_discardCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphone_discardCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphone_discardCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Video, 0)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Duration, 2)
	if err != nil {
		return err
	}

	err = st.Reason.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Connection_id, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphone_discardCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphone_setCallRating struct implement
type TLphone_setCallRating struct {
	User_initiative bool           `json:"user_initiative"`
	Peer            InputPhoneCall `json:"peer"`
	Rating          int32          `json:"rating"`
	Comment         string         `json:"comment"`
}

func (st *TLphone_setCallRating) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphone_setCallRating) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.User_initiative, 0, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Rating, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Comment, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphone_setCallRating) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphone_setCallRating, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphone_setCallRating) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.User_initiative, 0)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Rating, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Comment, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphone_setCallRating) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_editBanned struct implement
type TLchannels_editBanned struct {
	Channel       InputChannel     `json:"channel"`
	User_id       InputUser        `json:"user_id"`
	Banned_rights ChatBannedRights `json:"banned_rights"`
}

func (st *TLchannels_editBanned) ResetDefault() {
	st.Channel.ResetDefault()
	st.User_id.ResetDefault()
	st.Banned_rights.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_editBanned) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.User_id.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.Banned_rights.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_editBanned) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_editBanned, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_editBanned) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.User_id.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.Banned_rights.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_editBanned) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_sendScreenshotNotification struct implement
type TLmessages_sendScreenshotNotification struct {
	Peer            InputPeer `json:"peer"`
	Reply_to_msg_id int32     `json:"reply_to_msg_id"`
	Random_id       int64     `json:"random_id"`
}

func (st *TLmessages_sendScreenshotNotification) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_sendScreenshotNotification) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Reply_to_msg_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Random_id, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_sendScreenshotNotification) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_sendScreenshotNotification, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_sendScreenshotNotification) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Reply_to_msg_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Random_id, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_sendScreenshotNotification) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_togglePreHistoryHidden struct implement
type TLchannels_togglePreHistoryHidden struct {
	Channel InputChannel `json:"channel"`
	Enabled Bool         `json:"enabled"`
}

func (st *TLchannels_togglePreHistoryHidden) ResetDefault() {
	st.Channel.ResetDefault()
	st.Enabled.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_togglePreHistoryHidden) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Enabled.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_togglePreHistoryHidden) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_togglePreHistoryHidden, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_togglePreHistoryHidden) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Enabled.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_togglePreHistoryHidden) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_sendMultiMedia struct implement
type TLmessages_sendMultiMedia struct {
	Silent          bool               `json:"silent"`
	Background      bool               `json:"background"`
	Clear_draft     bool               `json:"clear_draft"`
	Peer            InputPeer          `json:"peer"`
	Reply_to_msg_id int32              `json:"reply_to_msg_id"`
	Multi_media     []InputSingleMedia `json:"multi_media"`
	Schedule_date   int32              `json:"schedule_date"`
}

func (st *TLmessages_sendMultiMedia) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_sendMultiMedia) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Silent, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Background, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Clear_draft, 2, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Reply_to_msg_id, 4, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Multi_media = make([]InputSingleMedia, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Multi_media[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Schedule_date, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_sendMultiMedia) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_sendMultiMedia, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_sendMultiMedia) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Silent, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Background, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Clear_draft, 2)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Reply_to_msg_id, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Multi_media)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Multi_media {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Schedule_date, 6)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_sendMultiMedia) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_updatePinnedMessage struct implement
type TLmessages_updatePinnedMessage struct {
	Silent     bool      `json:"silent"`
	Unpin      bool      `json:"unpin"`
	Pm_oneside bool      `json:"pm_oneside"`
	Peer       InputPeer `json:"peer"`
	Id         int32     `json:"id"`
}

func (st *TLmessages_updatePinnedMessage) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_updatePinnedMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Silent, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Unpin, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Pm_oneside, 2, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Id, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_updatePinnedMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_updatePinnedMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_updatePinnedMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Silent, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Unpin, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Pm_oneside, 2)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Id, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_updatePinnedMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getNotifyExceptions struct implement
type TLaccount_getNotifyExceptions struct {
	Compare_sound bool            `json:"compare_sound"`
	Peer          InputNotifyPeer `json:"peer"`
}

func (st *TLaccount_getNotifyExceptions) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getNotifyExceptions) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Compare_sound, 0, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getNotifyExceptions) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getNotifyExceptions, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getNotifyExceptions) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Compare_sound, 0)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getNotifyExceptions) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_sendVote struct implement
type TLmessages_sendVote struct {
	Peer    InputPeer `json:"peer"`
	Msg_id  int32     `json:"msg_id"`
	Options [][]uint8 `json:"options"`
}

func (st *TLmessages_sendVote) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_sendVote) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Msg_id, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Options = make([][]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err, have, ty = _is.SkipToNoCheck(0, false)
				if err != nil {
					return err
				}

				if have {
					if ty == codec.LIST {
						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}

						st.Options[i0] = make([]uint8, length)
						for i1, e1 := int32(0), length; i1 < e1; i1++ {

							err = _is.Read_uint8(&st.Options[i0][i1], 0, false)
							if err != nil {
								return err
							}

						}
					} else if ty == codec.SIMPLE_LIST {

						err, _ = _is.SkipTo(codec.BYTE, 0, true)
						if err != nil {
							return err
						}

						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}

						err = _is.Read_slice_uint8(&st.Options[i0], length, true)
						if err != nil {
							return err
						}

					} else {
						err = fmt.Errorf("require vector, but not")
						if err != nil {
							return err
						}

					}
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_sendVote) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_sendVote, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_sendVote) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Msg_id, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Options)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Options {

		err = _os.WriteHead(codec.LIST, 0)
		if err != nil {
			return err
		}

		err = _os.Write_int32(int32(len(v)), 0)
		if err != nil {
			return err
		}

		for _, v := range v {

			err = _os.Write_uint8(v, 0)
			if err != nil {
				return err
			}

		}
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_sendVote) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getPollResults struct implement
type TLmessages_getPollResults struct {
	Peer   InputPeer `json:"peer"`
	Msg_id int32     `json:"msg_id"`
}

func (st *TLmessages_getPollResults) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getPollResults) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Msg_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getPollResults) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getPollResults, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getPollResults) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Msg_id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getPollResults) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_editChatDefaultBannedRights struct implement
type TLmessages_editChatDefaultBannedRights struct {
	Peer          InputPeer        `json:"peer"`
	Banned_rights ChatBannedRights `json:"banned_rights"`
}

func (st *TLmessages_editChatDefaultBannedRights) ResetDefault() {
	st.Peer.ResetDefault()
	st.Banned_rights.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_editChatDefaultBannedRights) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Banned_rights.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_editChatDefaultBannedRights) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_editChatDefaultBannedRights, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_editChatDefaultBannedRights) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Banned_rights.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_editChatDefaultBannedRights) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLfolders_editPeerFolders struct implement
type TLfolders_editPeerFolders struct {
	Folder_peers []InputFolderPeer `json:"folder_peers"`
}

func (st *TLfolders_editPeerFolders) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLfolders_editPeerFolders) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Folder_peers = make([]InputFolderPeer, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Folder_peers[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLfolders_editPeerFolders) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLfolders_editPeerFolders, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLfolders_editPeerFolders) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Folder_peers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Folder_peers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLfolders_editPeerFolders) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLfolders_deleteFolder struct implement
type TLfolders_deleteFolder struct {
	Folder_id int32 `json:"folder_id"`
}

func (st *TLfolders_deleteFolder) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLfolders_deleteFolder) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Folder_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLfolders_deleteFolder) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLfolders_deleteFolder, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLfolders_deleteFolder) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Folder_id, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLfolders_deleteFolder) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_addContact struct implement
type TLcontacts_addContact struct {
	Add_phone_privacy_exception bool      `json:"add_phone_privacy_exception"`
	Id                          InputUser `json:"id"`
	First_name                  string    `json:"first_name"`
	Last_name                   string    `json:"last_name"`
	Phone                       string    `json:"phone"`
}

func (st *TLcontacts_addContact) ResetDefault() {
	st.Id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_addContact) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Add_phone_privacy_exception, 0, false)
	if err != nil {
		return err
	}

	err = st.Id.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.First_name, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Last_name, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_addContact) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_addContact, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_addContact) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Add_phone_privacy_exception, 0)
	if err != nil {
		return err
	}

	err = st.Id.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.First_name, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Last_name, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_addContact) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_acceptContact struct implement
type TLcontacts_acceptContact struct {
	Id InputUser `json:"id"`
}

func (st *TLcontacts_acceptContact) ResetDefault() {
	st.Id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_acceptContact) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_acceptContact) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_acceptContact, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_acceptContact) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_acceptContact) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_editCreator struct implement
type TLchannels_editCreator struct {
	Channel  InputChannel          `json:"channel"`
	User_id  InputUser             `json:"user_id"`
	Password InputCheckPasswordSRP `json:"password"`
}

func (st *TLchannels_editCreator) ResetDefault() {
	st.Channel.ResetDefault()
	st.User_id.ResetDefault()
	st.Password.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_editCreator) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.User_id.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.Password.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_editCreator) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_editCreator, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_editCreator) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.User_id.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.Password.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_editCreator) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_getLocated struct implement
type TLcontacts_getLocated struct {
	Background   bool          `json:"background"`
	Geo_point    InputGeoPoint `json:"geo_point"`
	Self_expires int32         `json:"self_expires"`
}

func (st *TLcontacts_getLocated) ResetDefault() {
	st.Geo_point.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_getLocated) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Background, 0, false)
	if err != nil {
		return err
	}

	err = st.Geo_point.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Self_expires, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_getLocated) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_getLocated, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_getLocated) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Background, 0)
	if err != nil {
		return err
	}

	err = st.Geo_point.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Self_expires, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_getLocated) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_toggleSlowMode struct implement
type TLchannels_toggleSlowMode struct {
	Channel InputChannel `json:"channel"`
	Seconds int32        `json:"seconds"`
}

func (st *TLchannels_toggleSlowMode) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_toggleSlowMode) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Seconds, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_toggleSlowMode) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_toggleSlowMode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_toggleSlowMode) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Seconds, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_toggleSlowMode) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_sendScheduledMessages struct implement
type TLmessages_sendScheduledMessages struct {
	Peer InputPeer `json:"peer"`
	Id   []int32   `json:"id"`
}

func (st *TLmessages_sendScheduledMessages) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_sendScheduledMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_sendScheduledMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_sendScheduledMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_sendScheduledMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_sendScheduledMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_deleteScheduledMessages struct implement
type TLmessages_deleteScheduledMessages struct {
	Peer InputPeer `json:"peer"`
	Id   []int32   `json:"id"`
}

func (st *TLmessages_deleteScheduledMessages) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_deleteScheduledMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_deleteScheduledMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_deleteScheduledMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_deleteScheduledMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_deleteScheduledMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_blockFromReplies struct implement
type TLcontacts_blockFromReplies struct {
	Delete_message bool  `json:"delete_message"`
	Delete_history bool  `json:"delete_history"`
	Report_spam    bool  `json:"report_spam"`
	Msg_id         int32 `json:"msg_id"`
}

func (st *TLcontacts_blockFromReplies) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_blockFromReplies) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Delete_message, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Delete_history, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Report_spam, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Msg_id, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_blockFromReplies) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_blockFromReplies, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_blockFromReplies) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Delete_message, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Delete_history, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Report_spam, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Msg_id, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_blockFromReplies) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_sendVerifyEmailCode struct implement
type TLaccount_sendVerifyEmailCode struct {
	Email string `json:"email"`
}

func (st *TLaccount_sendVerifyEmailCode) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_sendVerifyEmailCode) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Email, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_sendVerifyEmailCode) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_sendVerifyEmailCode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_sendVerifyEmailCode) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Email, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_sendVerifyEmailCode) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getMessagesViews struct implement
type TLmessages_getMessagesViews struct {
	Peer      InputPeer `json:"peer"`
	Id        []int32   `json:"id"`
	Increment Bool      `json:"increment"`
}

func (st *TLmessages_getMessagesViews) ResetDefault() {
	st.Peer.ResetDefault()
	st.Increment.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getMessagesViews) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Increment.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getMessagesViews) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getMessagesViews, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getMessagesViews) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	err = st.Increment.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getMessagesViews) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinvokeAfterMsg struct implement
type TLinvokeAfterMsg struct {
	Msg_id int64   `json:"msg_id"`
	Query  []uint8 `json:"query"`
}

func (st *TLinvokeAfterMsg) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinvokeAfterMsg) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Msg_id, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Query = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Query[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Query, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinvokeAfterMsg) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinvokeAfterMsg, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinvokeAfterMsg) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Msg_id, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Query)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Query {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinvokeAfterMsg) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinvokeAfterMsgs struct implement
type TLinvokeAfterMsgs struct {
	Msg_ids []int64 `json:"msg_ids"`
	Query   []uint8 `json:"query"`
}

func (st *TLinvokeAfterMsgs) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinvokeAfterMsgs) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Msg_ids = make([]int64, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int64(&st.Msg_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Query = make([]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_uint8(&st.Query[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Query, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinvokeAfterMsgs) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinvokeAfterMsgs, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinvokeAfterMsgs) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Msg_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Msg_ids {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Query)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Query {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinvokeAfterMsgs) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinitConnection struct implement
type TLinitConnection struct {
	Api_id           int32            `json:"api_id"`
	Device_model     string           `json:"device_model"`
	System_version   string           `json:"system_version"`
	App_version      string           `json:"app_version"`
	System_lang_code string           `json:"system_lang_code"`
	Lang_pack        string           `json:"lang_pack"`
	Lang_code        string           `json:"lang_code"`
	Proxy            InputClientProxy `json:"proxy"`
	Params           JSONValue        `json:"params"`
	Query            []uint8          `json:"query"`
}

func (st *TLinitConnection) ResetDefault() {
	st.Proxy.ResetDefault()
	st.Params.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinitConnection) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Api_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Device_model, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.System_version, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.App_version, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.System_lang_code, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Lang_pack, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Lang_code, 6, false)
	if err != nil {
		return err
	}

	err = st.Proxy.ReadBlock(_is, 7, false)
	if err != nil {
		return err
	}

	err = st.Params.ReadBlock(_is, 8, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(9, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Query = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Query[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Query, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinitConnection) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinitConnection, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinitConnection) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Api_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Device_model, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.System_version, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.App_version, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.System_lang_code, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Lang_pack, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Lang_code, 6)
	if err != nil {
		return err
	}

	err = st.Proxy.WriteBlock(_os, 7)
	if err != nil {
		return err
	}

	err = st.Params.WriteBlock(_os, 8)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Query)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Query {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinitConnection) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinvokeWithLayer struct implement
type TLinvokeWithLayer struct {
	Layer int32   `json:"layer"`
	Query []uint8 `json:"query"`
}

func (st *TLinvokeWithLayer) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinvokeWithLayer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Layer, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Query = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Query[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Query, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinvokeWithLayer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinvokeWithLayer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinvokeWithLayer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Layer, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Query)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Query {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinvokeWithLayer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinvokeWithoutUpdates struct implement
type TLinvokeWithoutUpdates struct {
	Query []uint8 `json:"query"`
}

func (st *TLinvokeWithoutUpdates) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinvokeWithoutUpdates) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Query = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Query[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Query, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinvokeWithoutUpdates) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinvokeWithoutUpdates, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinvokeWithoutUpdates) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Query)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Query {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinvokeWithoutUpdates) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinvokeWithMessagesRange struct implement
type TLinvokeWithMessagesRange struct {
	Range MessageRange `json:"range"`
	Query []uint8      `json:"query"`
}

func (st *TLinvokeWithMessagesRange) ResetDefault() {
	st.Range.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinvokeWithMessagesRange) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Range.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Query = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Query[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Query, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinvokeWithMessagesRange) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinvokeWithMessagesRange, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinvokeWithMessagesRange) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Range.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Query)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Query {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinvokeWithMessagesRange) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLinvokeWithTakeout struct implement
type TLinvokeWithTakeout struct {
	Takeout_id int64   `json:"takeout_id"`
	Query      []uint8 `json:"query"`
}

func (st *TLinvokeWithTakeout) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLinvokeWithTakeout) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Takeout_id, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Query = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Query[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Query, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLinvokeWithTakeout) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLinvokeWithTakeout, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLinvokeWithTakeout) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Takeout_id, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Query)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Query {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLinvokeWithTakeout) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphotos_getUserPhotos struct implement
type TLphotos_getUserPhotos struct {
	User_id InputUser `json:"user_id"`
	Offset  int32     `json:"offset"`
	Max_id  int64     `json:"max_id"`
	Limit   int32     `json:"limit"`
}

func (st *TLphotos_getUserPhotos) ResetDefault() {
	st.User_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphotos_getUserPhotos) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.User_id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Max_id, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphotos_getUserPhotos) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphotos_getUserPhotos, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphotos_getUserPhotos) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.User_id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Max_id, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphotos_getUserPhotos) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphotos_updateProfilePhoto struct implement
type TLphotos_updateProfilePhoto struct {
	Id InputPhoto `json:"id"`
}

func (st *TLphotos_updateProfilePhoto) ResetDefault() {
	st.Id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphotos_updateProfilePhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphotos_updateProfilePhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphotos_updateProfilePhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphotos_updateProfilePhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphotos_updateProfilePhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphotos_uploadProfilePhoto struct implement
type TLphotos_uploadProfilePhoto struct {
	File           InputFile `json:"file"`
	Video          InputFile `json:"video"`
	Video_start_ts float64   `json:"video_start_ts"`
}

func (st *TLphotos_uploadProfilePhoto) ResetDefault() {
	st.File.ResetDefault()
	st.Video.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphotos_uploadProfilePhoto) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.File.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Video.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_float64(&st.Video_start_ts, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphotos_uploadProfilePhoto) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphotos_uploadProfilePhoto, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphotos_uploadProfilePhoto) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.File.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Video.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_float64(st.Video_start_ts, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphotos_uploadProfilePhoto) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getPasswordSettings struct implement
type TLaccount_getPasswordSettings struct {
	Password InputCheckPasswordSRP `json:"password"`
}

func (st *TLaccount_getPasswordSettings) ResetDefault() {
	st.Password.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getPasswordSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Password.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getPasswordSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getPasswordSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getPasswordSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Password.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getPasswordSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLlangpack_getLangPack struct implement
type TLlangpack_getLangPack struct {
	Lang_pack string `json:"lang_pack"`
	Lang_code string `json:"lang_code"`
}

func (st *TLlangpack_getLangPack) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLlangpack_getLangPack) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Lang_pack, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Lang_code, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLlangpack_getLangPack) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLlangpack_getLangPack, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLlangpack_getLangPack) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Lang_pack, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Lang_code, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLlangpack_getLangPack) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLlangpack_getDifference struct implement
type TLlangpack_getDifference struct {
	Lang_pack    string `json:"lang_pack"`
	Lang_code    string `json:"lang_code"`
	From_version int32  `json:"from_version"`
}

func (st *TLlangpack_getDifference) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLlangpack_getDifference) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Lang_pack, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Lang_code, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.From_version, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLlangpack_getDifference) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLlangpack_getDifference, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLlangpack_getDifference) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Lang_pack, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Lang_code, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.From_version, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLlangpack_getDifference) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_resolveUsername struct implement
type TLcontacts_resolveUsername struct {
	Username string `json:"username"`
}

func (st *TLcontacts_resolveUsername) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_resolveUsername) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Username, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_resolveUsername) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_resolveUsername, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_resolveUsername) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Username, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_resolveUsername) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_getNearestDc struct implement
type TLhelp_getNearestDc struct {
}

func (st *TLhelp_getNearestDc) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_getNearestDc) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_getNearestDc) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_getNearestDc, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_getNearestDc) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_getNearestDc) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_requestPasswordRecovery struct implement
type TLauth_requestPasswordRecovery struct {
}

func (st *TLauth_requestPasswordRecovery) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_requestPasswordRecovery) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_requestPasswordRecovery) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_requestPasswordRecovery, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_requestPasswordRecovery) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_requestPasswordRecovery) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_sendEncrypted struct implement
type TLmessages_sendEncrypted struct {
	Silent    bool               `json:"silent"`
	Peer      InputEncryptedChat `json:"peer"`
	Random_id int64              `json:"random_id"`
	Data      []uint8            `json:"data"`
}

func (st *TLmessages_sendEncrypted) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_sendEncrypted) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Silent, 0, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Random_id, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Data = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Data[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Data, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_sendEncrypted) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_sendEncrypted, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_sendEncrypted) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Silent, 0)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Random_id, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Data)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Data {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_sendEncrypted) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_sendEncryptedFile struct implement
type TLmessages_sendEncryptedFile struct {
	Silent    bool               `json:"silent"`
	Peer      InputEncryptedChat `json:"peer"`
	Random_id int64              `json:"random_id"`
	Data      []uint8            `json:"data"`
	File      InputEncryptedFile `json:"file"`
}

func (st *TLmessages_sendEncryptedFile) ResetDefault() {
	st.Peer.ResetDefault()
	st.File.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_sendEncryptedFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Silent, 0, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Random_id, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Data = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Data[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Data, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.File.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_sendEncryptedFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_sendEncryptedFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_sendEncryptedFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Silent, 0)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Random_id, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Data)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Data {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = st.File.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_sendEncryptedFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_sendEncryptedService struct implement
type TLmessages_sendEncryptedService struct {
	Peer      InputEncryptedChat `json:"peer"`
	Random_id int64              `json:"random_id"`
	Data      []uint8            `json:"data"`
}

func (st *TLmessages_sendEncryptedService) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_sendEncryptedService) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Random_id, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Data = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Data[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Data, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_sendEncryptedService) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_sendEncryptedService, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_sendEncryptedService) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Random_id, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Data)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Data {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_sendEncryptedService) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdates_getDifference struct implement
type TLupdates_getDifference struct {
	Pts             int32 `json:"pts"`
	Pts_total_limit int32 `json:"pts_total_limit"`
	Date            int32 `json:"date"`
	Qts             int32 `json:"qts"`
}

func (st *TLupdates_getDifference) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdates_getDifference) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Pts, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Pts_total_limit, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Date, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Qts, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdates_getDifference) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdates_getDifference, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdates_getDifference) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Pts, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Pts_total_limit, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Date, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Qts, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdates_getDifference) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getAllSecureValues struct implement
type TLaccount_getAllSecureValues struct {
}

func (st *TLaccount_getAllSecureValues) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getAllSecureValues) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getAllSecureValues) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getAllSecureValues, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getAllSecureValues) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getAllSecureValues) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getSecureValue struct implement
type TLaccount_getSecureValue struct {
	Types []SecureValueType `json:"types"`
}

func (st *TLaccount_getSecureValue) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getSecureValue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Types = make([]SecureValueType, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Types[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getSecureValue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getSecureValue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getSecureValue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Types)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Types {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getSecureValue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getRecentStickers struct implement
type TLmessages_getRecentStickers struct {
	Attached bool  `json:"attached"`
	Hash     int32 `json:"hash"`
}

func (st *TLmessages_getRecentStickers) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getRecentStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Attached, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getRecentStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getRecentStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getRecentStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Attached, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getRecentStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_installStickerSet struct implement
type TLmessages_installStickerSet struct {
	Stickerset InputStickerSet `json:"stickerset"`
	Archived   Bool            `json:"archived"`
}

func (st *TLmessages_installStickerSet) ResetDefault() {
	st.Stickerset.ResetDefault()
	st.Archived.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_installStickerSet) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Stickerset.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Archived.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_installStickerSet) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_installStickerSet, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_installStickerSet) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Stickerset.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Archived.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_installStickerSet) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_getBlocked struct implement
type TLcontacts_getBlocked struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (st *TLcontacts_getBlocked) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_getBlocked) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Offset, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_getBlocked) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_getBlocked, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_getBlocked) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Offset, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_getBlocked) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_requestUrlAuth struct implement
type TLmessages_requestUrlAuth struct {
	Peer      InputPeer `json:"peer"`
	Msg_id    int32     `json:"msg_id"`
	Button_id int32     `json:"button_id"`
}

func (st *TLmessages_requestUrlAuth) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_requestUrlAuth) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Msg_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Button_id, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_requestUrlAuth) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_requestUrlAuth, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_requestUrlAuth) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Msg_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Button_id, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_requestUrlAuth) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_acceptUrlAuth struct implement
type TLmessages_acceptUrlAuth struct {
	Write_allowed bool      `json:"write_allowed"`
	Peer          InputPeer `json:"peer"`
	Msg_id        int32     `json:"msg_id"`
	Button_id     int32     `json:"button_id"`
}

func (st *TLmessages_acceptUrlAuth) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_acceptUrlAuth) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Write_allowed, 0, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Msg_id, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Button_id, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_acceptUrlAuth) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_acceptUrlAuth, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_acceptUrlAuth) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Write_allowed, 0)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Msg_id, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Button_id, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_acceptUrlAuth) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_search struct implement
type TLcontacts_search struct {
	Q     string `json:"q"`
	Limit int32  `json:"limit"`
}

func (st *TLcontacts_search) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_search) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Q, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_search) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_search, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_search) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Q, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_search) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstats_getMegagroupStats struct implement
type TLstats_getMegagroupStats struct {
	Dark    bool         `json:"dark"`
	Channel InputChannel `json:"channel"`
}

func (st *TLstats_getMegagroupStats) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstats_getMegagroupStats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Dark, 0, false)
	if err != nil {
		return err
	}

	err = st.Channel.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstats_getMegagroupStats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstats_getMegagroupStats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstats_getMegagroupStats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Dark, 0)
	if err != nil {
		return err
	}

	err = st.Channel.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstats_getMegagroupStats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupload_getFile struct implement
type TLupload_getFile struct {
	Precise       bool              `json:"precise"`
	Cdn_supported bool              `json:"cdn_supported"`
	Location      InputFileLocation `json:"location"`
	Offset        int32             `json:"offset"`
	Limit         int32             `json:"limit"`
}

func (st *TLupload_getFile) ResetDefault() {
	st.Location.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupload_getFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Precise, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Cdn_supported, 1, false)
	if err != nil {
		return err
	}

	err = st.Location.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupload_getFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupload_getFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupload_getFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Precise, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Cdn_supported, 1)
	if err != nil {
		return err
	}

	err = st.Location.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupload_getFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getWebAuthorizations struct implement
type TLaccount_getWebAuthorizations struct {
}

func (st *TLaccount_getWebAuthorizations) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getWebAuthorizations) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getWebAuthorizations) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getWebAuthorizations, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getWebAuthorizations) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getWebAuthorizations) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupload_getCdnFile struct implement
type TLupload_getCdnFile struct {
	File_token []uint8 `json:"file_token"`
	Offset     int32   `json:"offset"`
	Limit      int32   `json:"limit"`
}

func (st *TLupload_getCdnFile) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupload_getCdnFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.File_token = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.File_token[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.File_token, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Offset, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupload_getCdnFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupload_getCdnFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupload_getCdnFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.File_token)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.File_token {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Offset, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupload_getCdnFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getContentSettings struct implement
type TLaccount_getContentSettings struct {
}

func (st *TLaccount_getContentSettings) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getContentSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getContentSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getContentSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getContentSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getContentSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_getContactIDs struct implement
type TLcontacts_getContactIDs struct {
	Hash int32 `json:"hash"`
}

func (st *TLcontacts_getContactIDs) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_getContactIDs) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_getContactIDs) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_getContactIDs, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_getContactIDs) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_getContactIDs) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getEmojiKeywordsLanguages struct implement
type TLmessages_getEmojiKeywordsLanguages struct {
	Lang_codes []string `json:"lang_codes"`
}

func (st *TLmessages_getEmojiKeywordsLanguages) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getEmojiKeywordsLanguages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Lang_codes = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_string(&st.Lang_codes[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getEmojiKeywordsLanguages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getEmojiKeywordsLanguages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getEmojiKeywordsLanguages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Lang_codes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Lang_codes {

		err = _os.Write_string(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getEmojiKeywordsLanguages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_deleteHistory struct implement
type TLmessages_deleteHistory struct {
	Just_clear bool      `json:"just_clear"`
	Revoke     bool      `json:"revoke"`
	Peer       InputPeer `json:"peer"`
	Max_id     int32     `json:"max_id"`
}

func (st *TLmessages_deleteHistory) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_deleteHistory) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Just_clear, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Revoke, 1, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_id, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_deleteHistory) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_deleteHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_deleteHistory) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Just_clear, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Revoke, 1)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_id, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_deleteHistory) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_deleteUserHistory struct implement
type TLchannels_deleteUserHistory struct {
	Channel InputChannel `json:"channel"`
	User_id InputUser    `json:"user_id"`
}

func (st *TLchannels_deleteUserHistory) ResetDefault() {
	st.Channel.ResetDefault()
	st.User_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_deleteUserHistory) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.User_id.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_deleteUserHistory) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_deleteUserHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_deleteUserHistory) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.User_id.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_deleteUserHistory) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_readMentions struct implement
type TLmessages_readMentions struct {
	Peer InputPeer `json:"peer"`
}

func (st *TLmessages_readMentions) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_readMentions) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_readMentions) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_readMentions, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_readMentions) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_readMentions) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_unpinAllMessages struct implement
type TLmessages_unpinAllMessages struct {
	Peer InputPeer `json:"peer"`
}

func (st *TLmessages_unpinAllMessages) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_unpinAllMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_unpinAllMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_unpinAllMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_unpinAllMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_unpinAllMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getAttachedStickers struct implement
type TLmessages_getAttachedStickers struct {
	Media InputStickeredMedia `json:"media"`
}

func (st *TLmessages_getAttachedStickers) ResetDefault() {
	st.Media.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getAttachedStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Media.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getAttachedStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getAttachedStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getAttachedStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Media.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getAttachedStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_getTermsOfServiceUpdate struct implement
type TLhelp_getTermsOfServiceUpdate struct {
}

func (st *TLhelp_getTermsOfServiceUpdate) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_getTermsOfServiceUpdate) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_getTermsOfServiceUpdate) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_getTermsOfServiceUpdate, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_getTermsOfServiceUpdate) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_getTermsOfServiceUpdate) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLlangpack_getLanguage struct implement
type TLlangpack_getLanguage struct {
	Lang_pack string `json:"lang_pack"`
	Lang_code string `json:"lang_code"`
}

func (st *TLlangpack_getLanguage) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLlangpack_getLanguage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Lang_pack, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Lang_code, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLlangpack_getLanguage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLlangpack_getLanguage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLlangpack_getLanguage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Lang_pack, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Lang_code, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLlangpack_getLanguage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_getPromoData struct implement
type TLhelp_getPromoData struct {
}

func (st *TLhelp_getPromoData) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_getPromoData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_getPromoData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_getPromoData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_getPromoData) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_getPromoData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_searchStickerSets struct implement
type TLmessages_searchStickerSets struct {
	Exclude_featured bool   `json:"exclude_featured"`
	Q                string `json:"q"`
	Hash             int32  `json:"hash"`
}

func (st *TLmessages_searchStickerSets) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_searchStickerSets) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Exclude_featured, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Q, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_searchStickerSets) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_searchStickerSets, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_searchStickerSets) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Exclude_featured, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Q, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_searchStickerSets) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdates_getState struct implement
type TLupdates_getState struct {
}

func (st *TLupdates_getState) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdates_getState) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdates_getState) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdates_getState, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdates_getState) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdates_getState) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getDocumentByHash struct implement
type TLmessages_getDocumentByHash struct {
	Sha256    []uint8 `json:"sha256"`
	Size      int32   `json:"size"`
	Mime_type string  `json:"mime_type"`
}

func (st *TLmessages_getDocumentByHash) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getDocumentByHash) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Sha256 = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Sha256[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Sha256, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Size, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Mime_type, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getDocumentByHash) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getDocumentByHash, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getDocumentByHash) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Sha256)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Sha256 {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Size, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Mime_type, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getDocumentByHash) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_uploadTheme struct implement
type TLaccount_uploadTheme struct {
	File      InputFile `json:"file"`
	Thumb     InputFile `json:"thumb"`
	File_name string    `json:"file_name"`
	Mime_type string    `json:"mime_type"`
}

func (st *TLaccount_uploadTheme) ResetDefault() {
	st.File.ResetDefault()
	st.Thumb.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_uploadTheme) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.File.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Thumb.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.File_name, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Mime_type, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_uploadTheme) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_uploadTheme, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_uploadTheme) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.File.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Thumb.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.File_name, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Mime_type, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_uploadTheme) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLlangpack_getLanguages struct implement
type TLlangpack_getLanguages struct {
	Lang_pack string `json:"lang_pack"`
}

func (st *TLlangpack_getLanguages) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLlangpack_getLanguages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Lang_pack, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLlangpack_getLanguages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLlangpack_getLanguages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLlangpack_getLanguages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Lang_pack, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLlangpack_getLanguages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getDialogFilters struct implement
type TLmessages_getDialogFilters struct {
}

func (st *TLmessages_getDialogFilters) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getDialogFilters) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getDialogFilters) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getDialogFilters, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getDialogFilters) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getDialogFilters) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getEmojiKeywords struct implement
type TLmessages_getEmojiKeywords struct {
	Lang_code string `json:"lang_code"`
}

func (st *TLmessages_getEmojiKeywords) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getEmojiKeywords) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Lang_code, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getEmojiKeywords) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getEmojiKeywords, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getEmojiKeywords) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Lang_code, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getEmojiKeywords) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getEmojiKeywordsDifference struct implement
type TLmessages_getEmojiKeywordsDifference struct {
	Lang_code    string `json:"lang_code"`
	From_version int32  `json:"from_version"`
}

func (st *TLmessages_getEmojiKeywordsDifference) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getEmojiKeywordsDifference) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Lang_code, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.From_version, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getEmojiKeywordsDifference) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getEmojiKeywordsDifference, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getEmojiKeywordsDifference) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Lang_code, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.From_version, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getEmojiKeywordsDifference) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getThemes struct implement
type TLaccount_getThemes struct {
	Format string `json:"format"`
	Hash   int32  `json:"hash"`
}

func (st *TLaccount_getThemes) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getThemes) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Format, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getThemes) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getThemes, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getThemes) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Format, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getThemes) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getAuthorizationForm struct implement
type TLaccount_getAuthorizationForm struct {
	Bot_id     int32  `json:"bot_id"`
	Scope      string `json:"scope"`
	Public_key string `json:"public_key"`
}

func (st *TLaccount_getAuthorizationForm) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getAuthorizationForm) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Bot_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Scope, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Public_key, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getAuthorizationForm) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getAuthorizationForm, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getAuthorizationForm) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Bot_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Scope, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Public_key, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getAuthorizationForm) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getMultiWallPapers struct implement
type TLaccount_getMultiWallPapers struct {
	Wallpapers []InputWallPaper `json:"wallpapers"`
}

func (st *TLaccount_getMultiWallPapers) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getMultiWallPapers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Wallpapers = make([]InputWallPaper, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Wallpapers[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getMultiWallPapers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getMultiWallPapers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getMultiWallPapers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Wallpapers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Wallpapers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getMultiWallPapers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_getCdnConfig struct implement
type TLhelp_getCdnConfig struct {
}

func (st *TLhelp_getCdnConfig) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_getCdnConfig) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_getCdnConfig) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_getCdnConfig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_getCdnConfig) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_getCdnConfig) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpayments_getSavedInfo struct implement
type TLpayments_getSavedInfo struct {
}

func (st *TLpayments_getSavedInfo) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpayments_getSavedInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpayments_getSavedInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpayments_getSavedInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpayments_getSavedInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpayments_getSavedInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getWallPaper struct implement
type TLaccount_getWallPaper struct {
	Wallpaper InputWallPaper `json:"wallpaper"`
}

func (st *TLaccount_getWallPaper) ResetDefault() {
	st.Wallpaper.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getWallPaper) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Wallpaper.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getWallPaper) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getWallPaper, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getWallPaper) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Wallpaper.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getWallPaper) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_uploadWallPaper struct implement
type TLaccount_uploadWallPaper struct {
	File      InputFile         `json:"file"`
	Mime_type string            `json:"mime_type"`
	Settings  WallPaperSettings `json:"settings"`
}

func (st *TLaccount_uploadWallPaper) ResetDefault() {
	st.File.ResetDefault()
	st.Settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_uploadWallPaper) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.File.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Mime_type, 1, false)
	if err != nil {
		return err
	}

	err = st.Settings.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_uploadWallPaper) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_uploadWallPaper, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_uploadWallPaper) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.File.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Mime_type, 1)
	if err != nil {
		return err
	}

	err = st.Settings.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_uploadWallPaper) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_logOut struct implement
type TLauth_logOut struct {
}

func (st *TLauth_logOut) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_logOut) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_logOut) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_logOut, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_logOut) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_logOut) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_resetAuthorizations struct implement
type TLauth_resetAuthorizations struct {
}

func (st *TLauth_resetAuthorizations) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_resetAuthorizations) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_resetAuthorizations) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_resetAuthorizations, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_resetAuthorizations) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_resetAuthorizations) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_bindTempAuthKey struct implement
type TLauth_bindTempAuthKey struct {
	Perm_auth_key_id  int64   `json:"perm_auth_key_id"`
	Nonce             int64   `json:"nonce"`
	Expires_at        int32   `json:"expires_at"`
	Encrypted_message []uint8 `json:"encrypted_message"`
}

func (st *TLauth_bindTempAuthKey) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_bindTempAuthKey) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Perm_auth_key_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Nonce, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Expires_at, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Encrypted_message = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Encrypted_message[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Encrypted_message, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_bindTempAuthKey) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_bindTempAuthKey, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_bindTempAuthKey) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Perm_auth_key_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Nonce, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Expires_at, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Encrypted_message)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Encrypted_message {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_bindTempAuthKey) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_registerDevice struct implement
type TLaccount_registerDevice struct {
	No_muted    bool    `json:"no_muted"`
	Token_type  int32   `json:"token_type"`
	Token       string  `json:"token"`
	App_sandbox Bool    `json:"app_sandbox"`
	Secret      []uint8 `json:"secret"`
	Other_uids  []int32 `json:"other_uids"`
}

func (st *TLaccount_registerDevice) ResetDefault() {
	st.App_sandbox.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_registerDevice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.No_muted, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Token_type, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Token, 2, false)
	if err != nil {
		return err
	}

	err = st.App_sandbox.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Secret = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Secret[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Secret, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Other_uids = make([]int32, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_int32(&st.Other_uids[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_registerDevice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_registerDevice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_registerDevice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.No_muted, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Token_type, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Token, 2)
	if err != nil {
		return err
	}

	err = st.App_sandbox.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Secret)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Secret {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Other_uids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Other_uids {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_registerDevice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_unregisterDevice struct implement
type TLaccount_unregisterDevice struct {
	Token_type int32   `json:"token_type"`
	Token      string  `json:"token"`
	Other_uids []int32 `json:"other_uids"`
}

func (st *TLaccount_unregisterDevice) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_unregisterDevice) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Token_type, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Token, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Other_uids = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Other_uids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_unregisterDevice) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_unregisterDevice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_unregisterDevice) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Token_type, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Token, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Other_uids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Other_uids {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_unregisterDevice) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_updateNotifySettings struct implement
type TLaccount_updateNotifySettings struct {
	Peer     InputNotifyPeer         `json:"peer"`
	Settings InputPeerNotifySettings `json:"settings"`
}

func (st *TLaccount_updateNotifySettings) ResetDefault() {
	st.Peer.ResetDefault()
	st.Settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_updateNotifySettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Settings.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_updateNotifySettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_updateNotifySettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_updateNotifySettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Settings.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_updateNotifySettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_resetNotifySettings struct implement
type TLaccount_resetNotifySettings struct {
}

func (st *TLaccount_resetNotifySettings) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_resetNotifySettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_resetNotifySettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_resetNotifySettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_resetNotifySettings) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_resetNotifySettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_updateStatus struct implement
type TLaccount_updateStatus struct {
	Offline Bool `json:"offline"`
}

func (st *TLaccount_updateStatus) ResetDefault() {
	st.Offline.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_updateStatus) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Offline.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_updateStatus) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_updateStatus, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_updateStatus) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Offline.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_updateStatus) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_reportPeer struct implement
type TLaccount_reportPeer struct {
	Peer   InputPeer    `json:"peer"`
	Reason ReportReason `json:"reason"`
}

func (st *TLaccount_reportPeer) ResetDefault() {
	st.Peer.ResetDefault()
	st.Reason.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_reportPeer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Reason.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_reportPeer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_reportPeer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_reportPeer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Reason.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_reportPeer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_deleteByPhones struct implement
type TLcontacts_deleteByPhones struct {
	Phones []string `json:"phones"`
}

func (st *TLcontacts_deleteByPhones) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_deleteByPhones) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Phones = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_string(&st.Phones[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_deleteByPhones) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_deleteByPhones, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_deleteByPhones) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Phones)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Phones {

		err = _os.Write_string(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_deleteByPhones) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_block struct implement
type TLcontacts_block struct {
	Id InputPeer `json:"id"`
}

func (st *TLcontacts_block) ResetDefault() {
	st.Id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_block) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_block) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_block, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_block) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_block) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_unblock struct implement
type TLcontacts_unblock struct {
	Id InputPeer `json:"id"`
}

func (st *TLcontacts_unblock) ResetDefault() {
	st.Id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_unblock) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_unblock) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_unblock, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_unblock) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_unblock) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_setTyping struct implement
type TLmessages_setTyping struct {
	Peer       InputPeer         `json:"peer"`
	Top_msg_id int32             `json:"top_msg_id"`
	Action     SendMessageAction `json:"action"`
}

func (st *TLmessages_setTyping) ResetDefault() {
	st.Peer.ResetDefault()
	st.Action.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_setTyping) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Top_msg_id, 1, false)
	if err != nil {
		return err
	}

	err = st.Action.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_setTyping) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_setTyping, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_setTyping) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Top_msg_id, 1)
	if err != nil {
		return err
	}

	err = st.Action.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_setTyping) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_reportSpam struct implement
type TLmessages_reportSpam struct {
	Peer InputPeer `json:"peer"`
}

func (st *TLmessages_reportSpam) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_reportSpam) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_reportSpam) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_reportSpam, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_reportSpam) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_reportSpam) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_report struct implement
type TLmessages_report struct {
	Peer   InputPeer    `json:"peer"`
	Id     []int32      `json:"id"`
	Reason ReportReason `json:"reason"`
}

func (st *TLmessages_report) ResetDefault() {
	st.Peer.ResetDefault()
	st.Reason.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_report) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Reason.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_report) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_report, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_report) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	err = st.Reason.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_report) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupload_saveFilePart struct implement
type TLupload_saveFilePart struct {
	File_id   int64   `json:"file_id"`
	File_part int32   `json:"file_part"`
	Bytes     []uint8 `json:"bytes"`
}

func (st *TLupload_saveFilePart) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupload_saveFilePart) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.File_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.File_part, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Bytes = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Bytes[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Bytes, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupload_saveFilePart) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupload_saveFilePart, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupload_saveFilePart) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.File_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.File_part, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Bytes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Bytes {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupload_saveFilePart) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_discardEncryption struct implement
type TLmessages_discardEncryption struct {
	Chat_id int32 `json:"chat_id"`
}

func (st *TLmessages_discardEncryption) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_discardEncryption) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Chat_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_discardEncryption) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_discardEncryption, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_discardEncryption) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Chat_id, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_discardEncryption) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_setEncryptedTyping struct implement
type TLmessages_setEncryptedTyping struct {
	Peer   InputEncryptedChat `json:"peer"`
	Typing Bool               `json:"typing"`
}

func (st *TLmessages_setEncryptedTyping) ResetDefault() {
	st.Peer.ResetDefault()
	st.Typing.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_setEncryptedTyping) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Typing.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_setEncryptedTyping) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_setEncryptedTyping, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_setEncryptedTyping) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Typing.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_setEncryptedTyping) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_readEncryptedHistory struct implement
type TLmessages_readEncryptedHistory struct {
	Peer     InputEncryptedChat `json:"peer"`
	Max_date int32              `json:"max_date"`
}

func (st *TLmessages_readEncryptedHistory) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_readEncryptedHistory) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_date, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_readEncryptedHistory) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_readEncryptedHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_readEncryptedHistory) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_date, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_readEncryptedHistory) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_reportEncryptedSpam struct implement
type TLmessages_reportEncryptedSpam struct {
	Peer InputEncryptedChat `json:"peer"`
}

func (st *TLmessages_reportEncryptedSpam) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_reportEncryptedSpam) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_reportEncryptedSpam) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_reportEncryptedSpam, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_reportEncryptedSpam) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_reportEncryptedSpam) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupload_saveBigFilePart struct implement
type TLupload_saveBigFilePart struct {
	File_id          int64   `json:"file_id"`
	File_part        int32   `json:"file_part"`
	File_total_parts int32   `json:"file_total_parts"`
	Bytes            []uint8 `json:"bytes"`
}

func (st *TLupload_saveBigFilePart) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupload_saveBigFilePart) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.File_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.File_part, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.File_total_parts, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Bytes = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Bytes[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Bytes, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupload_saveBigFilePart) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupload_saveBigFilePart, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupload_saveBigFilePart) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.File_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.File_part, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.File_total_parts, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Bytes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Bytes {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupload_saveBigFilePart) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_checkUsername struct implement
type TLaccount_checkUsername struct {
	Username string `json:"username"`
}

func (st *TLaccount_checkUsername) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_checkUsername) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Username, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_checkUsername) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_checkUsername, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_checkUsername) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Username, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_checkUsername) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_deleteAccount struct implement
type TLaccount_deleteAccount struct {
	Reason string `json:"reason"`
}

func (st *TLaccount_deleteAccount) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_deleteAccount) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Reason, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_deleteAccount) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_deleteAccount, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_deleteAccount) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Reason, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_deleteAccount) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_setAccountTTL struct implement
type TLaccount_setAccountTTL struct {
	Ttl AccountDaysTTL `json:"ttl"`
}

func (st *TLaccount_setAccountTTL) ResetDefault() {
	st.Ttl.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_setAccountTTL) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Ttl.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_setAccountTTL) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_setAccountTTL, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_setAccountTTL) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Ttl.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_setAccountTTL) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_updateDeviceLocked struct implement
type TLaccount_updateDeviceLocked struct {
	Period int32 `json:"period"`
}

func (st *TLaccount_updateDeviceLocked) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_updateDeviceLocked) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Period, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_updateDeviceLocked) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_updateDeviceLocked, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_updateDeviceLocked) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Period, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_updateDeviceLocked) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_resetAuthorization struct implement
type TLaccount_resetAuthorization struct {
	Hash int64 `json:"hash"`
}

func (st *TLaccount_resetAuthorization) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_resetAuthorization) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_resetAuthorization) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_resetAuthorization, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_resetAuthorization) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Hash, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_resetAuthorization) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_updatePasswordSettings struct implement
type TLaccount_updatePasswordSettings struct {
	Password     InputCheckPasswordSRP         `json:"password"`
	New_settings Account_PasswordInputSettings `json:"new_settings"`
}

func (st *TLaccount_updatePasswordSettings) ResetDefault() {
	st.Password.ResetDefault()
	st.New_settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_updatePasswordSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Password.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.New_settings.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_updatePasswordSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_updatePasswordSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_updatePasswordSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Password.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.New_settings.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_updatePasswordSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_uninstallStickerSet struct implement
type TLmessages_uninstallStickerSet struct {
	Stickerset InputStickerSet `json:"stickerset"`
}

func (st *TLmessages_uninstallStickerSet) ResetDefault() {
	st.Stickerset.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_uninstallStickerSet) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Stickerset.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_uninstallStickerSet) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_uninstallStickerSet, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_uninstallStickerSet) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Stickerset.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_uninstallStickerSet) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_readHistory struct implement
type TLchannels_readHistory struct {
	Channel InputChannel `json:"channel"`
	Max_id  int32        `json:"max_id"`
}

func (st *TLchannels_readHistory) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_readHistory) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_readHistory) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_readHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_readHistory) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_readHistory) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_reportSpam struct implement
type TLchannels_reportSpam struct {
	Channel InputChannel `json:"channel"`
	User_id InputUser    `json:"user_id"`
	Id      []int32      `json:"id"`
}

func (st *TLchannels_reportSpam) ResetDefault() {
	st.Channel.ResetDefault()
	st.User_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_reportSpam) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.User_id.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_reportSpam) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_reportSpam, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_reportSpam) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.User_id.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_reportSpam) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_checkUsername struct implement
type TLchannels_checkUsername struct {
	Channel  InputChannel `json:"channel"`
	Username string       `json:"username"`
}

func (st *TLchannels_checkUsername) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_checkUsername) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Username, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_checkUsername) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_checkUsername, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_checkUsername) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Username, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_checkUsername) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_updateUsername struct implement
type TLchannels_updateUsername struct {
	Channel  InputChannel `json:"channel"`
	Username string       `json:"username"`
}

func (st *TLchannels_updateUsername) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_updateUsername) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Username, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_updateUsername) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_updateUsername, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_updateUsername) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Username, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_updateUsername) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_editChatAdmin struct implement
type TLmessages_editChatAdmin struct {
	Chat_id  int32     `json:"chat_id"`
	User_id  InputUser `json:"user_id"`
	Is_admin Bool      `json:"is_admin"`
}

func (st *TLmessages_editChatAdmin) ResetDefault() {
	st.User_id.ResetDefault()
	st.Is_admin.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_editChatAdmin) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Chat_id, 0, false)
	if err != nil {
		return err
	}

	err = st.User_id.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.Is_admin.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_editChatAdmin) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_editChatAdmin, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_editChatAdmin) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Chat_id, 0)
	if err != nil {
		return err
	}

	err = st.User_id.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.Is_admin.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_editChatAdmin) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_reorderStickerSets struct implement
type TLmessages_reorderStickerSets struct {
	Masks bool    `json:"masks"`
	Order []int64 `json:"order"`
}

func (st *TLmessages_reorderStickerSets) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_reorderStickerSets) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Masks, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Order = make([]int64, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int64(&st.Order[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_reorderStickerSets) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_reorderStickerSets, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_reorderStickerSets) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Masks, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Order)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Order {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_reorderStickerSets) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_saveGif struct implement
type TLmessages_saveGif struct {
	Id     InputDocument `json:"id"`
	Unsave Bool          `json:"unsave"`
}

func (st *TLmessages_saveGif) ResetDefault() {
	st.Id.ResetDefault()
	st.Unsave.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_saveGif) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Unsave.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_saveGif) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_saveGif, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_saveGif) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Unsave.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_saveGif) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_setInlineBotResults struct implement
type TLmessages_setInlineBotResults struct {
	Gallery     bool                   `json:"gallery"`
	Private     bool                   `json:"private"`
	Query_id    int64                  `json:"query_id"`
	Results     []InputBotInlineResult `json:"results"`
	Cache_time  int32                  `json:"cache_time"`
	Next_offset string                 `json:"next_offset"`
	Switch_pm   InlineBotSwitchPM      `json:"switch_pm"`
}

func (st *TLmessages_setInlineBotResults) ResetDefault() {
	st.Switch_pm.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_setInlineBotResults) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Gallery, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Private, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Query_id, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Results = make([]InputBotInlineResult, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Results[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Cache_time, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Next_offset, 5, false)
	if err != nil {
		return err
	}

	err = st.Switch_pm.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_setInlineBotResults) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_setInlineBotResults, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_setInlineBotResults) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Gallery, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Private, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Query_id, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Results)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Results {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Cache_time, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Next_offset, 5)
	if err != nil {
		return err
	}

	err = st.Switch_pm.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_setInlineBotResults) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_cancelCode struct implement
type TLauth_cancelCode struct {
	Phone_number    string `json:"phone_number"`
	Phone_code_hash string `json:"phone_code_hash"`
}

func (st *TLauth_cancelCode) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_cancelCode) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Phone_number, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone_code_hash, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_cancelCode) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_cancelCode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_cancelCode) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Phone_number, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone_code_hash, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_cancelCode) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_editInlineBotMessage struct implement
type TLmessages_editInlineBotMessage struct {
	No_webpage   bool                    `json:"no_webpage"`
	Id           InputBotInlineMessageID `json:"id"`
	Message      string                  `json:"message"`
	Media        InputMedia              `json:"media"`
	Reply_markup ReplyMarkup             `json:"reply_markup"`
	Entities     []MessageEntity         `json:"entities"`
}

func (st *TLmessages_editInlineBotMessage) ResetDefault() {
	st.Id.ResetDefault()
	st.Media.ResetDefault()
	st.Reply_markup.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_editInlineBotMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.No_webpage, 0, false)
	if err != nil {
		return err
	}

	err = st.Id.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 2, false)
	if err != nil {
		return err
	}

	err = st.Media.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = st.Reply_markup.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_editInlineBotMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_editInlineBotMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_editInlineBotMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.No_webpage, 0)
	if err != nil {
		return err
	}

	err = st.Id.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 2)
	if err != nil {
		return err
	}

	err = st.Media.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = st.Reply_markup.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_editInlineBotMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_setBotCallbackAnswer struct implement
type TLmessages_setBotCallbackAnswer struct {
	Alert      bool   `json:"alert"`
	Query_id   int64  `json:"query_id"`
	Message    string `json:"message"`
	Url        string `json:"url"`
	Cache_time int32  `json:"cache_time"`
}

func (st *TLmessages_setBotCallbackAnswer) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_setBotCallbackAnswer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Alert, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Query_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Url, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Cache_time, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_setBotCallbackAnswer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_setBotCallbackAnswer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_setBotCallbackAnswer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Alert, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Query_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Url, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Cache_time, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_setBotCallbackAnswer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_resetTopPeerRating struct implement
type TLcontacts_resetTopPeerRating struct {
	Category TopPeerCategory `json:"category"`
	Peer     InputPeer       `json:"peer"`
}

func (st *TLcontacts_resetTopPeerRating) ResetDefault() {
	st.Category.ResetDefault()
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_resetTopPeerRating) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Category.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_resetTopPeerRating) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_resetTopPeerRating, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_resetTopPeerRating) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Category.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_resetTopPeerRating) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_saveDraft struct implement
type TLmessages_saveDraft struct {
	No_webpage      bool            `json:"no_webpage"`
	Reply_to_msg_id int32           `json:"reply_to_msg_id"`
	Peer            InputPeer       `json:"peer"`
	Message         string          `json:"message"`
	Entities        []MessageEntity `json:"entities"`
}

func (st *TLmessages_saveDraft) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_saveDraft) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.No_webpage, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Reply_to_msg_id, 1, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 3, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_saveDraft) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_saveDraft, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_saveDraft) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.No_webpage, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Reply_to_msg_id, 1)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 3)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_saveDraft) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_readFeaturedStickers struct implement
type TLmessages_readFeaturedStickers struct {
	Id []int64 `json:"id"`
}

func (st *TLmessages_readFeaturedStickers) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_readFeaturedStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]int64, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int64(&st.Id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_readFeaturedStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_readFeaturedStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_readFeaturedStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_readFeaturedStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_saveRecentSticker struct implement
type TLmessages_saveRecentSticker struct {
	Attached bool          `json:"attached"`
	Id       InputDocument `json:"id"`
	Unsave   Bool          `json:"unsave"`
}

func (st *TLmessages_saveRecentSticker) ResetDefault() {
	st.Id.ResetDefault()
	st.Unsave.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_saveRecentSticker) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Attached, 0, false)
	if err != nil {
		return err
	}

	err = st.Id.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.Unsave.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_saveRecentSticker) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_saveRecentSticker, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_saveRecentSticker) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Attached, 0)
	if err != nil {
		return err
	}

	err = st.Id.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.Unsave.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_saveRecentSticker) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_clearRecentStickers struct implement
type TLmessages_clearRecentStickers struct {
	Attached bool `json:"attached"`
}

func (st *TLmessages_clearRecentStickers) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_clearRecentStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Attached, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_clearRecentStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_clearRecentStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_clearRecentStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Attached, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_clearRecentStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_confirmPhone struct implement
type TLaccount_confirmPhone struct {
	Phone_code_hash string `json:"phone_code_hash"`
	Phone_code      string `json:"phone_code"`
}

func (st *TLaccount_confirmPhone) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_confirmPhone) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Phone_code_hash, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone_code, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_confirmPhone) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_confirmPhone, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_confirmPhone) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Phone_code_hash, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone_code, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_confirmPhone) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_dropTempAuthKeys struct implement
type TLauth_dropTempAuthKeys struct {
	Except_auth_keys []int64 `json:"except_auth_keys"`
}

func (st *TLauth_dropTempAuthKeys) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_dropTempAuthKeys) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Except_auth_keys = make([]int64, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int64(&st.Except_auth_keys[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_dropTempAuthKeys) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_dropTempAuthKeys, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_dropTempAuthKeys) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Except_auth_keys)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Except_auth_keys {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_dropTempAuthKeys) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_setInlineGameScore struct implement
type TLmessages_setInlineGameScore struct {
	Edit_message bool                    `json:"edit_message"`
	Force        bool                    `json:"force"`
	Id           InputBotInlineMessageID `json:"id"`
	User_id      InputUser               `json:"user_id"`
	Score        int32                   `json:"score"`
}

func (st *TLmessages_setInlineGameScore) ResetDefault() {
	st.Id.ResetDefault()
	st.User_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_setInlineGameScore) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Edit_message, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Force, 1, false)
	if err != nil {
		return err
	}

	err = st.Id.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = st.User_id.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Score, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_setInlineGameScore) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_setInlineGameScore, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_setInlineGameScore) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Edit_message, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Force, 1)
	if err != nil {
		return err
	}

	err = st.Id.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = st.User_id.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Score, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_setInlineGameScore) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_setBotUpdatesStatus struct implement
type TLhelp_setBotUpdatesStatus struct {
	Pending_updates_count int32  `json:"pending_updates_count"`
	Message               string `json:"message"`
}

func (st *TLhelp_setBotUpdatesStatus) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_setBotUpdatesStatus) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Pending_updates_count, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_setBotUpdatesStatus) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_setBotUpdatesStatus, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_setBotUpdatesStatus) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Pending_updates_count, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_setBotUpdatesStatus) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_toggleDialogPin struct implement
type TLmessages_toggleDialogPin struct {
	Pinned bool            `json:"pinned"`
	Peer   InputDialogPeer `json:"peer"`
}

func (st *TLmessages_toggleDialogPin) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_toggleDialogPin) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Pinned, 0, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_toggleDialogPin) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_toggleDialogPin, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_toggleDialogPin) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Pinned, 0)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_toggleDialogPin) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_reorderPinnedDialogs struct implement
type TLmessages_reorderPinnedDialogs struct {
	Force     bool              `json:"force"`
	Folder_id int32             `json:"folder_id"`
	Order     []InputDialogPeer `json:"order"`
}

func (st *TLmessages_reorderPinnedDialogs) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_reorderPinnedDialogs) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Force, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Folder_id, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Order = make([]InputDialogPeer, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Order[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_reorderPinnedDialogs) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_reorderPinnedDialogs, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_reorderPinnedDialogs) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Force, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Folder_id, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Order)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Order {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_reorderPinnedDialogs) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbots_answerWebhookJSONQuery struct implement
type TLbots_answerWebhookJSONQuery struct {
	Query_id int64    `json:"query_id"`
	Data     DataJSON `json:"data"`
}

func (st *TLbots_answerWebhookJSONQuery) ResetDefault() {
	st.Data.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbots_answerWebhookJSONQuery) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Query_id, 0, false)
	if err != nil {
		return err
	}

	err = st.Data.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbots_answerWebhookJSONQuery) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbots_answerWebhookJSONQuery, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbots_answerWebhookJSONQuery) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Query_id, 0)
	if err != nil {
		return err
	}

	err = st.Data.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbots_answerWebhookJSONQuery) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpayments_clearSavedInfo struct implement
type TLpayments_clearSavedInfo struct {
	Credentials bool `json:"credentials"`
	Info        bool `json:"info"`
}

func (st *TLpayments_clearSavedInfo) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpayments_clearSavedInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Credentials, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Info, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpayments_clearSavedInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpayments_clearSavedInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpayments_clearSavedInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Credentials, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Info, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpayments_clearSavedInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_setBotShippingResults struct implement
type TLmessages_setBotShippingResults struct {
	Query_id         int64            `json:"query_id"`
	Error            string           `json:"error"`
	Shipping_options []ShippingOption `json:"shipping_options"`
}

func (st *TLmessages_setBotShippingResults) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_setBotShippingResults) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Query_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Error, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Shipping_options = make([]ShippingOption, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Shipping_options[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_setBotShippingResults) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_setBotShippingResults, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_setBotShippingResults) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Query_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Error, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Shipping_options)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Shipping_options {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_setBotShippingResults) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_setBotPrecheckoutResults struct implement
type TLmessages_setBotPrecheckoutResults struct {
	Success  bool   `json:"success"`
	Query_id int64  `json:"query_id"`
	Error    string `json:"error"`
}

func (st *TLmessages_setBotPrecheckoutResults) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_setBotPrecheckoutResults) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Success, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Query_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Error, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_setBotPrecheckoutResults) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_setBotPrecheckoutResults, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_setBotPrecheckoutResults) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Success, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Query_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Error, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_setBotPrecheckoutResults) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphone_receivedCall struct implement
type TLphone_receivedCall struct {
	Peer InputPhoneCall `json:"peer"`
}

func (st *TLphone_receivedCall) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphone_receivedCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphone_receivedCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphone_receivedCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphone_receivedCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphone_receivedCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphone_saveCallDebug struct implement
type TLphone_saveCallDebug struct {
	Peer  InputPhoneCall `json:"peer"`
	Debug DataJSON       `json:"debug"`
}

func (st *TLphone_saveCallDebug) ResetDefault() {
	st.Peer.ResetDefault()
	st.Debug.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphone_saveCallDebug) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Debug.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphone_saveCallDebug) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphone_saveCallDebug, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphone_saveCallDebug) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Debug.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphone_saveCallDebug) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_setStickers struct implement
type TLchannels_setStickers struct {
	Channel    InputChannel    `json:"channel"`
	Stickerset InputStickerSet `json:"stickerset"`
}

func (st *TLchannels_setStickers) ResetDefault() {
	st.Channel.ResetDefault()
	st.Stickerset.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_setStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Stickerset.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_setStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_setStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_setStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Stickerset.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_setStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_faveSticker struct implement
type TLmessages_faveSticker struct {
	Id     InputDocument `json:"id"`
	Unfave Bool          `json:"unfave"`
}

func (st *TLmessages_faveSticker) ResetDefault() {
	st.Id.ResetDefault()
	st.Unfave.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_faveSticker) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Unfave.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_faveSticker) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_faveSticker, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_faveSticker) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Unfave.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_faveSticker) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_readMessageContents struct implement
type TLchannels_readMessageContents struct {
	Channel InputChannel `json:"channel"`
	Id      []int32      `json:"id"`
}

func (st *TLchannels_readMessageContents) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_readMessageContents) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_readMessageContents) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_readMessageContents, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_readMessageContents) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_readMessageContents) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_resetSaved struct implement
type TLcontacts_resetSaved struct {
}

func (st *TLcontacts_resetSaved) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_resetSaved) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_resetSaved) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_resetSaved, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_resetSaved) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_resetSaved) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_deleteHistory struct implement
type TLchannels_deleteHistory struct {
	Channel InputChannel `json:"channel"`
	Max_id  int32        `json:"max_id"`
}

func (st *TLchannels_deleteHistory) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_deleteHistory) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_deleteHistory) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_deleteHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_deleteHistory) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_deleteHistory) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_resetWebAuthorization struct implement
type TLaccount_resetWebAuthorization struct {
	Hash int64 `json:"hash"`
}

func (st *TLaccount_resetWebAuthorization) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_resetWebAuthorization) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int64(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_resetWebAuthorization) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_resetWebAuthorization, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_resetWebAuthorization) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int64(st.Hash, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_resetWebAuthorization) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_resetWebAuthorizations struct implement
type TLaccount_resetWebAuthorizations struct {
}

func (st *TLaccount_resetWebAuthorizations) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_resetWebAuthorizations) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_resetWebAuthorizations) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_resetWebAuthorizations, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_resetWebAuthorizations) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_resetWebAuthorizations) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_acceptTermsOfService struct implement
type TLhelp_acceptTermsOfService struct {
	Id DataJSON `json:"id"`
}

func (st *TLhelp_acceptTermsOfService) ResetDefault() {
	st.Id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_acceptTermsOfService) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_acceptTermsOfService) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_acceptTermsOfService, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_acceptTermsOfService) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_acceptTermsOfService) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_deleteSecureValue struct implement
type TLaccount_deleteSecureValue struct {
	Types []SecureValueType `json:"types"`
}

func (st *TLaccount_deleteSecureValue) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_deleteSecureValue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Types = make([]SecureValueType, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Types[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_deleteSecureValue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_deleteSecureValue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_deleteSecureValue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Types)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Types {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_deleteSecureValue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLusers_setSecureValueErrors struct implement
type TLusers_setSecureValueErrors struct {
	Id     InputUser          `json:"id"`
	Errors []SecureValueError `json:"errors"`
}

func (st *TLusers_setSecureValueErrors) ResetDefault() {
	st.Id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLusers_setSecureValueErrors) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Errors = make([]SecureValueError, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Errors[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLusers_setSecureValueErrors) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLusers_setSecureValueErrors, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLusers_setSecureValueErrors) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Errors)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Errors {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLusers_setSecureValueErrors) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_acceptAuthorization struct implement
type TLaccount_acceptAuthorization struct {
	Bot_id       int32                      `json:"bot_id"`
	Scope        string                     `json:"scope"`
	Public_key   string                     `json:"public_key"`
	Value_hashes []SecureValueHash          `json:"value_hashes"`
	Credentials  SecureCredentialsEncrypted `json:"credentials"`
}

func (st *TLaccount_acceptAuthorization) ResetDefault() {
	st.Credentials.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_acceptAuthorization) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Bot_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Scope, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Public_key, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Value_hashes = make([]SecureValueHash, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Value_hashes[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Credentials.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_acceptAuthorization) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_acceptAuthorization, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_acceptAuthorization) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Bot_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Scope, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Public_key, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Value_hashes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Value_hashes {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = st.Credentials.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_acceptAuthorization) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_verifyPhone struct implement
type TLaccount_verifyPhone struct {
	Phone_number    string `json:"phone_number"`
	Phone_code_hash string `json:"phone_code_hash"`
	Phone_code      string `json:"phone_code"`
}

func (st *TLaccount_verifyPhone) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_verifyPhone) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Phone_number, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone_code_hash, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone_code, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_verifyPhone) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_verifyPhone, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_verifyPhone) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Phone_number, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone_code_hash, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone_code, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_verifyPhone) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_verifyEmail struct implement
type TLaccount_verifyEmail struct {
	Email string `json:"email"`
	Code  string `json:"code"`
}

func (st *TLaccount_verifyEmail) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_verifyEmail) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Email, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Code, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_verifyEmail) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_verifyEmail, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_verifyEmail) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Email, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Code, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_verifyEmail) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_finishTakeoutSession struct implement
type TLaccount_finishTakeoutSession struct {
	Success bool `json:"success"`
}

func (st *TLaccount_finishTakeoutSession) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_finishTakeoutSession) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Success, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_finishTakeoutSession) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_finishTakeoutSession, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_finishTakeoutSession) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Success, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_finishTakeoutSession) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_markDialogUnread struct implement
type TLmessages_markDialogUnread struct {
	Unread bool            `json:"unread"`
	Peer   InputDialogPeer `json:"peer"`
}

func (st *TLmessages_markDialogUnread) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_markDialogUnread) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Unread, 0, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_markDialogUnread) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_markDialogUnread, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_markDialogUnread) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Unread, 0)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_markDialogUnread) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_toggleTopPeers struct implement
type TLcontacts_toggleTopPeers struct {
	Enabled Bool `json:"enabled"`
}

func (st *TLcontacts_toggleTopPeers) ResetDefault() {
	st.Enabled.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_toggleTopPeers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Enabled.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_toggleTopPeers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_toggleTopPeers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_toggleTopPeers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Enabled.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_toggleTopPeers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_clearAllDrafts struct implement
type TLmessages_clearAllDrafts struct {
}

func (st *TLmessages_clearAllDrafts) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_clearAllDrafts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_clearAllDrafts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_clearAllDrafts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_clearAllDrafts) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_clearAllDrafts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_saveAppLog struct implement
type TLhelp_saveAppLog struct {
	Events []InputAppEvent `json:"events"`
}

func (st *TLhelp_saveAppLog) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_saveAppLog) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Events = make([]InputAppEvent, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Events[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_saveAppLog) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_saveAppLog, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_saveAppLog) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Events)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Events {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_saveAppLog) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_confirmPasswordEmail struct implement
type TLaccount_confirmPasswordEmail struct {
	Code string `json:"code"`
}

func (st *TLaccount_confirmPasswordEmail) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_confirmPasswordEmail) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Code, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_confirmPasswordEmail) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_confirmPasswordEmail, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_confirmPasswordEmail) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Code, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_confirmPasswordEmail) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_resendPasswordEmail struct implement
type TLaccount_resendPasswordEmail struct {
}

func (st *TLaccount_resendPasswordEmail) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_resendPasswordEmail) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_resendPasswordEmail) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_resendPasswordEmail, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_resendPasswordEmail) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_resendPasswordEmail) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_cancelPasswordEmail struct implement
type TLaccount_cancelPasswordEmail struct {
}

func (st *TLaccount_cancelPasswordEmail) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_cancelPasswordEmail) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_cancelPasswordEmail) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_cancelPasswordEmail, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_cancelPasswordEmail) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_cancelPasswordEmail) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getContactSignUpNotification struct implement
type TLaccount_getContactSignUpNotification struct {
}

func (st *TLaccount_getContactSignUpNotification) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getContactSignUpNotification) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getContactSignUpNotification) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getContactSignUpNotification, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getContactSignUpNotification) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getContactSignUpNotification) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_setContactSignUpNotification struct implement
type TLaccount_setContactSignUpNotification struct {
	Silent Bool `json:"silent"`
}

func (st *TLaccount_setContactSignUpNotification) ResetDefault() {
	st.Silent.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_setContactSignUpNotification) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Silent.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_setContactSignUpNotification) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_setContactSignUpNotification, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_setContactSignUpNotification) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Silent.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_setContactSignUpNotification) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_editChatAbout struct implement
type TLmessages_editChatAbout struct {
	Peer  InputPeer `json:"peer"`
	About string    `json:"about"`
}

func (st *TLmessages_editChatAbout) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_editChatAbout) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.About, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_editChatAbout) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_editChatAbout, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_editChatAbout) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.About, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_editChatAbout) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_saveWallPaper struct implement
type TLaccount_saveWallPaper struct {
	Wallpaper InputWallPaper    `json:"wallpaper"`
	Unsave    Bool              `json:"unsave"`
	Settings  WallPaperSettings `json:"settings"`
}

func (st *TLaccount_saveWallPaper) ResetDefault() {
	st.Wallpaper.ResetDefault()
	st.Unsave.ResetDefault()
	st.Settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_saveWallPaper) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Wallpaper.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Unsave.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.Settings.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_saveWallPaper) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_saveWallPaper, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_saveWallPaper) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Wallpaper.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Unsave.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.Settings.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_saveWallPaper) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_installWallPaper struct implement
type TLaccount_installWallPaper struct {
	Wallpaper InputWallPaper    `json:"wallpaper"`
	Settings  WallPaperSettings `json:"settings"`
}

func (st *TLaccount_installWallPaper) ResetDefault() {
	st.Wallpaper.ResetDefault()
	st.Settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_installWallPaper) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Wallpaper.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Settings.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_installWallPaper) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_installWallPaper, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_installWallPaper) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Wallpaper.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Settings.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_installWallPaper) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_resetWallPapers struct implement
type TLaccount_resetWallPapers struct {
}

func (st *TLaccount_resetWallPapers) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_resetWallPapers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_resetWallPapers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_resetWallPapers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_resetWallPapers) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_resetWallPapers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_saveAutoDownloadSettings struct implement
type TLaccount_saveAutoDownloadSettings struct {
	Low      bool                 `json:"low"`
	High     bool                 `json:"high"`
	Settings AutoDownloadSettings `json:"settings"`
}

func (st *TLaccount_saveAutoDownloadSettings) ResetDefault() {
	st.Settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_saveAutoDownloadSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Low, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.High, 1, false)
	if err != nil {
		return err
	}

	err = st.Settings.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_saveAutoDownloadSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_saveAutoDownloadSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_saveAutoDownloadSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Low, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.High, 1)
	if err != nil {
		return err
	}

	err = st.Settings.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_saveAutoDownloadSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_setDiscussionGroup struct implement
type TLchannels_setDiscussionGroup struct {
	Broadcast InputChannel `json:"broadcast"`
	Group     InputChannel `json:"group"`
}

func (st *TLchannels_setDiscussionGroup) ResetDefault() {
	st.Broadcast.ResetDefault()
	st.Group.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_setDiscussionGroup) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Broadcast.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Group.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_setDiscussionGroup) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_setDiscussionGroup, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_setDiscussionGroup) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Broadcast.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Group.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_setDiscussionGroup) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_hidePeerSettingsBar struct implement
type TLmessages_hidePeerSettingsBar struct {
	Peer InputPeer `json:"peer"`
}

func (st *TLmessages_hidePeerSettingsBar) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_hidePeerSettingsBar) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_hidePeerSettingsBar) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_hidePeerSettingsBar, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_hidePeerSettingsBar) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_hidePeerSettingsBar) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_editLocation struct implement
type TLchannels_editLocation struct {
	Channel   InputChannel  `json:"channel"`
	Geo_point InputGeoPoint `json:"geo_point"`
	Address   string        `json:"address"`
}

func (st *TLchannels_editLocation) ResetDefault() {
	st.Channel.ResetDefault()
	st.Geo_point.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_editLocation) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Geo_point.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Address, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_editLocation) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_editLocation, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_editLocation) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Geo_point.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Address, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_editLocation) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_saveTheme struct implement
type TLaccount_saveTheme struct {
	Theme  InputTheme `json:"theme"`
	Unsave Bool       `json:"unsave"`
}

func (st *TLaccount_saveTheme) ResetDefault() {
	st.Theme.ResetDefault()
	st.Unsave.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_saveTheme) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Theme.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Unsave.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_saveTheme) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_saveTheme, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_saveTheme) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Theme.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Unsave.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_saveTheme) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_installTheme struct implement
type TLaccount_installTheme struct {
	Dark   bool       `json:"dark"`
	Format string     `json:"format"`
	Theme  InputTheme `json:"theme"`
}

func (st *TLaccount_installTheme) ResetDefault() {
	st.Theme.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_installTheme) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Dark, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Format, 1, false)
	if err != nil {
		return err
	}

	err = st.Theme.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_installTheme) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_installTheme, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_installTheme) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Dark, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Format, 1)
	if err != nil {
		return err
	}

	err = st.Theme.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_installTheme) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_setContentSettings struct implement
type TLaccount_setContentSettings struct {
	Sensitive_enabled bool `json:"sensitive_enabled"`
}

func (st *TLaccount_setContentSettings) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_setContentSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Sensitive_enabled, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_setContentSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_setContentSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_setContentSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Sensitive_enabled, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_setContentSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_toggleStickerSets struct implement
type TLmessages_toggleStickerSets struct {
	Uninstall   bool              `json:"uninstall"`
	Archive     bool              `json:"archive"`
	Unarchive   bool              `json:"unarchive"`
	Stickersets []InputStickerSet `json:"stickersets"`
}

func (st *TLmessages_toggleStickerSets) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_toggleStickerSets) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Uninstall, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Archive, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Unarchive, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Stickersets = make([]InputStickerSet, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Stickersets[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_toggleStickerSets) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_toggleStickerSets, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_toggleStickerSets) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Uninstall, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Archive, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Unarchive, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Stickersets)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Stickersets {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_toggleStickerSets) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_updateDialogFilter struct implement
type TLmessages_updateDialogFilter struct {
	Id     int32        `json:"id"`
	Filter DialogFilter `json:"filter"`
}

func (st *TLmessages_updateDialogFilter) ResetDefault() {
	st.Filter.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_updateDialogFilter) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = st.Filter.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_updateDialogFilter) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_updateDialogFilter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_updateDialogFilter) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Id, 0)
	if err != nil {
		return err
	}

	err = st.Filter.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_updateDialogFilter) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_updateDialogFiltersOrder struct implement
type TLmessages_updateDialogFiltersOrder struct {
	Order []int32 `json:"order"`
}

func (st *TLmessages_updateDialogFiltersOrder) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_updateDialogFiltersOrder) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Order = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Order[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_updateDialogFiltersOrder) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_updateDialogFiltersOrder, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_updateDialogFiltersOrder) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Order)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Order {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_updateDialogFiltersOrder) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbots_setBotCommands struct implement
type TLbots_setBotCommands struct {
	Commands []BotCommand `json:"commands"`
}

func (st *TLbots_setBotCommands) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbots_setBotCommands) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Commands = make([]BotCommand, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Commands[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbots_setBotCommands) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbots_setBotCommands, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbots_setBotCommands) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Commands)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Commands {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbots_setBotCommands) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_hidePromoData struct implement
type TLhelp_hidePromoData struct {
	Peer InputPeer `json:"peer"`
}

func (st *TLhelp_hidePromoData) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_hidePromoData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_hidePromoData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_hidePromoData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_hidePromoData) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_hidePromoData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphone_sendSignalingData struct implement
type TLphone_sendSignalingData struct {
	Peer InputPhoneCall `json:"peer"`
	Data []uint8        `json:"data"`
}

func (st *TLphone_sendSignalingData) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphone_sendSignalingData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Data = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Data[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Data, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphone_sendSignalingData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphone_sendSignalingData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphone_sendSignalingData) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Data)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Data {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphone_sendSignalingData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_dismissSuggestion struct implement
type TLhelp_dismissSuggestion struct {
	Suggestion string `json:"suggestion"`
}

func (st *TLhelp_dismissSuggestion) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_dismissSuggestion) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Suggestion, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_dismissSuggestion) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_dismissSuggestion, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_dismissSuggestion) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Suggestion, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_dismissSuggestion) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_readDiscussion struct implement
type TLmessages_readDiscussion struct {
	Peer        InputPeer `json:"peer"`
	Msg_id      int32     `json:"msg_id"`
	Read_max_id int32     `json:"read_max_id"`
}

func (st *TLmessages_readDiscussion) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_readDiscussion) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Msg_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Read_max_id, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_readDiscussion) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_readDiscussion, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_readDiscussion) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Msg_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Read_max_id, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_readDiscussion) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_getInviteText struct implement
type TLhelp_getInviteText struct {
}

func (st *TLhelp_getInviteText) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_getInviteText) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_getInviteText) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_getInviteText, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_getInviteText) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_getInviteText) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLusers_getUsers struct implement
type TLusers_getUsers struct {
	Id []InputUser `json:"id"`
}

func (st *TLusers_getUsers) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLusers_getUsers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]InputUser, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Id[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLusers_getUsers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLusers_getUsers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLusers_getUsers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLusers_getUsers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getBotCallbackAnswer struct implement
type TLmessages_getBotCallbackAnswer struct {
	Game     bool                  `json:"game"`
	Peer     InputPeer             `json:"peer"`
	Msg_id   int32                 `json:"msg_id"`
	Data     []uint8               `json:"data"`
	Password InputCheckPasswordSRP `json:"password"`
}

func (st *TLmessages_getBotCallbackAnswer) ResetDefault() {
	st.Peer.ResetDefault()
	st.Password.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getBotCallbackAnswer) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Game, 0, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Msg_id, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Data = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Data[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Data, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Password.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getBotCallbackAnswer) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getBotCallbackAnswer, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getBotCallbackAnswer) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Game, 0)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Msg_id, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Data)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Data {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = st.Password.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getBotCallbackAnswer) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getPollVotes struct implement
type TLmessages_getPollVotes struct {
	Peer   InputPeer `json:"peer"`
	Id     int32     `json:"id"`
	Option []uint8   `json:"option"`
	Offset string    `json:"offset"`
	Limit  int32     `json:"limit"`
}

func (st *TLmessages_getPollVotes) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getPollVotes) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Id, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Option = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Option[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Option, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_string(&st.Offset, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getPollVotes) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getPollVotes, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getPollVotes) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Id, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Option)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Option {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_string(st.Offset, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getPollVotes) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_receivedMessages struct implement
type TLmessages_receivedMessages struct {
	Max_id int32 `json:"max_id"`
}

func (st *TLmessages_receivedMessages) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_receivedMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Max_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_receivedMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_receivedMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_receivedMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Max_id, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_receivedMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_getParticipants struct implement
type TLchannels_getParticipants struct {
	Channel InputChannel              `json:"channel"`
	Filter  ChannelParticipantsFilter `json:"filter"`
	Offset  int32                     `json:"offset"`
	Limit   int32                     `json:"limit"`
	Hash    int32                     `json:"hash"`
}

func (st *TLchannels_getParticipants) ResetDefault() {
	st.Channel.ResetDefault()
	st.Filter.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_getParticipants) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Filter.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_getParticipants) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_getParticipants, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_getParticipants) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Filter.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_getParticipants) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getFeaturedStickers struct implement
type TLmessages_getFeaturedStickers struct {
	Hash int32 `json:"hash"`
}

func (st *TLmessages_getFeaturedStickers) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getFeaturedStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getFeaturedStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getFeaturedStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getFeaturedStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getFeaturedStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getOldFeaturedStickers struct implement
type TLmessages_getOldFeaturedStickers struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
	Hash   int32 `json:"hash"`
}

func (st *TLmessages_getOldFeaturedStickers) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getOldFeaturedStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Offset, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getOldFeaturedStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getOldFeaturedStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getOldFeaturedStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Offset, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getOldFeaturedStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_getCountriesList struct implement
type TLhelp_getCountriesList struct {
	Lang_code string `json:"lang_code"`
	Hash      int32  `json:"hash"`
}

func (st *TLhelp_getCountriesList) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_getCountriesList) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Lang_code, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_getCountriesList) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_getCountriesList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_getCountriesList) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Lang_code, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_getCountriesList) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getNotifySettings struct implement
type TLaccount_getNotifySettings struct {
	Peer InputNotifyPeer `json:"peer"`
}

func (st *TLaccount_getNotifySettings) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getNotifySettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getNotifySettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getNotifySettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getNotifySettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getNotifySettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_importContacts struct implement
type TLcontacts_importContacts struct {
	Contacts []InputContact `json:"contacts"`
}

func (st *TLcontacts_importContacts) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_importContacts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Contacts = make([]InputContact, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Contacts[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_importContacts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_importContacts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_importContacts) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Contacts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Contacts {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_importContacts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_sendCode struct implement
type TLauth_sendCode struct {
	Phone_number string       `json:"phone_number"`
	Api_id       int32        `json:"api_id"`
	Api_hash     string       `json:"api_hash"`
	Settings     CodeSettings `json:"settings"`
}

func (st *TLauth_sendCode) ResetDefault() {
	st.Settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_sendCode) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Phone_number, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Api_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Api_hash, 2, false)
	if err != nil {
		return err
	}

	err = st.Settings.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_sendCode) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_sendCode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_sendCode) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Phone_number, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Api_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Api_hash, 2)
	if err != nil {
		return err
	}

	err = st.Settings.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_sendCode) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_sendChangePhoneCode struct implement
type TLaccount_sendChangePhoneCode struct {
	Phone_number string       `json:"phone_number"`
	Settings     CodeSettings `json:"settings"`
}

func (st *TLaccount_sendChangePhoneCode) ResetDefault() {
	st.Settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_sendChangePhoneCode) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Phone_number, 0, false)
	if err != nil {
		return err
	}

	err = st.Settings.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_sendChangePhoneCode) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_sendChangePhoneCode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_sendChangePhoneCode) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Phone_number, 0)
	if err != nil {
		return err
	}

	err = st.Settings.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_sendChangePhoneCode) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_resendCode struct implement
type TLauth_resendCode struct {
	Phone_number    string `json:"phone_number"`
	Phone_code_hash string `json:"phone_code_hash"`
}

func (st *TLauth_resendCode) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_resendCode) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Phone_number, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone_code_hash, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_resendCode) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_resendCode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_resendCode) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Phone_number, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone_code_hash, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_resendCode) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_sendConfirmPhoneCode struct implement
type TLaccount_sendConfirmPhoneCode struct {
	Hash     string       `json:"hash"`
	Settings CodeSettings `json:"settings"`
}

func (st *TLaccount_sendConfirmPhoneCode) ResetDefault() {
	st.Settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_sendConfirmPhoneCode) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	err = st.Settings.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_sendConfirmPhoneCode) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_sendConfirmPhoneCode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_sendConfirmPhoneCode) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Hash, 0)
	if err != nil {
		return err
	}

	err = st.Settings.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_sendConfirmPhoneCode) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_sendVerifyPhoneCode struct implement
type TLaccount_sendVerifyPhoneCode struct {
	Phone_number string       `json:"phone_number"`
	Settings     CodeSettings `json:"settings"`
}

func (st *TLaccount_sendVerifyPhoneCode) ResetDefault() {
	st.Settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_sendVerifyPhoneCode) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Phone_number, 0, false)
	if err != nil {
		return err
	}

	err = st.Settings.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_sendVerifyPhoneCode) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_sendVerifyPhoneCode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_sendVerifyPhoneCode) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Phone_number, 0)
	if err != nil {
		return err
	}

	err = st.Settings.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_sendVerifyPhoneCode) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getWallPapers struct implement
type TLaccount_getWallPapers struct {
	Hash int32 `json:"hash"`
}

func (st *TLaccount_getWallPapers) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getWallPapers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getWallPapers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getWallPapers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getWallPapers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getWallPapers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLusers_getFullUser struct implement
type TLusers_getFullUser struct {
	Id InputUser `json:"id"`
}

func (st *TLusers_getFullUser) ResetDefault() {
	st.Id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLusers_getFullUser) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLusers_getFullUser) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLusers_getFullUser, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLusers_getFullUser) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLusers_getFullUser) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getMessageEditData struct implement
type TLmessages_getMessageEditData struct {
	Peer InputPeer `json:"peer"`
	Id   int32     `json:"id"`
}

func (st *TLmessages_getMessageEditData) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getMessageEditData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getMessageEditData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getMessageEditData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getMessageEditData) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getMessageEditData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_exportAuthorization struct implement
type TLauth_exportAuthorization struct {
	Dc_id int32 `json:"dc_id"`
}

func (st *TLauth_exportAuthorization) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_exportAuthorization) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Dc_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_exportAuthorization) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_exportAuthorization, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_exportAuthorization) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Dc_id, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_exportAuthorization) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_getPassportConfig struct implement
type TLhelp_getPassportConfig struct {
	Hash int32 `json:"hash"`
}

func (st *TLhelp_getPassportConfig) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_getPassportConfig) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_getPassportConfig) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_getPassportConfig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_getPassportConfig) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_getPassportConfig) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphone_requestCall struct implement
type TLphone_requestCall struct {
	Video     bool              `json:"video"`
	User_id   InputUser         `json:"user_id"`
	Random_id int32             `json:"random_id"`
	G_a_hash  []uint8           `json:"g_a_hash"`
	Protocol  PhoneCallProtocol `json:"protocol"`
}

func (st *TLphone_requestCall) ResetDefault() {
	st.User_id.ResetDefault()
	st.Protocol.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphone_requestCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Video, 0, false)
	if err != nil {
		return err
	}

	err = st.User_id.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Random_id, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.G_a_hash = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.G_a_hash[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.G_a_hash, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Protocol.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphone_requestCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphone_requestCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphone_requestCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Video, 0)
	if err != nil {
		return err
	}

	err = st.User_id.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Random_id, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.G_a_hash)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.G_a_hash {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = st.Protocol.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphone_requestCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphone_acceptCall struct implement
type TLphone_acceptCall struct {
	Peer     InputPhoneCall    `json:"peer"`
	G_b      []uint8           `json:"g_b"`
	Protocol PhoneCallProtocol `json:"protocol"`
}

func (st *TLphone_acceptCall) ResetDefault() {
	st.Peer.ResetDefault()
	st.Protocol.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphone_acceptCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.G_b = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.G_b[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.G_b, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Protocol.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphone_acceptCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphone_acceptCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphone_acceptCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.G_b)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.G_b {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = st.Protocol.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphone_acceptCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphone_confirmCall struct implement
type TLphone_confirmCall struct {
	Peer            InputPhoneCall    `json:"peer"`
	G_a             []uint8           `json:"g_a"`
	Key_fingerprint int64             `json:"key_fingerprint"`
	Protocol        PhoneCallProtocol `json:"protocol"`
}

func (st *TLphone_confirmCall) ResetDefault() {
	st.Peer.ResetDefault()
	st.Protocol.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphone_confirmCall) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.G_a = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.G_a[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.G_a, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int64(&st.Key_fingerprint, 2, false)
	if err != nil {
		return err
	}

	err = st.Protocol.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphone_confirmCall) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphone_confirmCall, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphone_confirmCall) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.G_a)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.G_a {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int64(st.Key_fingerprint, 2)
	if err != nil {
		return err
	}

	err = st.Protocol.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphone_confirmCall) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getArchivedStickers struct implement
type TLmessages_getArchivedStickers struct {
	Masks     bool  `json:"masks"`
	Offset_id int64 `json:"offset_id"`
	Limit     int32 `json:"limit"`
}

func (st *TLmessages_getArchivedStickers) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getArchivedStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Masks, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Offset_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getArchivedStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getArchivedStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getArchivedStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Masks, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Offset_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getArchivedStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLbots_sendCustomRequest struct implement
type TLbots_sendCustomRequest struct {
	Custom_method string   `json:"custom_method"`
	Params        DataJSON `json:"params"`
}

func (st *TLbots_sendCustomRequest) ResetDefault() {
	st.Params.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLbots_sendCustomRequest) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Custom_method, 0, false)
	if err != nil {
		return err
	}

	err = st.Params.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLbots_sendCustomRequest) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLbots_sendCustomRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLbots_sendCustomRequest) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Custom_method, 0)
	if err != nil {
		return err
	}

	err = st.Params.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLbots_sendCustomRequest) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphone_getCallConfig struct implement
type TLphone_getCallConfig struct {
}

func (st *TLphone_getCallConfig) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphone_getCallConfig) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphone_getCallConfig) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphone_getCallConfig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphone_getCallConfig) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphone_getCallConfig) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_exportChatInvite struct implement
type TLmessages_exportChatInvite struct {
	Peer InputPeer `json:"peer"`
}

func (st *TLmessages_exportChatInvite) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_exportChatInvite) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_exportChatInvite) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_exportChatInvite, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_exportChatInvite) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_exportChatInvite) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getDialogUnreadMarks struct implement
type TLmessages_getDialogUnreadMarks struct {
}

func (st *TLmessages_getDialogUnreadMarks) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getDialogUnreadMarks) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getDialogUnreadMarks) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getDialogUnreadMarks, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getDialogUnreadMarks) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getDialogUnreadMarks) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_getContacts struct implement
type TLcontacts_getContacts struct {
	Hash int32 `json:"hash"`
}

func (st *TLcontacts_getContacts) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_getContacts) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_getContacts) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_getContacts, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_getContacts) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_getContacts) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupload_reuploadCdnFile struct implement
type TLupload_reuploadCdnFile struct {
	File_token    []uint8 `json:"file_token"`
	Request_token []uint8 `json:"request_token"`
}

func (st *TLupload_reuploadCdnFile) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupload_reuploadCdnFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.File_token = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.File_token[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.File_token, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Request_token = make([]uint8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = _is.Read_uint8(&st.Request_token[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Request_token, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupload_reuploadCdnFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupload_reuploadCdnFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupload_reuploadCdnFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.File_token)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.File_token {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Request_token)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Request_token {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupload_reuploadCdnFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupload_getCdnFileHashes struct implement
type TLupload_getCdnFileHashes struct {
	File_token []uint8 `json:"file_token"`
	Offset     int32   `json:"offset"`
}

func (st *TLupload_getCdnFileHashes) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupload_getCdnFileHashes) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.File_token = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.File_token[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.File_token, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int32(&st.Offset, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupload_getCdnFileHashes) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupload_getCdnFileHashes, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupload_getCdnFileHashes) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.File_token)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.File_token {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int32(st.Offset, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupload_getCdnFileHashes) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupload_getFileHashes struct implement
type TLupload_getFileHashes struct {
	Location InputFileLocation `json:"location"`
	Offset   int32             `json:"offset"`
}

func (st *TLupload_getFileHashes) ResetDefault() {
	st.Location.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupload_getFileHashes) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Location.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupload_getFileHashes) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupload_getFileHashes, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupload_getFileHashes) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Location.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupload_getFileHashes) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_getUserInfo struct implement
type TLhelp_getUserInfo struct {
	User_id InputUser `json:"user_id"`
}

func (st *TLhelp_getUserInfo) ResetDefault() {
	st.User_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_getUserInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.User_id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_getUserInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_getUserInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_getUserInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.User_id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_getUserInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_editUserInfo struct implement
type TLhelp_editUserInfo struct {
	User_id  InputUser       `json:"user_id"`
	Message  string          `json:"message"`
	Entities []MessageEntity `json:"entities"`
}

func (st *TLhelp_editUserInfo) ResetDefault() {
	st.User_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_editUserInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.User_id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_editUserInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_editUserInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_editUserInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.User_id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_editUserInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpayments_getPaymentForm struct implement
type TLpayments_getPaymentForm struct {
	Msg_id int32 `json:"msg_id"`
}

func (st *TLpayments_getPaymentForm) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpayments_getPaymentForm) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Msg_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpayments_getPaymentForm) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpayments_getPaymentForm, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpayments_getPaymentForm) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Msg_id, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpayments_getPaymentForm) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstats_getMessageStats struct implement
type TLstats_getMessageStats struct {
	Dark    bool         `json:"dark"`
	Channel InputChannel `json:"channel"`
	Msg_id  int32        `json:"msg_id"`
}

func (st *TLstats_getMessageStats) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstats_getMessageStats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Dark, 0, false)
	if err != nil {
		return err
	}

	err = st.Channel.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Msg_id, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstats_getMessageStats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstats_getMessageStats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstats_getMessageStats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Dark, 0)
	if err != nil {
		return err
	}

	err = st.Channel.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Msg_id, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstats_getMessageStats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getStatsURL struct implement
type TLmessages_getStatsURL struct {
	Dark   bool      `json:"dark"`
	Peer   InputPeer `json:"peer"`
	Params string    `json:"params"`
}

func (st *TLmessages_getStatsURL) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getStatsURL) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Dark, 0, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Params, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getStatsURL) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getStatsURL, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getStatsURL) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Dark, 0)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Params, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getStatsURL) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getSavedGifs struct implement
type TLmessages_getSavedGifs struct {
	Hash int32 `json:"hash"`
}

func (st *TLmessages_getSavedGifs) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getSavedGifs) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getSavedGifs) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getSavedGifs, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getSavedGifs) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getSavedGifs) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getChats struct implement
type TLmessages_getChats struct {
	Id []int32 `json:"id"`
}

func (st *TLmessages_getChats) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getChats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getChats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getChats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getChats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getChats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_getChannels struct implement
type TLchannels_getChannels struct {
	Id []InputChannel `json:"id"`
}

func (st *TLchannels_getChannels) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_getChannels) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]InputChannel, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Id[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_getChannels) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_getChannels, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_getChannels) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_getChannels) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_getAdminedPublicChannels struct implement
type TLchannels_getAdminedPublicChannels struct {
	By_location bool `json:"by_location"`
	Check_limit bool `json:"check_limit"`
}

func (st *TLchannels_getAdminedPublicChannels) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_getAdminedPublicChannels) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.By_location, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Check_limit, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_getAdminedPublicChannels) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_getAdminedPublicChannels, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_getAdminedPublicChannels) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.By_location, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Check_limit, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_getAdminedPublicChannels) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getCommonChats struct implement
type TLmessages_getCommonChats struct {
	User_id InputUser `json:"user_id"`
	Max_id  int32     `json:"max_id"`
	Limit   int32     `json:"limit"`
}

func (st *TLmessages_getCommonChats) ResetDefault() {
	st.User_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getCommonChats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.User_id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getCommonChats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getCommonChats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getCommonChats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.User_id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getCommonChats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getAllChats struct implement
type TLmessages_getAllChats struct {
	Except_ids []int32 `json:"except_ids"`
}

func (st *TLmessages_getAllChats) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getAllChats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Except_ids = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Except_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getAllChats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getAllChats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getAllChats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Except_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Except_ids {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getAllChats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_getLeftChannels struct implement
type TLchannels_getLeftChannels struct {
	Offset int32 `json:"offset"`
}

func (st *TLchannels_getLeftChannels) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_getLeftChannels) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Offset, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_getLeftChannels) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_getLeftChannels, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_getLeftChannels) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Offset, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_getLeftChannels) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_getGroupsForDiscussion struct implement
type TLchannels_getGroupsForDiscussion struct {
}

func (st *TLchannels_getGroupsForDiscussion) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_getGroupsForDiscussion) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_getGroupsForDiscussion) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_getGroupsForDiscussion, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_getGroupsForDiscussion) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_getGroupsForDiscussion) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpayments_sendPaymentForm struct implement
type TLpayments_sendPaymentForm struct {
	Msg_id             int32                   `json:"msg_id"`
	Requested_info_id  string                  `json:"requested_info_id"`
	Shipping_option_id string                  `json:"shipping_option_id"`
	Credentials        InputPaymentCredentials `json:"credentials"`
}

func (st *TLpayments_sendPaymentForm) ResetDefault() {
	st.Credentials.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpayments_sendPaymentForm) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Msg_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Requested_info_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Shipping_option_id, 2, false)
	if err != nil {
		return err
	}

	err = st.Credentials.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpayments_sendPaymentForm) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpayments_sendPaymentForm, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpayments_sendPaymentForm) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Msg_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Requested_info_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Shipping_option_id, 2)
	if err != nil {
		return err
	}

	err = st.Credentials.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpayments_sendPaymentForm) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_createTheme struct implement
type TLaccount_createTheme struct {
	Slug     string             `json:"slug"`
	Title    string             `json:"title"`
	Document InputDocument      `json:"document"`
	Settings InputThemeSettings `json:"settings"`
}

func (st *TLaccount_createTheme) ResetDefault() {
	st.Document.ResetDefault()
	st.Settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_createTheme) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Slug, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 1, false)
	if err != nil {
		return err
	}

	err = st.Document.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = st.Settings.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_createTheme) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_createTheme, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_createTheme) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Slug, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 1)
	if err != nil {
		return err
	}

	err = st.Document.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = st.Settings.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_createTheme) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_updateTheme struct implement
type TLaccount_updateTheme struct {
	Format   string             `json:"format"`
	Theme    InputTheme         `json:"theme"`
	Slug     string             `json:"slug"`
	Title    string             `json:"title"`
	Document InputDocument      `json:"document"`
	Settings InputThemeSettings `json:"settings"`
}

func (st *TLaccount_updateTheme) ResetDefault() {
	st.Theme.ResetDefault()
	st.Document.ResetDefault()
	st.Settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_updateTheme) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Format, 0, false)
	if err != nil {
		return err
	}

	err = st.Theme.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Slug, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 3, false)
	if err != nil {
		return err
	}

	err = st.Document.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = st.Settings.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_updateTheme) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_updateTheme, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_updateTheme) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Format, 0)
	if err != nil {
		return err
	}

	err = st.Theme.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Slug, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 3)
	if err != nil {
		return err
	}

	err = st.Document.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = st.Settings.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_updateTheme) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getTheme struct implement
type TLaccount_getTheme struct {
	Format      string     `json:"format"`
	Theme       InputTheme `json:"theme"`
	Document_id int64      `json:"document_id"`
}

func (st *TLaccount_getTheme) ResetDefault() {
	st.Theme.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getTheme) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Format, 0, false)
	if err != nil {
		return err
	}

	err = st.Theme.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Document_id, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getTheme) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getTheme, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getTheme) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Format, 0)
	if err != nil {
		return err
	}

	err = st.Theme.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Document_id, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getTheme) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getSearchCounters struct implement
type TLmessages_getSearchCounters struct {
	Peer    InputPeer        `json:"peer"`
	Filters []MessagesFilter `json:"filters"`
}

func (st *TLmessages_getSearchCounters) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getSearchCounters) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Filters = make([]MessagesFilter, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Filters[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getSearchCounters) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getSearchCounters, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getSearchCounters) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Filters)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Filters {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getSearchCounters) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_signUp struct implement
type TLauth_signUp struct {
	Phone_number    string `json:"phone_number"`
	Phone_code_hash string `json:"phone_code_hash"`
	First_name      string `json:"first_name"`
	Last_name       string `json:"last_name"`
}

func (st *TLauth_signUp) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_signUp) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Phone_number, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone_code_hash, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.First_name, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Last_name, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_signUp) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_signUp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_signUp) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Phone_number, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone_code_hash, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.First_name, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Last_name, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_signUp) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_signIn struct implement
type TLauth_signIn struct {
	Phone_number    string `json:"phone_number"`
	Phone_code_hash string `json:"phone_code_hash"`
	Phone_code      string `json:"phone_code"`
}

func (st *TLauth_signIn) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_signIn) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Phone_number, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone_code_hash, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Phone_code, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_signIn) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_signIn, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_signIn) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Phone_number, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone_code_hash, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Phone_code, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_signIn) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_importAuthorization struct implement
type TLauth_importAuthorization struct {
	Id    int32   `json:"id"`
	Bytes []uint8 `json:"bytes"`
}

func (st *TLauth_importAuthorization) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_importAuthorization) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Bytes = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Bytes[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Bytes, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_importAuthorization) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_importAuthorization, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_importAuthorization) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Id, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Bytes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Bytes {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_importAuthorization) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_importBotAuthorization struct implement
type TLauth_importBotAuthorization struct {
	Flags          int32  `json:"flags"`
	Api_id         int32  `json:"api_id"`
	Api_hash       string `json:"api_hash"`
	Bot_auth_token string `json:"bot_auth_token"`
}

func (st *TLauth_importBotAuthorization) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_importBotAuthorization) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Flags, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Api_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Api_hash, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Bot_auth_token, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_importBotAuthorization) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_importBotAuthorization, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_importBotAuthorization) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Flags, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Api_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Api_hash, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Bot_auth_token, 3)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_importBotAuthorization) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_checkPassword struct implement
type TLauth_checkPassword struct {
	Password InputCheckPasswordSRP `json:"password"`
}

func (st *TLauth_checkPassword) ResetDefault() {
	st.Password.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_checkPassword) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Password.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_checkPassword) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_checkPassword, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_checkPassword) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Password.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_checkPassword) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_recoverPassword struct implement
type TLauth_recoverPassword struct {
	Code string `json:"code"`
}

func (st *TLauth_recoverPassword) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_recoverPassword) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Code, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_recoverPassword) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_recoverPassword, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_recoverPassword) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Code, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_recoverPassword) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getDhConfig struct implement
type TLmessages_getDhConfig struct {
	Version       int32 `json:"version"`
	Random_length int32 `json:"random_length"`
}

func (st *TLmessages_getDhConfig) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getDhConfig) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Version, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Random_length, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getDhConfig) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getDhConfig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getDhConfig) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Version, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Random_length, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getDhConfig) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_uploadEncryptedFile struct implement
type TLmessages_uploadEncryptedFile struct {
	Peer InputEncryptedChat `json:"peer"`
	File InputEncryptedFile `json:"file"`
}

func (st *TLmessages_uploadEncryptedFile) ResetDefault() {
	st.Peer.ResetDefault()
	st.File.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_uploadEncryptedFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.File.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_uploadEncryptedFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_uploadEncryptedFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_uploadEncryptedFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.File.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_uploadEncryptedFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_saveSecureValue struct implement
type TLaccount_saveSecureValue struct {
	Value            InputSecureValue `json:"value"`
	Secure_secret_id int64            `json:"secure_secret_id"`
}

func (st *TLaccount_saveSecureValue) ResetDefault() {
	st.Value.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_saveSecureValue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Value.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Secure_secret_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_saveSecureValue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_saveSecureValue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_saveSecureValue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Value.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Secure_secret_id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_saveSecureValue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getStickers struct implement
type TLmessages_getStickers struct {
	Emoticon string `json:"emoticon"`
	Hash     int32  `json:"hash"`
}

func (st *TLmessages_getStickers) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Emoticon, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Emoticon, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_getSupportName struct implement
type TLhelp_getSupportName struct {
}

func (st *TLhelp_getSupportName) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_getSupportName) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_getSupportName) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_getSupportName, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_getSupportName) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_getSupportName) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_getTopPeers struct implement
type TLcontacts_getTopPeers struct {
	Correspondents bool  `json:"correspondents"`
	Bots_pm        bool  `json:"bots_pm"`
	Bots_inline    bool  `json:"bots_inline"`
	Phone_calls    bool  `json:"phone_calls"`
	Forward_users  bool  `json:"forward_users"`
	Forward_chats  bool  `json:"forward_chats"`
	Groups         bool  `json:"groups"`
	Channels       bool  `json:"channels"`
	Offset         int32 `json:"offset"`
	Limit          int32 `json:"limit"`
	Hash           int32 `json:"hash"`
}

func (st *TLcontacts_getTopPeers) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_getTopPeers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Correspondents, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Bots_pm, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Bots_inline, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Phone_calls, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Forward_users, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Forward_chats, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Groups, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Channels, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 10, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_getTopPeers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_getTopPeers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_getTopPeers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Correspondents, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Bots_pm, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Bots_inline, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Phone_calls, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Forward_users, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Forward_chats, 5)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Groups, 6)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Channels, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 10)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_getTopPeers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getFavedStickers struct implement
type TLmessages_getFavedStickers struct {
	Hash int32 `json:"hash"`
}

func (st *TLmessages_getFavedStickers) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getFavedStickers) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getFavedStickers) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getFavedStickers, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getFavedStickers) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Hash, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getFavedStickers) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpayments_getBankCardData struct implement
type TLpayments_getBankCardData struct {
	Number string `json:"number"`
}

func (st *TLpayments_getBankCardData) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpayments_getBankCardData) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Number, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpayments_getBankCardData) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpayments_getBankCardData, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpayments_getBankCardData) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Number, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpayments_getBankCardData) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getDiscussionMessage struct implement
type TLmessages_getDiscussionMessage struct {
	Peer   InputPeer `json:"peer"`
	Msg_id int32     `json:"msg_id"`
}

func (st *TLmessages_getDiscussionMessage) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getDiscussionMessage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Msg_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getDiscussionMessage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getDiscussionMessage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getDiscussionMessage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Msg_id, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getDiscussionMessage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_requestEncryption struct implement
type TLmessages_requestEncryption struct {
	User_id   InputUser `json:"user_id"`
	Random_id int32     `json:"random_id"`
	G_a       []uint8   `json:"g_a"`
}

func (st *TLmessages_requestEncryption) ResetDefault() {
	st.User_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_requestEncryption) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.User_id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Random_id, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.G_a = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.G_a[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.G_a, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_requestEncryption) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_requestEncryption, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_requestEncryption) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.User_id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Random_id, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.G_a)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.G_a {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_requestEncryption) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_acceptEncryption struct implement
type TLmessages_acceptEncryption struct {
	Peer            InputEncryptedChat `json:"peer"`
	G_b             []uint8            `json:"g_b"`
	Key_fingerprint int64              `json:"key_fingerprint"`
}

func (st *TLmessages_acceptEncryption) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_acceptEncryption) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.G_b = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.G_b[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.G_b, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int64(&st.Key_fingerprint, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_acceptEncryption) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_acceptEncryption, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_acceptEncryption) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.G_b)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.G_b {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int64(st.Key_fingerprint, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_acceptEncryption) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupdates_getChannelDifference struct implement
type TLupdates_getChannelDifference struct {
	Force   bool                  `json:"force"`
	Channel InputChannel          `json:"channel"`
	Filter  ChannelMessagesFilter `json:"filter"`
	Pts     int32                 `json:"pts"`
	Limit   int32                 `json:"limit"`
}

func (st *TLupdates_getChannelDifference) ResetDefault() {
	st.Channel.ResetDefault()
	st.Filter.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupdates_getChannelDifference) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Force, 0, false)
	if err != nil {
		return err
	}

	err = st.Channel.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.Filter.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Pts, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupdates_getChannelDifference) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupdates_getChannelDifference, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupdates_getChannelDifference) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Force, 0)
	if err != nil {
		return err
	}

	err = st.Channel.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.Filter.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Pts, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupdates_getChannelDifference) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getWebPagePreview struct implement
type TLmessages_getWebPagePreview struct {
	Message  string          `json:"message"`
	Entities []MessageEntity `json:"entities"`
}

func (st *TLmessages_getWebPagePreview) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getWebPagePreview) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Message, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Entities = make([]MessageEntity, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Entities[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getWebPagePreview) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getWebPagePreview, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getWebPagePreview) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Message, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Entities)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Entities {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getWebPagePreview) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_uploadMedia struct implement
type TLmessages_uploadMedia struct {
	Peer  InputPeer  `json:"peer"`
	Media InputMedia `json:"media"`
}

func (st *TLmessages_uploadMedia) ResetDefault() {
	st.Peer.ResetDefault()
	st.Media.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_uploadMedia) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Media.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_uploadMedia) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_uploadMedia, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_uploadMedia) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Media.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_uploadMedia) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getOnlines struct implement
type TLmessages_getOnlines struct {
	Peer InputPeer `json:"peer"`
}

func (st *TLmessages_getOnlines) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getOnlines) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getOnlines) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getOnlines, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getOnlines) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getOnlines) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_getRecentMeUrls struct implement
type TLhelp_getRecentMeUrls struct {
	Referer string `json:"referer"`
}

func (st *TLhelp_getRecentMeUrls) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_getRecentMeUrls) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Referer, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_getRecentMeUrls) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_getRecentMeUrls, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_getRecentMeUrls) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Referer, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_getRecentMeUrls) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpayments_getPaymentReceipt struct implement
type TLpayments_getPaymentReceipt struct {
	Msg_id int32 `json:"msg_id"`
}

func (st *TLpayments_getPaymentReceipt) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpayments_getPaymentReceipt) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Msg_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpayments_getPaymentReceipt) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpayments_getPaymentReceipt, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpayments_getPaymentReceipt) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Msg_id, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpayments_getPaymentReceipt) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getFullChat struct implement
type TLmessages_getFullChat struct {
	Chat_id int32 `json:"chat_id"`
}

func (st *TLmessages_getFullChat) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getFullChat) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Chat_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getFullChat) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getFullChat, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getFullChat) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Chat_id, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getFullChat) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_getFullChannel struct implement
type TLchannels_getFullChannel struct {
	Channel InputChannel `json:"channel"`
}

func (st *TLchannels_getFullChannel) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_getFullChannel) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_getFullChannel) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_getFullChannel, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_getFullChannel) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_getFullChannel) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLupload_getWebFile struct implement
type TLupload_getWebFile struct {
	Location InputWebFileLocation `json:"location"`
	Offset   int32                `json:"offset"`
	Limit    int32                `json:"limit"`
}

func (st *TLupload_getWebFile) ResetDefault() {
	st.Location.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLupload_getWebFile) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Location.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLupload_getWebFile) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLupload_getWebFile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLupload_getWebFile) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Location.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLupload_getWebFile) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getAutoDownloadSettings struct implement
type TLaccount_getAutoDownloadSettings struct {
}

func (st *TLaccount_getAutoDownloadSettings) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getAutoDownloadSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getAutoDownloadSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getAutoDownloadSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getAutoDownloadSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getAutoDownloadSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getWebPage struct implement
type TLmessages_getWebPage struct {
	Url  string `json:"url"`
	Hash int32  `json:"hash"`
}

func (st *TLmessages_getWebPage) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getWebPage) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Url, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getWebPage) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getWebPage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getWebPage) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Url, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getWebPage) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstats_getBroadcastStats struct implement
type TLstats_getBroadcastStats struct {
	Dark    bool         `json:"dark"`
	Channel InputChannel `json:"channel"`
}

func (st *TLstats_getBroadcastStats) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstats_getBroadcastStats) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Dark, 0, false)
	if err != nil {
		return err
	}

	err = st.Channel.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstats_getBroadcastStats) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstats_getBroadcastStats, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstats_getBroadcastStats) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Dark, 0)
	if err != nil {
		return err
	}

	err = st.Channel.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstats_getBroadcastStats) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLauth_acceptLoginToken struct implement
type TLauth_acceptLoginToken struct {
	Token []uint8 `json:"token"`
}

func (st *TLauth_acceptLoginToken) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLauth_acceptLoginToken) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Token = make([]uint8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_uint8(&st.Token[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			err = _is.Read_slice_uint8(&st.Token, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLauth_acceptLoginToken) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLauth_acceptLoginToken, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLauth_acceptLoginToken) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Token)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Token {

		err = _os.Write_uint8(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLauth_acceptLoginToken) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_getConfig struct implement
type TLhelp_getConfig struct {
}

func (st *TLhelp_getConfig) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_getConfig) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_getConfig) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_getConfig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_getConfig) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_getConfig) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getGameHighScores struct implement
type TLmessages_getGameHighScores struct {
	Peer    InputPeer `json:"peer"`
	Id      int32     `json:"id"`
	User_id InputUser `json:"user_id"`
}

func (st *TLmessages_getGameHighScores) ResetDefault() {
	st.Peer.ResetDefault()
	st.User_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getGameHighScores) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Id, 1, false)
	if err != nil {
		return err
	}

	err = st.User_id.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getGameHighScores) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getGameHighScores, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getGameHighScores) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Id, 1)
	if err != nil {
		return err
	}

	err = st.User_id.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getGameHighScores) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getInlineGameHighScores struct implement
type TLmessages_getInlineGameHighScores struct {
	Id      InputBotInlineMessageID `json:"id"`
	User_id InputUser               `json:"user_id"`
}

func (st *TLmessages_getInlineGameHighScores) ResetDefault() {
	st.Id.ResetDefault()
	st.User_id.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getInlineGameHighScores) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Id.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.User_id.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getInlineGameHighScores) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getInlineGameHighScores, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getInlineGameHighScores) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Id.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.User_id.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getInlineGameHighScores) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getPrivacy struct implement
type TLaccount_getPrivacy struct {
	Key_key InputPrivacyKey `json:"key_key"`
}

func (st *TLaccount_getPrivacy) ResetDefault() {
	st.Key_key.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getPrivacy) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Key_key.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getPrivacy) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getPrivacy, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getPrivacy) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Key_key.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getPrivacy) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_setPrivacy struct implement
type TLaccount_setPrivacy struct {
	Key_key InputPrivacyKey    `json:"key_key"`
	Rules   []InputPrivacyRule `json:"rules"`
}

func (st *TLaccount_setPrivacy) ResetDefault() {
	st.Key_key.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_setPrivacy) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Key_key.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Rules = make([]InputPrivacyRule, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Rules[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_setPrivacy) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_setPrivacy, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_setPrivacy) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Key_key.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Rules)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Rules {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_setPrivacy) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_getSaved struct implement
type TLcontacts_getSaved struct {
}

func (st *TLcontacts_getSaved) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_getSaved) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_getSaved) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_getSaved, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_getSaved) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_getSaved) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLlangpack_getStrings struct implement
type TLlangpack_getStrings struct {
	Lang_pack string   `json:"lang_pack"`
	Lang_code string   `json:"lang_code"`
	Keys      []string `json:"keys"`
}

func (st *TLlangpack_getStrings) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLlangpack_getStrings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Lang_pack, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Lang_code, 1, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Keys = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_string(&st.Keys[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLlangpack_getStrings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLlangpack_getStrings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLlangpack_getStrings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Lang_pack, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Lang_code, 1)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Keys)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Keys {

		err = _os.Write_string(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLlangpack_getStrings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_getDeepLinkInfo struct implement
type TLhelp_getDeepLinkInfo struct {
	Path string `json:"path"`
}

func (st *TLhelp_getDeepLinkInfo) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_getDeepLinkInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Path, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_getDeepLinkInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_getDeepLinkInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_getDeepLinkInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Path, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_getDeepLinkInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_getAdminLog struct implement
type TLchannels_getAdminLog struct {
	Channel       InputChannel                `json:"channel"`
	Q             string                      `json:"q"`
	Events_filter ChannelAdminLogEventsFilter `json:"events_filter"`
	Admins        []InputUser                 `json:"admins"`
	Max_id        int64                       `json:"max_id"`
	Min_id        int64                       `json:"min_id"`
	Limit         int32                       `json:"limit"`
}

func (st *TLchannels_getAdminLog) ResetDefault() {
	st.Channel.ResetDefault()
	st.Events_filter.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_getAdminLog) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Q, 1, false)
	if err != nil {
		return err
	}

	err = st.Events_filter.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Admins = make([]InputUser, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Admins[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = _is.Read_int64(&st.Max_id, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.Min_id, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_getAdminLog) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_getAdminLog, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_getAdminLog) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Q, 1)
	if err != nil {
		return err
	}

	err = st.Events_filter.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Admins)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Admins {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	err = _os.Write_int64(st.Max_id, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.Min_id, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 6)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_getAdminLog) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getTmpPassword struct implement
type TLaccount_getTmpPassword struct {
	Password InputCheckPasswordSRP `json:"password"`
	Period   int32                 `json:"period"`
}

func (st *TLaccount_getTmpPassword) ResetDefault() {
	st.Password.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getTmpPassword) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Password.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Period, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getTmpPassword) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getTmpPassword, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getTmpPassword) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Password.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Period, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getTmpPassword) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_initTakeoutSession struct implement
type TLaccount_initTakeoutSession struct {
	Contacts           bool  `json:"contacts"`
	Message_users      bool  `json:"message_users"`
	Message_chats      bool  `json:"message_chats"`
	Message_megagroups bool  `json:"message_megagroups"`
	Message_channels   bool  `json:"message_channels"`
	Files              bool  `json:"files"`
	File_max_size      int32 `json:"file_max_size"`
}

func (st *TLaccount_initTakeoutSession) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_initTakeoutSession) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Contacts, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Message_users, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Message_chats, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Message_megagroups, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Message_channels, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Files, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.File_max_size, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_initTakeoutSession) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_initTakeoutSession, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_initTakeoutSession) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Contacts, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Message_users, 1)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Message_chats, 2)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Message_megagroups, 3)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Message_channels, 4)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Files, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.File_max_size, 6)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_initTakeoutSession) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLpayments_validateRequestedInfo struct implement
type TLpayments_validateRequestedInfo struct {
	Save   bool                 `json:"save"`
	Msg_id int32                `json:"msg_id"`
	Info   PaymentRequestedInfo `json:"info"`
}

func (st *TLpayments_validateRequestedInfo) ResetDefault() {
	st.Info.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLpayments_validateRequestedInfo) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Save, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Msg_id, 1, false)
	if err != nil {
		return err
	}

	err = st.Info.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLpayments_validateRequestedInfo) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLpayments_validateRequestedInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLpayments_validateRequestedInfo) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Save, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Msg_id, 1)
	if err != nil {
		return err
	}

	err = st.Info.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLpayments_validateRequestedInfo) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_getInactiveChannels struct implement
type TLchannels_getInactiveChannels struct {
}

func (st *TLchannels_getInactiveChannels) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_getInactiveChannels) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_getInactiveChannels) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_getInactiveChannels, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_getInactiveChannels) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_getInactiveChannels) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getSplitRanges struct implement
type TLmessages_getSplitRanges struct {
}

func (st *TLmessages_getSplitRanges) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getSplitRanges) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getSplitRanges) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getSplitRanges, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getSplitRanges) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getSplitRanges) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_checkChatInvite struct implement
type TLmessages_checkChatInvite struct {
	Hash string `json:"hash"`
}

func (st *TLmessages_checkChatInvite) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_checkChatInvite) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Hash, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_checkChatInvite) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_checkChatInvite, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_checkChatInvite) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Hash, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_checkChatInvite) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getGlobalPrivacySettings struct implement
type TLaccount_getGlobalPrivacySettings struct {
}

func (st *TLaccount_getGlobalPrivacySettings) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getGlobalPrivacySettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getGlobalPrivacySettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getGlobalPrivacySettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getGlobalPrivacySettings) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getGlobalPrivacySettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_setGlobalPrivacySettings struct implement
type TLaccount_setGlobalPrivacySettings struct {
	Settings GlobalPrivacySettings `json:"settings"`
}

func (st *TLaccount_setGlobalPrivacySettings) ResetDefault() {
	st.Settings.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_setGlobalPrivacySettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Settings.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_setGlobalPrivacySettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_setGlobalPrivacySettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_setGlobalPrivacySettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Settings.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_setGlobalPrivacySettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getStickerSet struct implement
type TLmessages_getStickerSet struct {
	Stickerset InputStickerSet `json:"stickerset"`
}

func (st *TLmessages_getStickerSet) ResetDefault() {
	st.Stickerset.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getStickerSet) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Stickerset.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getStickerSet) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getStickerSet, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getStickerSet) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Stickerset.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getStickerSet) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstickers_createStickerSet struct implement
type TLstickers_createStickerSet struct {
	Masks      bool                  `json:"masks"`
	Animated   bool                  `json:"animated"`
	User_id    InputUser             `json:"user_id"`
	Title      string                `json:"title"`
	Short_name string                `json:"short_name"`
	Thumb      InputDocument         `json:"thumb"`
	Stickers   []InputStickerSetItem `json:"stickers"`
}

func (st *TLstickers_createStickerSet) ResetDefault() {
	st.User_id.ResetDefault()
	st.Thumb.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstickers_createStickerSet) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_bool(&st.Masks, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_bool(&st.Animated, 1, false)
	if err != nil {
		return err
	}

	err = st.User_id.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Title, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Short_name, 4, false)
	if err != nil {
		return err
	}

	err = st.Thumb.ReadBlock(_is, 5, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Stickers = make([]InputStickerSetItem, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Stickers[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstickers_createStickerSet) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstickers_createStickerSet, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstickers_createStickerSet) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_bool(st.Masks, 0)
	if err != nil {
		return err
	}

	err = _os.Write_bool(st.Animated, 1)
	if err != nil {
		return err
	}

	err = st.User_id.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Title, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Short_name, 4)
	if err != nil {
		return err
	}

	err = st.Thumb.WriteBlock(_os, 5)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Stickers)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Stickers {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstickers_createStickerSet) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstickers_removeStickerFromSet struct implement
type TLstickers_removeStickerFromSet struct {
	Sticker InputDocument `json:"sticker"`
}

func (st *TLstickers_removeStickerFromSet) ResetDefault() {
	st.Sticker.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstickers_removeStickerFromSet) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Sticker.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstickers_removeStickerFromSet) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstickers_removeStickerFromSet, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstickers_removeStickerFromSet) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Sticker.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstickers_removeStickerFromSet) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstickers_changeStickerPosition struct implement
type TLstickers_changeStickerPosition struct {
	Sticker  InputDocument `json:"sticker"`
	Position int32         `json:"position"`
}

func (st *TLstickers_changeStickerPosition) ResetDefault() {
	st.Sticker.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstickers_changeStickerPosition) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Sticker.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Position, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstickers_changeStickerPosition) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstickers_changeStickerPosition, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstickers_changeStickerPosition) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Sticker.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Position, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstickers_changeStickerPosition) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstickers_addStickerToSet struct implement
type TLstickers_addStickerToSet struct {
	Stickerset InputStickerSet     `json:"stickerset"`
	Sticker    InputStickerSetItem `json:"sticker"`
}

func (st *TLstickers_addStickerToSet) ResetDefault() {
	st.Stickerset.ResetDefault()
	st.Sticker.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstickers_addStickerToSet) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Stickerset.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Sticker.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstickers_addStickerToSet) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstickers_addStickerToSet, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstickers_addStickerToSet) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Stickerset.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Sticker.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstickers_addStickerToSet) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstickers_setStickerSetThumb struct implement
type TLstickers_setStickerSetThumb struct {
	Stickerset InputStickerSet `json:"stickerset"`
	Thumb      InputDocument   `json:"thumb"`
}

func (st *TLstickers_setStickerSetThumb) ResetDefault() {
	st.Stickerset.ResetDefault()
	st.Thumb.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstickers_setStickerSetThumb) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Stickerset.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Thumb.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstickers_setStickerSetThumb) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstickers_setStickerSetThumb, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstickers_setStickerSetThumb) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Stickerset.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Thumb.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstickers_setStickerSetThumb) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getPassword struct implement
type TLaccount_getPassword struct {
}

func (st *TLaccount_getPassword) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getPassword) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getPassword) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getPassword, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getPassword) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getPassword) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getInlineBotResults struct implement
type TLmessages_getInlineBotResults struct {
	Bot       InputUser     `json:"bot"`
	Peer      InputPeer     `json:"peer"`
	Geo_point InputGeoPoint `json:"geo_point"`
	Query     string        `json:"query"`
	Offset    string        `json:"offset"`
}

func (st *TLmessages_getInlineBotResults) ResetDefault() {
	st.Bot.ResetDefault()
	st.Peer.ResetDefault()
	st.Geo_point.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getInlineBotResults) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Bot.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = st.Peer.ReadBlock(_is, 1, false)
	if err != nil {
		return err
	}

	err = st.Geo_point.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Query, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Offset, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getInlineBotResults) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getInlineBotResults, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getInlineBotResults) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Bot.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = st.Peer.WriteBlock(_os, 1)
	if err != nil {
		return err
	}

	err = st.Geo_point.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Query, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Offset, 4)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getInlineBotResults) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getEmojiURL struct implement
type TLmessages_getEmojiURL struct {
	Lang_code string `json:"lang_code"`
}

func (st *TLmessages_getEmojiURL) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getEmojiURL) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Lang_code, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getEmojiURL) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getEmojiURL, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getEmojiURL) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Lang_code, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getEmojiURL) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLcontacts_getStatuses struct implement
type TLcontacts_getStatuses struct {
}

func (st *TLcontacts_getStatuses) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLcontacts_getStatuses) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLcontacts_getStatuses) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLcontacts_getStatuses, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLcontacts_getStatuses) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLcontacts_getStatuses) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLhelp_getAppUpdate struct implement
type TLhelp_getAppUpdate struct {
	Source string `json:"source"`
}

func (st *TLhelp_getAppUpdate) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLhelp_getAppUpdate) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.Source, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLhelp_getAppUpdate) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLhelp_getAppUpdate, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLhelp_getAppUpdate) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.Source, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLhelp_getAppUpdate) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getPeerSettings struct implement
type TLmessages_getPeerSettings struct {
	Peer InputPeer `json:"peer"`
}

func (st *TLmessages_getPeerSettings) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getPeerSettings) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getPeerSettings) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getPeerSettings, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getPeerSettings) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getPeerSettings) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getMessages struct implement
type TLmessages_getMessages struct {
	Id []InputMessage `json:"id"`
}

func (st *TLmessages_getMessages) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]InputMessage, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Id[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getHistory struct implement
type TLmessages_getHistory struct {
	Peer        InputPeer `json:"peer"`
	Offset_id   int32     `json:"offset_id"`
	Offset_date int32     `json:"offset_date"`
	Add_offset  int32     `json:"add_offset"`
	Limit       int32     `json:"limit"`
	Max_id      int32     `json:"max_id"`
	Min_id      int32     `json:"min_id"`
	Hash        int32     `json:"hash"`
}

func (st *TLmessages_getHistory) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getHistory) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset_date, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Add_offset, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_id, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Min_id, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getHistory) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getHistory) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset_date, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Add_offset, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_id, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Min_id, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 7)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getHistory) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_search struct implement
type TLmessages_search struct {
	Peer       InputPeer      `json:"peer"`
	Q          string         `json:"q"`
	From_id    InputPeer      `json:"from_id"`
	Top_msg_id int32          `json:"top_msg_id"`
	Filter     MessagesFilter `json:"filter"`
	Min_date   int32          `json:"min_date"`
	Max_date   int32          `json:"max_date"`
	Offset_id  int32          `json:"offset_id"`
	Add_offset int32          `json:"add_offset"`
	Limit      int32          `json:"limit"`
	Max_id     int32          `json:"max_id"`
	Min_id     int32          `json:"min_id"`
	Hash       int32          `json:"hash"`
}

func (st *TLmessages_search) ResetDefault() {
	st.Peer.ResetDefault()
	st.From_id.ResetDefault()
	st.Filter.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_search) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Q, 1, false)
	if err != nil {
		return err
	}

	err = st.From_id.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Top_msg_id, 3, false)
	if err != nil {
		return err
	}

	err = st.Filter.ReadBlock(_is, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Min_date, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_date, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset_id, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Add_offset, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_id, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Min_id, 11, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 12, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_search) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_search, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_search) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Q, 1)
	if err != nil {
		return err
	}

	err = st.From_id.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Top_msg_id, 3)
	if err != nil {
		return err
	}

	err = st.Filter.WriteBlock(_os, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Min_date, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_date, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset_id, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Add_offset, 8)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 9)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_id, 10)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Min_id, 11)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 12)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_search) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLchannels_getMessages struct implement
type TLchannels_getMessages struct {
	Channel InputChannel   `json:"channel"`
	Id      []InputMessage `json:"id"`
}

func (st *TLchannels_getMessages) ResetDefault() {
	st.Channel.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLchannels_getMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]InputMessage, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Id[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLchannels_getMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLchannels_getMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLchannels_getMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLchannels_getMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_searchGlobal struct implement
type TLmessages_searchGlobal struct {
	Folder_id   int32          `json:"folder_id"`
	Q           string         `json:"q"`
	Filter      MessagesFilter `json:"filter"`
	Min_date    int32          `json:"min_date"`
	Max_date    int32          `json:"max_date"`
	Offset_rate int32          `json:"offset_rate"`
	Offset_peer InputPeer      `json:"offset_peer"`
	Offset_id   int32          `json:"offset_id"`
	Limit       int32          `json:"limit"`
}

func (st *TLmessages_searchGlobal) ResetDefault() {
	st.Filter.ResetDefault()
	st.Offset_peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_searchGlobal) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Folder_id, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Q, 1, false)
	if err != nil {
		return err
	}

	err = st.Filter.ReadBlock(_is, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Min_date, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_date, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset_rate, 5, false)
	if err != nil {
		return err
	}

	err = st.Offset_peer.ReadBlock(_is, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset_id, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_searchGlobal) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_searchGlobal, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_searchGlobal) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Folder_id, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Q, 1)
	if err != nil {
		return err
	}

	err = st.Filter.WriteBlock(_os, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Min_date, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_date, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset_rate, 5)
	if err != nil {
		return err
	}

	err = st.Offset_peer.WriteBlock(_os, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset_id, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 8)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_searchGlobal) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getUnreadMentions struct implement
type TLmessages_getUnreadMentions struct {
	Peer       InputPeer `json:"peer"`
	Offset_id  int32     `json:"offset_id"`
	Add_offset int32     `json:"add_offset"`
	Limit      int32     `json:"limit"`
	Max_id     int32     `json:"max_id"`
	Min_id     int32     `json:"min_id"`
}

func (st *TLmessages_getUnreadMentions) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getUnreadMentions) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Add_offset, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_id, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Min_id, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getUnreadMentions) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getUnreadMentions, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getUnreadMentions) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Add_offset, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_id, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Min_id, 5)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getUnreadMentions) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getRecentLocations struct implement
type TLmessages_getRecentLocations struct {
	Peer  InputPeer `json:"peer"`
	Limit int32     `json:"limit"`
	Hash  int32     `json:"hash"`
}

func (st *TLmessages_getRecentLocations) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getRecentLocations) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getRecentLocations) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getRecentLocations, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getRecentLocations) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getRecentLocations) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getScheduledHistory struct implement
type TLmessages_getScheduledHistory struct {
	Peer InputPeer `json:"peer"`
	Hash int32     `json:"hash"`
}

func (st *TLmessages_getScheduledHistory) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getScheduledHistory) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getScheduledHistory) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getScheduledHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getScheduledHistory) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getScheduledHistory) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getScheduledMessages struct implement
type TLmessages_getScheduledMessages struct {
	Peer InputPeer `json:"peer"`
	Id   []int32   `json:"id"`
}

func (st *TLmessages_getScheduledMessages) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getScheduledMessages) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err, have, ty = _is.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = _is.Read_int32(&st.Id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getScheduledMessages) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getScheduledMessages, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getScheduledMessages) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getScheduledMessages) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_getReplies struct implement
type TLmessages_getReplies struct {
	Peer        InputPeer `json:"peer"`
	Msg_id      int32     `json:"msg_id"`
	Offset_id   int32     `json:"offset_id"`
	Offset_date int32     `json:"offset_date"`
	Add_offset  int32     `json:"add_offset"`
	Limit       int32     `json:"limit"`
	Max_id      int32     `json:"max_id"`
	Min_id      int32     `json:"min_id"`
	Hash        int32     `json:"hash"`
}

func (st *TLmessages_getReplies) ResetDefault() {
	st.Peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_getReplies) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Peer.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Msg_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset_id, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset_date, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Add_offset, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Max_id, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Min_id, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Hash, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_getReplies) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_getReplies, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_getReplies) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Peer.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Msg_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset_id, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset_date, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Add_offset, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 5)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Max_id, 6)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Min_id, 7)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Hash, 8)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_getReplies) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLstats_getMessagePublicForwards struct implement
type TLstats_getMessagePublicForwards struct {
	Channel     InputChannel `json:"channel"`
	Msg_id      int32        `json:"msg_id"`
	Offset_rate int32        `json:"offset_rate"`
	Offset_peer InputPeer    `json:"offset_peer"`
	Offset_id   int32        `json:"offset_id"`
	Limit       int32        `json:"limit"`
}

func (st *TLstats_getMessagePublicForwards) ResetDefault() {
	st.Channel.ResetDefault()
	st.Offset_peer.ResetDefault()
}

//ReadFrom reads  from _is and put into struct.
func (st *TLstats_getMessagePublicForwards) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = st.Channel.ReadBlock(_is, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Msg_id, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset_rate, 2, false)
	if err != nil {
		return err
	}

	err = st.Offset_peer.ReadBlock(_is, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Offset_id, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Limit, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLstats_getMessagePublicForwards) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLstats_getMessagePublicForwards, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLstats_getMessagePublicForwards) WriteTo(_os *codec.Buffer) error {
	var err error

	err = st.Channel.WriteBlock(_os, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Msg_id, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset_rate, 2)
	if err != nil {
		return err
	}

	err = st.Offset_peer.WriteBlock(_os, 3)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Offset_id, 4)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Limit, 5)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLstats_getMessagePublicForwards) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLaccount_getAuthorizations struct implement
type TLaccount_getAuthorizations struct {
}

func (st *TLaccount_getAuthorizations) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLaccount_getAuthorizations) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLaccount_getAuthorizations) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLaccount_getAuthorizations, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLaccount_getAuthorizations) WriteTo(_os *codec.Buffer) error {
	var err error

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLaccount_getAuthorizations) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLphotos_deletePhotos struct implement
type TLphotos_deletePhotos struct {
	Id []InputPhoto `json:"id"`
}

func (st *TLphotos_deletePhotos) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLphotos_deletePhotos) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err, have, ty = _is.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Id = make([]InputPhoto, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Id[i0].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("not support simple_list type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLphotos_deletePhotos) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLphotos_deletePhotos, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLphotos_deletePhotos) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(int32(len(st.Id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Id {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return err
		}

	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLphotos_deletePhotos) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// TLmessages_receivedQueue struct implement
type TLmessages_receivedQueue struct {
	Max_qts int32 `json:"max_qts"`
}

func (st *TLmessages_receivedQueue) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *TLmessages_receivedQueue) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Max_qts, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *TLmessages_receivedQueue) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TLmessages_receivedQueue, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *TLmessages_receivedQueue) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Max_qts, 0)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *TLmessages_receivedQueue) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}
