package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
)

//file
type ParamsType struct {
	Name string `json:"name"`
	Type string `json:"type"`
}
type Constructors struct {
	ID        string       `json:"id"`
	Predicate string       `json:"predicate"`
	Params    []ParamsType `json:"params"`
	Type      string       `json:"type"`
}
type Methods struct {
	ID     string       `json:"id"`
	Method string       `json:"method"`
	Params []ParamsType `json:"params"`
	Type   string       `json:"type"`
}
type AutoGenerated struct {
	Constructors []Constructors `json:"constructors"`
	Methods      []Methods      `json:"methods"`
}

//pd
type PbConstructorsStruct struct {
	Type   map[string][]Constructors
	Params map[string][]ParamsType
}
type PbMethodsStruct struct {
	Type   map[string][]Methods
	Params map[string][]ParamsType
}

var TLjson AutoGenerated
var PbConstructors = PbConstructorsStruct{
	Type:   make(map[string][]Constructors),
	Params: make(map[string][]ParamsType),
}
var PbMethods = PbMethodsStruct{
	Type:   make(map[string][]Methods),
	Params: make(map[string][]ParamsType),
}

func Readfile(filename string) ([]byte, error) {
	var (
		err     error
		content []byte
	)
	content, err = ioutil.ReadFile(filename)
	if err != nil {
		fmt.Println(err)
		return nil, err
	}
	return content, nil
}

func JsonToStruct(filename string) error {

	b, err := Readfile(filename)
	if err != nil {

		fmt.Println("Readfile failed:", err)
		return err
	}
	err = json.Unmarshal(b, &TLjson)
	if err != nil {

		fmt.Println("Umarshal failed:", err)
		return err
	}

	return nil
}

func MethodsExtractionType() {
	for _, value := range TLjson.Methods {
		PbMethods.Type[value.Type] = append(PbMethods.Type[value.Type], value)
		//参数
		for _, vv := range value.Params {
			if ParamsTypeDeduplication(PbMethods.Params[value.Type], vv) {
				PbMethods.Params[value.Type] = append(PbMethods.Params[value.Type], vv)
			}
		}

	}
}
func ConstructorsExtractionType() {
	for _, value := range TLjson.Constructors {
		PbConstructors.Type[value.Type] = append(PbConstructors.Type[value.Type], value)
		//参数
		for _, vv := range value.Params {
			if ParamsTypeDeduplication(PbConstructors.Params[value.Type], vv) {
				PbConstructors.Params[value.Type] = append(PbConstructors.Params[value.Type], vv)
			}
		}

	}
}

func ParamsTypeDeduplication(ps []ParamsType, p ParamsType) bool {

	if len(ps) < 1 {
		return true
	}
	for _, v := range ps {
		if v.Type == p.Type && v.Name == p.Name {
			return false
		}
	}
	return true
}
